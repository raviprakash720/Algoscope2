[
  {
    "id": 1,
    "title": "Two Sum",
    "slug": "two-sum",
    "difficulty": "Easy",
    "algorithmType": "two_pointer",
    "status": "strong",
    "tags": [
      "Array",
      "Hash Table"
    ],
    "problem_statement": "Given an array of integers `nums` and an integer `target`, return indices of the two numbers such that they add up to `target`.",
    "constraints": [
      "2 <= nums.length <= 10^4",
      "-10^9 <= nums[i] <= 10^9",
      "-10^9 <= target <= 10^9",
      "Only one valid answer exists."
    ],
    "examples": [
      {
        "input": "nums = [2,7,11,15], target = 9",
        "output": "[0,1]",
        "explanation": "Because nums[0] + nums[1] == 9, we return [0, 1]."
      }
    ],
    "brute_force_explanation": "Check every pair of elements to see if their sum matches the target.",
    "optimal_explanation": "Use a hash map to store the values and their indices. For each element, check if the complement (target - value) exists in the map.",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": {
        "time": "O(N²)",
        "space": "O(1)"
      },
      "optimal": {
        "time": "O(N)",
        "space": "O(N)"
      }
    },
    "pattern_capsule": {
      "invariant": "For any x, we need (target - x) to exist.",
      "trigger": "Find a pair with a specific sum.",
      "mistake": "Using nested loops (O(n\u00c2\u00b2)) instead of a Hash Map (O(n))."
    },
    "thinking_guide": {
      "first_principles": [
        "Input: An array of integers `nums` and a single integer `target`.",
        "Output: A pair of indices `[i, j]` such that `nums[i] + nums[j] == target`.",
        "Constraints: Exactly one solution exists. Efficiently handling large arrays is key."
      ],
      "pattern_signals": [
        "Keywords: 'Sum', 'Pair', 'Target'.",
        "Structural Clue: We need to find a relationship between two numbers in a linear collection.",
        "Why this fits: A Hash Map (Frequency Map) allow us to 'look back' at previous numbers in O(1) time."
      ],
      "naive_approach": [
        "What beginners try: Nested loops (O(n^2)) checking every possible pair.",
        "Why it works: It exhaustively searches all combinations.",
        "Why it's inefficient: For 10^4 elements, it performs 100 million operations, which is too slow."
      ],
      "approach_blueprint": [
        "1. Initialize an empty hash map to store `value -> index` mappings.",
        "2. Iterate through the array once.",
        "3. For each number, calculate its `complement` (target - current).",
        "4. Check if the `complement` is already in the map.",
        "5. If found, return the current index and the stored index.",
        "6. If not found, store the current number and its index in the map."
      ]
    },
    "primaryPattern": "two_pointer",
    "shortPatternReason": "Requires finding a pair with a specific sum.",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "patternSignals": [
      "Requires finding a pair with a specific sum.",
      "Uses Array logic."
    ],
    "edgeCases": [
      "Empty input",
      "Single element",
      "Maximum constraints"
    ],
    "strategyShift": "Use a hash map to store the values and their indices. For each element, check if the complement (target - value) exists in the map.",
    "naiveApproach": "Check every pair of elements to see if their sum matches the target.",
    "optimalApproach": "Use a hash map to store the values and their indices. For each element, check if the complement (target - value) exists in the map.",
    "simpleExplanation": "Requires finding a pair with a specific sum.",
    "subPattern": "opposite_direction",
    "patternLevel": "core_patterns"
  },
  {
    "id": 2,
    "title": "Add Two Numbers",
    "slug": "add-two-numbers",
    "difficulty": "Medium",
    "algorithmType": "linked_list",
    "status": "complete",
    "tags": [
      "Linked List",
      "Math",
      "Recursion"
    ],
    "primaryPattern": "Linked List",
    "shortPatternReason": "Simulating manual digit-by-digit addition with carry handling.",
    "time_complexity": "O(max(m, n))",
    "space_complexity": "O(max(m, n))",
    "problem_statement": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\n\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself. The core challenge is managing the 'carry' value that propagates from one digit to the next, much like manual elementary addition.",
    "constraints": [
      "The number of nodes in each linked list is in the range [1, 100].",
      "0 <= Node.val <= 9",
      "It is guaranteed that the list represents a number that does not have leading zeros."
    ],
    "examples": [
      {
        "input": "l1 = [2,4,3], l2 = [5,6,4]",
        "output": "[7,0,8]",
        "explanation": "342 + 465 = 807. We add the units (2+5=7), then the tens (4+6=10, carry 1), then the hundreds (3+4+1=8)."
      }
    ],
    "brute_force_explanation": "A common mistake is attempting to convert the entire linked list into a large integer, adding them, and then converting back to a list. While intuitive, this approach is fundamentally flawed for high-fidelity systems: standard 64-bit integers overflow quickly (around 20 digits). For a problem that guarantees lists up to 100 nodes, conversion to a native integer will result in catastrophic precision loss.",
    "optimal_explanation": "The optimal approach simulates manual 'column-by-column' addition from the least significant digit (LSD) to the most significant. Because the problem reverse-stores the digits (Head = Units, Next = Tens), we traverse from Head to Tail. We maintain a 'carry' state that propagates to the next pair of nodes. This ensures O(max(M, N)) efficiency and handles numbers of infinite length.",
    "intuition": "LSD-FIRST TRAVERSAL. By storing digits in reverse, the problem creators simplified the logic: the Head is always the starting point for addition. We simulate a hardware adder, where each node pair produces a digit and a carry for the next stage.",
    "scenarios": [
      "Large number arithmetic",
      "Arbitrary precision calculators",
      "Data stream merging"
    ],
    "complexity": {
      "brute": {
        "time": "O(N)",
        "space": "O(N)"
      },
      "optimal": {
        "time": "O(N)",
        "space": "O(N)"
      }
    },
    "pseudocode": {
      "brute": "// Naive: Convert to int (Limited by precision)\nn1 = list_to_int(l1)\nn2 = list_to_int(l2)\nreturn int_to_list(n1 + n2)",
      "optimal": "carry = 0\nwhile l1 or l2 or carry:\n    v1 = l1.val if l1 else 0\n    v2 = l2.val if l2 else 0\n    sum = v1 + v2 + carry\n    carry = sum // 10\n    append(sum % 10) to result"
    },
    "external_links": {
      "leetcode": "https://leetcode.com/problems/add-two-numbers/"
    },
    "input_settings": {
      "input1": {
        "label": "List 1 (Digits Reversed)",
        "placeholder": "[2, 4, 3]"
      },
      "input2": {
        "label": "List 2 (Digits Reversed)",
        "placeholder": "[5, 6, 4]"
      }
    },
    "efficiencyGain": "Direct traversal avoids integer overflow and scales to arbitrary lengths (O(N) vs O(N) but memory-safe).",
    "real_time_applications": [
      {
        "title": "BigInt Architectures",
        "description": "How modern engines (V8, Python) handle numbers larger than 64 bits using 'limb' arrays (similar to linked lists)."
      },
      {
        "title": "Financial Ledger Systems",
        "description": "Ensuring zero precision loss when calculating large-scale transactions (e.g., national debts or micro-cent rounding)."
      },
      {
        "title": "Cryptography",
        "description": "Large prime number arithmetic used in RSA and Elliptic Curve encryption where keys exceed 2048 bits."
      }
    ]
  },
  {
    "id": 3,
    "title": "Longest Substring Without Repeating Characters",
    "slug": "longest-substring-without-repeating-characters",
    "difficulty": "Medium",
    "algorithmType": "sliding_window",
    "status": "strong",
    "tags": [
      "Hash Table",
      "String",
      "Sliding Window"
    ],
    "problem_statement": "Given a string `s`, find the length of the longest substring without repeating characters.",
    "constraints": [
      "0 <= s.length <= 5 * 10^4",
      "s consists of English letters, digits, symbols and spaces."
    ],
    "examples": [
      {
        "input": "s = \"abcabcbb\"",
        "output": "3",
        "explanation": "The answer is \"abc\", with the length of 3."
      },
      {
        "input": "s = \"bbbbb\"",
        "output": "1",
        "explanation": "The answer is \"b\", with the length of 1."
      }
    ],
    "brute_force_explanation": "Check every possible substring and verify if it has repeating characters. Keep track of the maximum length found.",
    "optimal_explanation": "Use the sliding window technique with two pointers (left and right). Expand the right pointer to include characters and shrink the left pointer when a duplicate is found.",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": {
        "time": "O(N³)",
        "space": "O(N)"
      },
      "optimal": {
        "time": "O(N)",
        "space": "O(min(M, N))"
      }
    },
    "pseudocode": {
      "brute": "for i from 0 to n-1:\n    for j from i to n-1:\n        if isUnique(s[i:j+1]):\n            maxLen = max(maxLen, j-i+1)",
      "optimal": "l = 0, maxLen = 0, map = {}\nfor r from 0 to n-1:\n    if s[r] in map:\n        l = max(l, map[s[r]] + 1)\n    map[s[r]] = r\n    maxLen = max(maxLen, r-l+1)"
    },
    "external_links": {
      "leetcode": "https://leetcode.com/problems/longest-substring-without-repeating-characters/"
    },
    "input_settings": {
      "input1": {
        "label": "Input Sequence (String)",
        "placeholder": "\"abcabcbb\""
      },
      "input2": {
        "label": "Unique Constraint Type",
        "placeholder": "All ASCII"
      }
    },
    "efficiencyGain": "Sliding Window reduces redundant checks, achieving O(N) linear time versus O(N³) cubic time.",
    "real_time_applications": [
      {
        "title": "Network Congestion Control",
        "description": "TCP uses sliding windows to manage data flow and detect packet loss without re-calculating the entire stream."
      },
      {
        "title": "Autocomplete Engines",
        "description": "Identifying the longest valid prefix in massive dictionaries as users type in real-time."
      },
      {
        "title": "Genomic Sequencing",
        "description": "Finding non-repetitive DNA sequences in billions of base pairs to identify unique genetic markers."
      }
    ]
  },
  {
    "id": 4,
    "title": "Median of Two Sorted Arrays",
    "slug": "median-of-two-sorted-arrays",
    "difficulty": "Hard",
    "algorithmType": "two_pointer",
    "status": "complete",
    "tags": [
      "Array",
      "Binary Search",
      "Divide and Conquer"
    ],
    "problem_statement": "Given two sorted arrays `nums1` and `nums2` of size `m` and `n` respectively, return the median of the two sorted arrays. The overall run time complexity should be `O(log (m+n))`.",
    "constraints": [
      "nums1.length == m",
      "nums2.length == n",
      "0 <= m, n <= 1000",
      "1 <= m + n <= 2000",
      "-10^6 <= nums1[i], nums2[i] <= 10^6"
    ],
    "examples": [
      {
        "input": "nums1 = [1,3], nums2 = [2]",
        "output": "2.00000",
        "explanation": "merged array = [1,2,3] and median is 2."
      }
    ],
    "brute_force_explanation": "Merge both arrays into a single sorted array and pick the middle element. While O(M+N) time is acceptable for small arrays, it fails the O(log(M+N)) requirement for truly large-scale datasets.",
    "optimal_explanation": "Leverage Binary Search to partition the two arrays simultaneously. By ensuring the elements on the left side of the partitions are always smaller than those on the right, we can find the median in logarithmic time without merging.",
    "intuition": "DIVIDE AND CONQUER. We're not looking for a value, but a 'cut' point. By cutting the smaller array, we instantly know where the cut must be in the larger array to keep the total halves equal.",
    "scenarios": [
      "Optimizing database merges",
      "High-frequency trade matching",
      "Real-time sensor data fusion"
    ],
    "complexity": {
      "brute": {
        "time": "O(M+N)",
        "space": "O(M+N)"
      },
      "optimal": {
        "time": "O(log(min(M, N)))",
        "space": "O(1)"
      }
    },
    "pseudocode": {
      "brute": "merged = sort(nums1 + nums2)\nif even: return (merged[mid] + merged[mid-1])/2\nelse: return merged[mid]",
      "optimal": "ensure nums1 is shorter\nlow, high = 0, len(nums1)\nwhile low <= high:\n    partitionX = (low + high) // 2\n    partitionY = (total + 1) // 2 - partitionX\n    if maxLeftX <= minRightY and maxLeftY <= minRightX:\n        return median calculation\n    high/low = adjust bounds"
    },
    "external_links": {
      "leetcode": "https://leetcode.com/problems/median-of-two-sorted-arrays/"
    },
    "input_settings": {
      "input1": {
        "label": "Array 1 (Sorted)",
        "placeholder": "[1, 3]"
      },
      "input2": {
        "label": "Array 2 (Sorted)",
        "placeholder": "[2]"
      }
    },
    "efficiencyGain": "Logarithmic complexity scaling ensures high performance even with arrays containing millions of elements.",
    "real_time_applications": [
      {
        "title": "Adexchange Bid Sorting",
        "description": "Rapidly finding the median bid price across multiple sorted streams to set real-time floors."
      },
      {
        "title": "Parallel DB Joins",
        "description": "Coordinating data partitions between distributed nodes where data is already sorted by primary key."
      },
      {
        "title": "Autonomous Path Median",
        "description": "Synthesizing depth-sensor streams (LIDAR) into a median safety distance calculation in milliseconds."
      }
    ],
    "pattern_capsule": {
      "invariant": "The median divides the total set into two equal halves.",
      "trigger": "Two sorted arrays + O(log(m+n)) constraint.",
      "mistake": "Merging arrays (O(m+n)) instead of binary search partitioning."
    },
    "thinking_guide": {
      "first_principles": [
        "Input: Two separate sorted lists. We need the middle value if they were one.",
        "Output: The median (average of two middle elements if even total length).",
        "Constraints: Logarithmic time (O(log(m+n))) forces us to use Binary Search, not merging."
      ],
      "pattern_signals": [
        "Keywords: 'Sorted', 'Logarithm', 'Median'.",
        "Structural Clue: We have two sorted sequences and need to find a 'cut' point.",
        "Why this fits: Partitioning logic allows us to find the median without actually merging the arrays."
      ],
      "naive_approach": [
        "What beginners try: Merging both arrays (O(n+m)) using Two Pointers.",
        "Why it works: It creates the full sorted sequence.",
        "Why it's inefficient: It processes every element, failing the O(log(m+n)) constraint."
      ],
      "approach_blueprint": [
        "1. Ensure nums1 is the smaller array to minimize the search space.",
        "2. Binary search for a partition point in nums1.",
        "3. Calculate the corresponding partition point in nums2.",
        "4. Verify if the partition is valid (left elements <= right elements).",
        "5. If left element in X > right element in Y, move search left. Otherwise, move right.",
        "6. Calculate median based on max-lefts and min-rights."
      ]
    },
    "strategyShift": "Use binary search to find the correct partition point between the two arrays such that all elements on the left are smaller than all elements on the right.",
    "naiveApproach": "Merge the two sorted arrays into one large sorted array and Find the middle element.",
    "optimalApproach": "Use binary search to find the correct partition point between the two arrays such that all elements on the left are smaller than all elements on the right.",
    "simpleExplanation": "Explore this fundamental computational pattern.",
    "patternSignals": [],
    "edgeCases": [],
    "time_complexity": "O(log(min(m,n)))",
    "space_complexity": "O(1)",
    "subPattern": "classic",
    "patternLevel": "core_patterns",
    "primaryPattern": "binary_search"
  },
  {
    "id": 5,
    "title": "Longest Palindromic Substring",
    "slug": "longest-palindromic-substring",
    "difficulty": "Medium",
    "algorithmType": "two_pointer",
    "status": "complete",
    "tags": [
      "String",
      "Dynamic Programming"
    ],
    "primaryPattern": "Expand Around Center",
    "shortPatternReason": "Exploiting palindromic symmetry by expanding outward from each character as a potential center.",
    "time_complexity": "O(n²)",
    "space_complexity": "O(1)",
    "problem_statement": "Given a string `s`, return the longest palindromic substring in `s`. A palindrome reads the same forwards and backwards. The challenge is to identify the global maximum palindrome without checking every possible substring (O(N³)).",
    "constraints": [
      "1 <= s.length <= 1000",
      "s consists of only digits and English letters."
    ],
    "examples": [
      {
        "input": "s = 'babad'",
        "output": "'bab'",
        "explanation": "'aba' is also a valid answer."
      }
    ],
    "brute_force_explanation": "A naive approach checks every possible substring ($O(N^2)$) and, for each, verify if it is a palindrome ($O(N)$). This leads to an $O(N^3)$ complexity, which becomes unusable as the string length approaches 1,000.",
    "optimal_explanation": "The 'Expand Around Center' pattern treats each character (and each gap between characters) as a potential center of a palindrome. By expanding outward as long as characters match, we find the longest palindrome for each center in $O(N)$ time, totaling $O(N^2)$ for the whole string with zero extra space.",
    "intuition": "SYMMETRY IS THE KEY. Instead of building strings and checking them, we start from a single point and 'verify symmetry' in both directions simultaneously. This leverages the definition of a palindrome to prune millions of unnecessary checks.",
    "scenarios": [
      "DNA sequence analysis",
      "Pattern matching in text editors",
      "Data compression algorithms"
    ],
    "complexity": {
      "brute": {
        "time": "O(N³)",
        "space": "O(1)"
      },
      "optimal": {
        "time": "O(N²)",
        "space": "O(1)"
      }
    },
    "pseudocode": {
      "brute": "for i from 0 to n-1:\n    for j from i to n-1:\n        if isPalindrome(s[i:j+1]):\n            update maxStr",
      "optimal": "for i from 0 to n-1:\n    len1 = expand(s, i, i) // odd\n    len2 = expand(s, i, i+1) // even\n    update maxRange if len1 or len2 is larger"
    },
    "external_links": {
      "leetcode": "https://leetcode.com/problems/longest-palindromic-substring/"
    },
    "input_settings": {
      "input1": {
        "label": "Input Sequence (String)",
        "placeholder": "\"babad\""
      },
      "input2": {
        "label": "Case Sensitivity",
        "placeholder": "Sensitive"
      }
    },
    "efficiencyGain": "Reducing cubic time to quadratic time by leveraging symmetry, saving thousands of operations on even medium-sized strings.",
    "real_time_applications": [
      {
        "title": "Bioinformatics Linkages",
        "description": "Identifying inverted repeats in genetic sequences which often indicate critical biological functions."
      },
      {
        "title": "Compiler Syntax Trees",
        "description": "Used in lexers to identify symmetric tokens or mirrored structures in recursive descent parsing."
      },
      {
        "title": "Network Protocol Palindromes",
        "description": "Detecting specific data packet patterns that serve as 'headers' or 'footers' in low-latency stream protocols."
      }
    ]
  },
  {
    "id": 6,
    "title": "Zigzag Conversion",
    "slug": "zigzag-conversion",
    "difficulty": "Medium",
    "algorithmType": "array",
    "status": "complete",
    "tags": [
      "String"
    ],
    "primaryPattern": "Cyclic Traversal",
    "shortPatternReason": "Simulating the zigzag motion by iterating through string and rows in a bouncing cycle.",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "problem_statement": "The string \"PAYPALISHIRING\" is written in a zigzag pattern on a given number of rows. This problem asks you to simulate this layout and then read the result row by row.",
    "constraints": [
      "1 <= s.length <= 1000",
      "s consists of English letters (lower-case and upper-case), ',' and '.'.",
      "1 <= numRows <= 1000"
    ],
    "examples": [
      {
        "input": "s = 'PAYPALISHIRING', numRows = 3",
        "output": "'PAHNAPLSIIGYIR'",
        "explanation": "P   A   H   N\nA P L S I I G\nY   I   R"
      }
    ],
    "brute_force_explanation": "A brute force approach would involve creating a 2D matrix of size (numRows, s.length) and manually placing characters. However, this wastes significant space as most matrix cells will be empty.",
    "optimal_explanation": "Instead of a full matrix, we use an array of strings (one for each row). We traverse the input string once, adding each character to the current row and 'bouncing' the row direction whenever we hit the top or bottom row.",
    "intuition": "THE BOUNCING BALL. Imagine a ball bouncing between the first and last row as it travels left to right. We don't need to know the horizontal position, only the current row and the direction of the bounce.",
    "scenarios": [
      "Text rendering in limited space",
      "Data obfuscation/Transposition ciphers",
      "Waveform visualization"
    ],
    "complexity": {
      "brute": {
        "time": "O(N)",
        "space": "O(N * numRows)"
      },
      "optimal": {
        "time": "O(N)",
        "space": "O(N)"
      }
    },
    "pseudocode": {
      "brute": "matrix = createMatrix(numRows, n)\nfill matrix in zigzag order\nresult = read matrix row by row",
      "optimal": "rows = array of strings\nfor char in s:\n    rows[currRow] += char\n    if currRow == 0 or currRow == max: direction *= -1\n    currRow += direction"
    },
    "external_links": {
      "leetcode": "https://leetcode.com/problems/zigzag-conversion/"
    },
    "input_settings": {
      "input1": {
        "label": "Input String",
        "placeholder": "\"PAYPALISHIRING\""
      },
      "input2": {
        "label": "Number of Rows",
        "placeholder": "3"
      }
    },
    "efficiencyGain": "Reducing space complexity from O(N*K) to O(N) by using row-level accumulation instead of a sparse 2D matrix.",
    "real_time_applications": [
      {
        "title": "Data Serialization",
        "description": "Rearranging data streams for specific hardware pipelines that read parallel chunks row-by-row."
      },
      {
        "title": "OLED Display Refresh",
        "description": "Optimizing scan-line updates for unconventional display geometries where pixels are addressed in non-linear zigzags."
      },
      {
        "title": "Classic Transposition Ciphers",
        "description": "Implementing 'Rail Fence' ciphers used in historical cryptography for basic message encryption."
      }
    ]
  },
  {
    "id": 7,
    "title": "Reverse Integer",
    "slug": "reverse-integer",
    "difficulty": "Easy",
    "algorithmType": "math",
    "status": "complete",
    "tags": [
      "Math"
    ],
    "primaryPattern": "Digit Manipulation",
    "shortPatternReason": "Using basic arithmetic (modulo/division) to reverse digits without using expensive string conversions.",
    "time_complexity": "O(log(x))",
    "space_complexity": "O(1)",
    "problem_statement": "Given a signed 32-bit integer `x`, return `x` with its digits reversed. If reversing `x` causes the value to go outside the signed 32-bit integer range, return 0.",
    "constraints": [
      "-2^31 <= x <= 2^31 - 1"
    ],
    "examples": [
      {
        "input": "x = 123",
        "output": "321"
      }
    ],
    "brute_force_explanation": "A common mistake is converting the number to a string, reversing the string, and converting it back. This is slow and can fail significantly on overflow before the conversion even happens.",
    "optimal_explanation": "Repeatedly extract the last digit using `x % 10` and append it to the result `res = res * 10 + lastDigit`. This process is done in a loop until `x` becomes 0, with checks for overflow at each step.",
    "intuition": "POP AND PUSH. Think of the number as a stack of digits. We 'pop' from the end of the original number and 'push' to the beginning of the new reverse number in a single movement.",
    "scenarios": [
      "Endianness conversion",
      "Bit-level field reversal",
      "Mathematical sequence analysis"
    ],
    "complexity": {
      "brute": {
        "time": "O(log X)",
        "space": "O(log X)"
      },
      "optimal": {
        "time": "O(log X)",
        "space": "O(1)"
      }
    },
    "pseudocode": {
      "brute": "s = str(abs(x))\nrev = s.reverse()\nif out_of_bounds: return 0\nreturn int(rev)",
      "optimal": "while x != 0:\n    pop = x % 10\n    if about_to_overflow: return 0\n    res = res * 10 + pop\n    x /= 10"
    },
    "external_links": {
      "leetcode": "https://leetcode.com/problems/reverse-integer/"
    },
    "input_settings": {
      "input1": {
        "label": "Input Integer",
        "placeholder": "123"
      },
      "input2": {
        "label": "Overflow Boundary",
        "placeholder": "32-bit"
      }
    },
    "efficiencyGain": "Avoiding O(log X) extra space for string storage and the overhead of multiple type conversions.",
    "real_time_applications": [
      {
        "title": "Low-level Bitstream Reversal",
        "description": "Reversing packet headers or field orders in networking protocols where speed is critical."
      },
      {
        "title": "Legacy System Migrations",
        "description": "Transforming data between Big-Endian and Little-Endian format in older embedded architectures."
      },
      {
        "title": "Decimal Arithmetic Verification",
        "description": "Checking numeric properties in accounting software where precise digit-level control is required."
      }
    ]
  },
  {
    "id": 8,
    "title": "String to Integer (atoi)",
    "slug": "string-to-integer-atoi",
    "difficulty": "Medium",
    "algorithmType": "array",
    "status": "complete",
    "tags": [
      "String"
    ],
    "primaryPattern": "Deterministic Finite Automata",
    "shortPatternReason": "Handling complex edge case states (whitespace, signs, non-digits) using a linear scan.",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "problem_statement": "Implement the `myAtoi(string s)` function, which converts a string to a 32-bit signed integer. It must handle leading whitespace, signs, and ignore non-digit characters following the number.",
    "constraints": [
      "0 <= s.length <= 200",
      "s consists of English letters, digits, ' ', '+', '-', and '.'."
    ],
    "examples": [
      {
        "input": "s = ' -42'",
        "output": "-42",
        "explanation": "Leading spaces are ignored, sign is detected."
      }
    ],
    "brute_force_explanation": "Checking the string multiple times (once for spaces, once for sign, once for digits) leads to redundant processing and complex conditional logic.",
    "optimal_explanation": "Use a single-pass implementation that mimics a simple State Machine. Start in 'Whitespace' state, move to 'Sign' state, then finally to 'Digit' state, maintaining the result and checking for overflow on every character.",
    "intuition": "CHARACTER VALIDATION. Instead of looking for a number, look for why a character should *stop* being a number. It's a process of elimination: first skip spaces, then confirm direction (sign), then harvest digits until any noise appears.",
    "scenarios": [
      "CLI argument parsing",
      "HTTP Header extraction",
      "Data ingestion from CSV/TXT"
    ],
    "complexity": {
      "brute": {
        "time": "O(N)",
        "space": "O(N)"
      },
      "optimal": {
        "time": "O(N)",
        "space": "O(1)"
      }
    },
    "pseudocode": {
      "brute": "s = s.strip()\nsign = get_sign(s)\ndigits = extract_digits(s)\nreturn clampTo32Bit(digits)",
      "optimal": "skipSpaces(s)\nif +/-: sign = val\nwhile isDigit(s[i]):\n    res = res * 10 + s[i]\n    if overflow: return limit\nreturn res * sign"
    },
    "external_links": {
      "leetcode": "https://leetcode.com/problems/string-to-integer-atoi/"
    },
    "input_settings": {
      "input1": {
        "label": "Input String",
        "placeholder": "\"  -42 with words\""
      },
      "input2": {
        "label": "Digit Clamp Target",
        "placeholder": "32-bit Signed"
      }
    },
    "efficiencyGain": "Reducing memory overhead by processing characters in-place rather than allocating new strings for stripping and filtering.",
    "real_time_applications": [
      {
        "title": "Compiler Lexical Analysis",
        "description": "Transforming ASCII source code into internal numeric types for faster computation in compilers."
      },
      {
        "title": "Financial Transaction Parsing",
        "description": "Processing raw text logs from banking mainframes where numbers are often padded with spaces or extra symbols."
      },
      {
        "title": "Embedded Input Handling",
        "description": "Translating user input from keypads or serial monitors into control variables for micro-controllers."
      }
    ]
  },
  {
    "id": 9,
    "title": "Palindrome Number",
    "slug": "palindrome-number",
    "difficulty": "Easy",
    "algorithmType": "math",
    "status": "complete",
    "tags": [
      "Math"
    ],
    "primaryPattern": "Half-Reversal",
    "shortPatternReason": "Reversing only half of the integer to compare against the first half, preventing overflow issues.",
    "time_complexity": "O(log(n))",
    "space_complexity": "O(1)",
    "problem_statement": "Given an integer `x`, return `true` if `x` is a palindrome, and `false` otherwise. A negative number is never a palindrome.",
    "constraints": [
      "-2^31 <= x <= 2^31 - 1"
    ],
    "examples": [
      {
        "input": "x = 121",
        "output": "true"
      },
      {
        "input": "x = -121",
        "output": "false"
      }
    ],
    "brute_force_explanation": "Converting the integer to a string and checking if the string is a palindrome is simple but slow and expensive in terms of memory.",
    "optimal_explanation": "Reverse the second half of the number and compare it with the first half. We know we've reached the middle when our reversed number becomes greater than or equal to the remaining original number.",
    "intuition": "MEETING IN THE MIDDLE. You don't need to rebuild the whole house to see if it's symmetrical. Just check if the back door is in the same place as the front door relative to the center.",
    "scenarios": [
      "Fast mathematical property checks",
      "Network ID verification",
      "Pattern discovery in large datasets"
    ],
    "complexity": {
      "brute": {
        "time": "O(log N)",
        "space": "O(log N)"
      },
      "optimal": {
        "time": "O(log N)",
        "space": "O(1)"
      }
    },
    "pseudocode": {
      "brute": "s = str(x)\nreturn s == s.reverse()",
      "optimal": "if x < 0: return False\nrev = 0\nwhile x > rev:\n    rev = rev * 10 + x % 10\n    x /= 10\nreturn x == rev or x == rev / 10"
    },
    "external_links": {
      "leetcode": "https://leetcode.com/problems/palindrome-number/"
    },
    "input_settings": {
      "input1": {
        "label": "Input Integer",
        "placeholder": "121"
      },
      "input2": {
        "label": "Base System",
        "placeholder": "Decimal (Base 10)"
      }
    },
    "efficiencyGain": "Eliminating string allocation and half of the iteration count by stopping at the numeric center.",
    "real_time_applications": [
      {
        "title": "In-Memory ID Validation",
        "description": "Rapidly verifying symmetric auto-generated IDs in distributed databases before processing more expensive queries."
      },
      {
        "title": "Graphic Symmetry Engines",
        "description": "Checking for mirror points in 2D coordinate maps to optimize rendering of symmetrical objects."
      },
      {
        "title": "Financial Checksumming",
        "description": "Using palindromic properties as simple, fast initial validation for certain data packet structures."
      }
    ]
  },
  {
    "id": 10,
    "title": "Regular Expression Matching",
    "slug": "regular-expression-matching",
    "difficulty": "Hard",
    "algorithmType": "dynamic_programming",
    "status": "complete",
    "tags": [
      "String",
      "Dynamic Programming",
      "Recursion"
    ],
    "primaryPattern": "Top-Down Memoization",
    "shortPatternReason": "Breaking down wildcard matching into overlapping subproblems solved recursively with caching.",
    "time_complexity": "O(S*P)",
    "space_complexity": "O(S*P)",
    "problem_statement": "Implement regular expression matching with support for '.' and '*' where '.' matches any single character and '*' matches zero or more of the preceding element.",
    "constraints": [
      "1 <= s.length <= 20",
      "1 <= p.length <= 20",
      "s consists of lowercase English letters.",
      "p consists of lowercase English letters, '.', and '*'."
    ],
    "examples": [
      {
        "input": "s = 'aa', p = 'a*'",
        "output": "true"
      }
    ],
    "brute_force_explanation": "A pure recursive approach without memoization explores the same sub-paths multiple times, exponential complexity that will hang on even slightly complex patterns.",
    "optimal_explanation": "Use Dynamic Programming (Table) or Recursion with Memoization. For each pair (i, j), we check if the current characters match. If the next character in pattern is '*', we have two choices: skip the '*' or continue matching with the same '*' element.",
    "intuition": "DECISION BRANCHES. Wildcards are just choices. '*' means 'I can be empty' OR 'I can be one of my previous self'. We explore both branches and if either leads to a match, the whole thing matches.",
    "scenarios": [
      "Search engines",
      "Log filtering",
      "Security rule validation"
    ],
    "complexity": {
      "brute": {
        "time": "O((S+P)*2^(S+P/2))",
        "space": "O(S+P)"
      },
      "optimal": {
        "time": "O(S*P)",
        "space": "O(S*P)"
      }
    },
    "pseudocode": {
      "brute": "match(s, p):\n    if not p: return not s\n    first_match = s and p[0] in {s[0], '.'}\n    if len(p) >= 2 and p[1] == '*':\n        return match(s, p[2:]) or (first_match and match(s[1:], p))\n    else:\n        return first_match and match(s[1:], p[1:])",
      "optimal": "dp = matrix[s+1][p+1]\ndp[last][last] = True\nfor i from s to 0:\n    for j from p-1 to 0:\n        // similar logic to recursive but fills table"
    },
    "external_links": {
      "leetcode": "https://leetcode.com/problems/regular-expression-matching/"
    },
    "input_settings": {
      "input1": {
        "label": "Input String (s)",
        "placeholder": "\"aa\""
      },
      "input2": {
        "label": "Regex Pattern (p)",
        "placeholder": "\"a*\""
      }
    },
    "efficiencyGain": "From exponential to polynomial time by caching results of sub-matches, handling deep recursion depths in real-world patterns.",
    "real_time_applications": [
      {
        "title": "WAF (Web Application Firewalls)",
        "description": "Rapidly matching incoming request patterns against known attack signatures (SQLi, XSS) using regex optimizations."
      },
      {
        "title": "Text Editor Search/Replace",
        "description": "Powers the core find-in-files functionality in IDEs like VS Code where patterns must match across thousands of lines."
      },
      {
        "title": "Routing Engines",
        "description": "Used in frameworks like Express or Django to translate URL patterns (e.g., /user/*) into specific function calls."
      }
    ]
  },
  {
    "id": 11,
    "title": "Container With Most Water",
    "slug": "container-with-most-water",
    "difficulty": "Medium",
    "algorithmType": "two_pointer",
    "status": "complete",
    "tags": [
      "Array",
      "Two Pointers"
    ],
    "primaryPattern": "Two Pointers",
    "shortPatternReason": "Searching for maximum area by narrowing the distance between the tallest possible vertical lines.",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "problem_statement": "You are given an integer array `height` of length `n`. There are `n` vertical lines drawn such that the two endpoints of the `ith` line are `(i, 0)` and `(i, height[i])`. Find two lines that together with the x-axis form a container, such that the container contains the most water. Return the maximum amount of water a container can store.",
    "constraints": [
      "n == height.length",
      "2 <= n <= 10^5",
      "0 <= height[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "height = [1,8,6,2,5,4,8,3,7]",
        "output": "49",
        "explanation": "The max area is found between indices 1 and 8 (heights 8 and 7), width = 7, area = 7 * 7 = 49."
      }
    ],
    "brute_force_explanation": "Checking every possible pair of lines (i, j) to calculate the area and keeping track of the maximum. This requires O(n\u00b2) time which is too slow for large inputs.",
    "optimal_explanation": "Use two pointers starting at both ends of the array. Calculate the current area and move the pointer that points to the shorter line inward. Since the width is already decreasing, the only way to potentially find a larger area is to find a taller line.",
    "intuition": "GREEDY NARROWING. The area is limited by the shorter line. To find a larger area while the width decreases, we MUST find a taller line. Thus, we always move the pointer pointing to the shorter line.",
    "scenarios": [
      "Optimizing physical storage containers",
      "Resource allocation in networking",
      "Financial portfolio optimization"
    ],
    "complexity": {
      "brute": {
        "time": "O(N\u00b2)",
        "space": "O(1)"
      },
      "optimal": {
        "time": "O(N)",
        "space": "O(1)"
      }
    },
    "pseudocode": {
      "brute": "maxArea = 0\nfor i in 0..n:\n    for j in i+1..n:\n        area = min(h[i], h[j]) * (j - i)\n        maxArea = max(maxArea, area)\nreturn maxArea",
      "optimal": "l = 0, r = n-1, maxArea = 0\nwhile l < r:\n    area = min(h[l], h[r]) * (r - l)\n    maxArea = max(maxArea, area)\n    if h[l] < h[r]: l++\n    else: r--\nreturn maxArea"
    },
    "external_links": {
      "leetcode": "https://leetcode.com/problems/container-with-most-water/"
    },
    "input_settings": {
      "input1": {
        "label": "Line Heights Array",
        "placeholder": "[1,8,6,2,5,4,8,3,7]"
      },
      "input2": {
        "label": "Goal Area",
        "placeholder": "Maximize"
      }
    },
    "efficiencyGain": "Reducing search space from O(N\u00b2) pairs to O(N) by eliminating pairs that can't possibly exceed the current maximum.",
    "real_time_applications": [
      {
        "title": "Logistics & Warehousing",
        "description": "Optimizing the placement of partitions in bulk storage units to maximize volumetric capacity."
      },
      {
        "title": "Bandwidth Throttling",
        "description": "Calculating peak data throughput between two time points in a fluctuating network signal."
      },
      {
        "title": "Supply Chain Fluidity",
        "description": "Determining the limiting factor in a multi-stage manufacturing pipeline by finding the 'shortest' resource line."
      }
    ]
  },
  {
    "id": 12,
    "title": "3Sum",
    "slug": "3sum",
    "difficulty": "Medium",
    "algorithmType": "two_pointer",
    "status": "new",
    "tags": [
      "Two Pointer"
    ],
    "primaryPattern": "two_pointer",
    "shortPatternReason": "Sorted array traversal with fixed element and two pointers.",
    "time_complexity": "O(n\u00b2)",
    "space_complexity": "O(log n) to O(n)",
    "problem_statement": "Standard LeetCode problem: 3Sum.",
    "constraints": [
      "N <= 10^5"
    ],
    "examples": [],
    "brute_force_explanation": "Iterative approach checking all pairs/subsets.",
    "optimal_explanation": "Optimal solution using Two Pointer.",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(n\u00b2)",
      "space": "O(log n) to O(n)"
    },
    "patternSignals": [
      "Sorted array traversal with fixed element and two pointers."
    ],
    "edgeCases": [
      "Small input",
      "Large values"
    ],
    "thinking_guide": {
      "first_principles": [
        "Understand the goal of 3Sum."
      ],
      "pattern_signals": [
        "Sorted array traversal with fixed element and two pointers."
      ],
      "naive_approach": [
        "Brute force checking all possibilities."
      ],
      "approach_blueprint": [
        "1. Apply pattern",
        "2. Optimize"
      ]
    },
    "strategyShift": "Optimal solution using Two Pointer.",
    "naiveApproach": "Iterative approach checking all pairs/subsets.",
    "optimalApproach": "Optimal solution using Two Pointer.",
    "simpleExplanation": "Sorted array traversal with fixed element and two pointers.",
    "subPattern": "opposite_direction",
    "patternLevel": "core_patterns"
  },
  {
    "id": 13,
    "title": "Valid Parentheses",
    "slug": "valid-parentheses",
    "difficulty": "Easy",
    "algorithmType": "stack",
    "status": "new",
    "tags": [
      "Stack"
    ],
    "primaryPattern": "array_basics",
    "shortPatternReason": "LIFO behavior for matching brackets.",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "problem_statement": "Standard LeetCode problem: Valid Parentheses.",
    "constraints": [
      "N <= 10^5"
    ],
    "examples": [],
    "brute_force_explanation": "Iterative approach checking all pairs/subsets.",
    "optimal_explanation": "Optimal solution using Stack.",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(n)",
      "space": "O(n)"
    },
    "patternSignals": [
      "LIFO behavior for matching brackets."
    ],
    "edgeCases": [
      "Small input",
      "Large values"
    ],
    "thinking_guide": {
      "first_principles": [
        "Understand the goal of Valid Parentheses."
      ],
      "pattern_signals": [
        "LIFO behavior for matching brackets."
      ],
      "naive_approach": [
        "Brute force checking all possibilities."
      ],
      "approach_blueprint": [
        "1. Apply pattern",
        "2. Optimize"
      ]
    },
    "strategyShift": "Optimal solution using Stack.",
    "naiveApproach": "Iterative approach checking all pairs/subsets.",
    "optimalApproach": "Optimal solution using Stack.",
    "simpleExplanation": "LIFO behavior for matching brackets.",
    "subPattern": "prefix_sum",
    "patternLevel": "foundation"
  },
  {
    "id": 14,
    "title": "Merge Two Sorted Lists",
    "slug": "merge-two-sorted-lists",
    "difficulty": "Easy",
    "algorithmType": "linked_list",
    "status": "new",
    "tags": [
      "Linked List"
    ],
    "primaryPattern": "two_pointer",
    "shortPatternReason": "Pointer manipulation in sorted sequences.",
    "time_complexity": "O(n+m)",
    "space_complexity": "O(1)",
    "problem_statement": "Standard LeetCode problem: Merge Two Sorted Lists.",
    "constraints": [
      "N <= 10^5"
    ],
    "examples": [],
    "brute_force_explanation": "Iterative approach checking all pairs/subsets.",
    "optimal_explanation": "Optimal solution using Linked List.",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(n+m)",
      "space": "O(1)"
    },
    "patternSignals": [
      "Pointer manipulation in sorted sequences."
    ],
    "edgeCases": [
      "Small input",
      "Large values"
    ],
    "thinking_guide": {
      "first_principles": [
        "Understand the goal of Merge Two Sorted Lists."
      ],
      "pattern_signals": [
        "Pointer manipulation in sorted sequences."
      ],
      "naive_approach": [
        "Brute force checking all possibilities."
      ],
      "approach_blueprint": [
        "1. Apply pattern",
        "2. Optimize"
      ]
    },
    "strategyShift": "Optimal solution using Linked List.",
    "naiveApproach": "Iterative approach checking all pairs/subsets.",
    "optimalApproach": "Optimal solution using Linked List.",
    "simpleExplanation": "Pointer manipulation in sorted sequences.",
    "subPattern": "same_direction",
    "patternLevel": "core_patterns"
  },
  {
    "id": 15,
    "title": "Generate Parentheses",
    "slug": "generate-parentheses",
    "difficulty": "Medium",
    "algorithmType": "recursion",
    "status": "new",
    "tags": [
      "Backtracking"
    ],
    "primaryPattern": "tree_patterns",
    "shortPatternReason": "Recursive generation with valid pairing constraints.",
    "time_complexity": "O(4\u207f / \u221an)",
    "space_complexity": "O(n)",
    "problem_statement": "Standard LeetCode problem: Generate Parentheses.",
    "constraints": [
      "N <= 10^5"
    ],
    "examples": [],
    "brute_force_explanation": "Iterative approach checking all pairs/subsets.",
    "optimal_explanation": "Optimal solution using Backtracking.",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(4\u207f / \u221an)",
      "space": "O(n)"
    },
    "patternSignals": [
      "Recursive generation with valid pairing constraints."
    ],
    "edgeCases": [
      "Small input",
      "Large values"
    ],
    "thinking_guide": {
      "first_principles": [
        "Understand the goal of Generate Parentheses."
      ],
      "pattern_signals": [
        "Recursive generation with valid pairing constraints."
      ],
      "naive_approach": [
        "Brute force checking all possibilities."
      ],
      "approach_blueprint": [
        "1. Apply pattern",
        "2. Optimize"
      ]
    },
    "strategyShift": "Optimal solution using Backtracking.",
    "naiveApproach": "Iterative approach checking all pairs/subsets.",
    "optimalApproach": "Optimal solution using Backtracking.",
    "simpleExplanation": "Recursive generation with valid pairing constraints.",
    "subPattern": "postorder_accumulation",
    "patternLevel": "advanced_patterns"
  },
  {
    "id": 16,
    "title": "Merge k Sorted Lists",
    "slug": "merge-k-sorted-lists",
    "difficulty": "Hard",
    "algorithmType": "linked_list",
    "status": "new",
    "tags": [
      "Heap / Priority Queue"
    ],
    "primaryPattern": "two_pointer",
    "shortPatternReason": "K-way merge using a min-heap.",
    "time_complexity": "O(N log k)",
    "space_complexity": "O(k)",
    "problem_statement": "Standard LeetCode problem: Merge k Sorted Lists.",
    "constraints": [
      "N <= 10^5"
    ],
    "examples": [],
    "brute_force_explanation": "Iterative approach checking all pairs/subsets.",
    "optimal_explanation": "Optimal solution using Heap / Priority Queue.",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(N log k)",
      "space": "O(k)"
    },
    "patternSignals": [
      "K-way merge using a min-heap."
    ],
    "edgeCases": [
      "Small input",
      "Large values"
    ],
    "thinking_guide": {
      "first_principles": [
        "Understand the goal of Merge k Sorted Lists."
      ],
      "pattern_signals": [
        "K-way merge using a min-heap."
      ],
      "naive_approach": [
        "Brute force checking all possibilities."
      ],
      "approach_blueprint": [
        "1. Apply pattern",
        "2. Optimize"
      ]
    },
    "strategyShift": "Optimal solution using Heap / Priority Queue.",
    "naiveApproach": "Iterative approach checking all pairs/subsets.",
    "optimalApproach": "Optimal solution using Heap / Priority Queue.",
    "simpleExplanation": "K-way merge using a min-heap.",
    "subPattern": "same_direction",
    "patternLevel": "core_patterns"
  },
  {
    "id": 17,
    "title": "Search in Rotated Sorted Array",
    "slug": "search-in-rotated-sorted-array",
    "difficulty": "Medium",
    "algorithmType": "binary_search",
    "status": "new",
    "tags": [
      "Binary Search"
    ],
    "primaryPattern": "binary_search",
    "shortPatternReason": "Logarithmic search in modified sorted space.",
    "time_complexity": "O(log n)",
    "space_complexity": "O(1)",
    "problem_statement": "Standard LeetCode problem: Search in Rotated Sorted Array.",
    "constraints": [
      "N <= 10^5"
    ],
    "examples": [],
    "brute_force_explanation": "Iterative approach checking all pairs/subsets.",
    "optimal_explanation": "Optimal solution using Binary Search.",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(log n)",
      "space": "O(1)"
    },
    "patternSignals": [
      "Logarithmic search in modified sorted space."
    ],
    "edgeCases": [
      "Small input",
      "Large values"
    ],
    "thinking_guide": {
      "first_principles": [
        "Understand the goal of Search in Rotated Sorted Array."
      ],
      "pattern_signals": [
        "Logarithmic search in modified sorted space."
      ],
      "naive_approach": [
        "Brute force checking all possibilities."
      ],
      "approach_blueprint": [
        "1. Apply pattern",
        "2. Optimize"
      ]
    },
    "strategyShift": "Optimal solution using Binary Search.",
    "naiveApproach": "Iterative approach checking all pairs/subsets.",
    "optimalApproach": "Optimal solution using Binary Search.",
    "simpleExplanation": "Logarithmic search in modified sorted space.",
    "subPattern": "rotated_array_search",
    "patternLevel": "core_patterns"
  },
  {
    "id": 18,
    "title": "Permutations",
    "slug": "permutations",
    "difficulty": "Medium",
    "algorithmType": "recursion",
    "status": "new",
    "tags": [
      "Backtracking"
    ],
    "primaryPattern": "graph_traversal",
    "shortPatternReason": "Generating all possible orderings recursively.",
    "time_complexity": "O(n * n!)",
    "space_complexity": "O(n)",
    "problem_statement": "Standard LeetCode problem: Permutations.",
    "constraints": [
      "N <= 10^5"
    ],
    "examples": [],
    "brute_force_explanation": "Iterative approach checking all pairs/subsets.",
    "optimal_explanation": "Optimal solution using Backtracking.",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(n * n!)",
      "space": "O(n)"
    },
    "patternSignals": [
      "Generating all possible orderings recursively."
    ],
    "edgeCases": [
      "Small input",
      "Large values"
    ],
    "thinking_guide": {
      "first_principles": [
        "Understand the goal of Permutations."
      ],
      "pattern_signals": [
        "Generating all possible orderings recursively."
      ],
      "naive_approach": [
        "Brute force checking all possibilities."
      ],
      "approach_blueprint": [
        "1. Apply pattern",
        "2. Optimize"
      ]
    },
    "strategyShift": "Optimal solution using Backtracking.",
    "naiveApproach": "Iterative approach checking all pairs/subsets.",
    "optimalApproach": "Optimal solution using Backtracking.",
    "simpleExplanation": "Generating all possible orderings recursively.",
    "subPattern": "dfs_backtracking",
    "patternLevel": "advanced_patterns"
  },
  {
    "id": 19,
    "title": "Group Anagrams",
    "slug": "group-anagrams",
    "difficulty": "Medium",
    "algorithmType": "two_pointer",
    "status": "new",
    "tags": [
      "Array"
    ],
    "primaryPattern": "two_pointer",
    "shortPatternReason": "Categorizing strings by sorted key or frequency frequency.",
    "time_complexity": "O(n * k log k)",
    "space_complexity": "O(n * k)",
    "problem_statement": "Standard LeetCode problem: Group Anagrams.",
    "constraints": [
      "N <= 10^5"
    ],
    "examples": [],
    "brute_force_explanation": "Iterative approach checking all pairs/subsets.",
    "optimal_explanation": "Optimal solution using Array.",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(n * k log k)",
      "space": "O(n * k)"
    },
    "patternSignals": [
      "Categorizing strings by sorted key or frequency frequency."
    ],
    "edgeCases": [
      "Small input",
      "Large values"
    ],
    "thinking_guide": {
      "first_principles": [
        "Understand the goal of Group Anagrams."
      ],
      "pattern_signals": [
        "Categorizing strings by sorted key or frequency frequency."
      ],
      "naive_approach": [
        "Brute force checking all possibilities."
      ],
      "approach_blueprint": [
        "1. Apply pattern",
        "2. Optimize"
      ]
    },
    "strategyShift": "Optimal solution using Array.",
    "naiveApproach": "Iterative approach checking all pairs/subsets.",
    "optimalApproach": "Optimal solution using Array.",
    "simpleExplanation": "Categorizing strings by sorted key or frequency frequency.",
    "subPattern": "same_direction",
    "patternLevel": "core_patterns"
  },
  {
    "id": 20,
    "title": "Maximum Subarray",
    "slug": "maximum-subarray",
    "difficulty": "Medium",
    "algorithmType": "two_pointer",
    "status": "new",
    "tags": [
      "Dynamic Programming"
    ],
    "primaryPattern": "two_pointer",
    "shortPatternReason": "Local vs Global maxima optimization (Kadane's).",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "problem_statement": "Standard LeetCode problem: Maximum Subarray.",
    "constraints": [
      "N <= 10^5"
    ],
    "examples": [],
    "brute_force_explanation": "Iterative approach checking all pairs/subsets.",
    "optimal_explanation": "Optimal solution using Dynamic Programming.",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(n)",
      "space": "O(1)"
    },
    "patternSignals": [
      "Local vs Global maxima optimization (Kadane's)."
    ],
    "edgeCases": [
      "Small input",
      "Large values"
    ],
    "thinking_guide": {
      "first_principles": [
        "Understand the goal of Maximum Subarray."
      ],
      "pattern_signals": [
        "Local vs Global maxima optimization (Kadane's)."
      ],
      "naive_approach": [
        "Brute force checking all possibilities."
      ],
      "approach_blueprint": [
        "1. Apply pattern",
        "2. Optimize"
      ]
    },
    "strategyShift": "Optimal solution using Dynamic Programming.",
    "naiveApproach": "Iterative approach checking all pairs/subsets.",
    "optimalApproach": "Optimal solution using Dynamic Programming.",
    "simpleExplanation": "Local vs Global maxima optimization (Kadane's).",
    "subPattern": "same_direction",
    "patternLevel": "core_patterns"
  },
  {
    "id": 21,
    "title": "Jump Game",
    "slug": "jump-game",
    "difficulty": "Medium",
    "algorithmType": "two_pointer",
    "status": "new",
    "tags": [
      "Greedy"
    ],
    "primaryPattern": "two_pointer",
    "shortPatternReason": "Tracking maximum reachable index greedily.",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "problem_statement": "Standard LeetCode problem: Jump Game.",
    "constraints": [
      "N <= 10^5"
    ],
    "examples": [],
    "brute_force_explanation": "Iterative approach checking all pairs/subsets.",
    "optimal_explanation": "Optimal solution using Greedy.",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(n)",
      "space": "O(1)"
    },
    "patternSignals": [
      "Tracking maximum reachable index greedily."
    ],
    "edgeCases": [
      "Small input",
      "Large values"
    ],
    "thinking_guide": {
      "first_principles": [
        "Understand the goal of Jump Game."
      ],
      "pattern_signals": [
        "Tracking maximum reachable index greedily."
      ],
      "naive_approach": [
        "Brute force checking all possibilities."
      ],
      "approach_blueprint": [
        "1. Apply pattern",
        "2. Optimize"
      ]
    },
    "strategyShift": "Optimal solution using Greedy.",
    "naiveApproach": "Iterative approach checking all pairs/subsets.",
    "optimalApproach": "Optimal solution using Greedy.",
    "simpleExplanation": "Tracking maximum reachable index greedily.",
    "subPattern": "same_direction",
    "patternLevel": "core_patterns"
  },
  {
    "id": 22,
    "title": "Merge Intervals",
    "slug": "merge-intervals",
    "difficulty": "Medium",
    "algorithmType": "two_pointer",
    "status": "new",
    "tags": [
      "Array"
    ],
    "primaryPattern": "two_pointer",
    "shortPatternReason": "Sorting and merging overlapping ranges.",
    "time_complexity": "O(n log n)",
    "space_complexity": "O(n)",
    "problem_statement": "Standard LeetCode problem: Merge Intervals.",
    "constraints": [
      "N <= 10^5"
    ],
    "examples": [],
    "brute_force_explanation": "Iterative approach checking all pairs/subsets.",
    "optimal_explanation": "Optimal solution using Array.",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(n log n)",
      "space": "O(n)"
    },
    "patternSignals": [
      "Sorting and merging overlapping ranges."
    ],
    "edgeCases": [
      "Small input",
      "Large values"
    ],
    "thinking_guide": {
      "first_principles": [
        "Understand the goal of Merge Intervals."
      ],
      "pattern_signals": [
        "Sorting and merging overlapping ranges."
      ],
      "naive_approach": [
        "Brute force checking all possibilities."
      ],
      "approach_blueprint": [
        "1. Apply pattern",
        "2. Optimize"
      ]
    },
    "strategyShift": "Optimal solution using Array.",
    "naiveApproach": "Iterative approach checking all pairs/subsets.",
    "optimalApproach": "Optimal solution using Array.",
    "simpleExplanation": "Sorting and merging overlapping ranges.",
    "subPattern": "same_direction",
    "patternLevel": "core_patterns"
  },
  {
    "id": 23,
    "title": "Climbing Stairs",
    "slug": "climbing-stairs",
    "difficulty": "Easy",
    "algorithmType": "recursion",
    "status": "new",
    "tags": [
      "Dynamic Programming"
    ],
    "primaryPattern": "tree_patterns",
    "shortPatternReason": "Optimal substructure using Fibonacci relation.",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "problem_statement": "Standard LeetCode problem: Climbing Stairs.",
    "constraints": [
      "N <= 10^5"
    ],
    "examples": [],
    "brute_force_explanation": "Iterative approach checking all pairs/subsets.",
    "optimal_explanation": "Optimal solution using Dynamic Programming.",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(n)",
      "space": "O(1)"
    },
    "patternSignals": [
      "Optimal substructure using Fibonacci relation."
    ],
    "edgeCases": [
      "Small input",
      "Large values"
    ],
    "thinking_guide": {
      "first_principles": [
        "Understand the goal of Climbing Stairs."
      ],
      "pattern_signals": [
        "Optimal substructure using Fibonacci relation."
      ],
      "naive_approach": [
        "Brute force checking all possibilities."
      ],
      "approach_blueprint": [
        "1. Apply pattern",
        "2. Optimize"
      ]
    },
    "strategyShift": "Optimal solution using Dynamic Programming.",
    "naiveApproach": "Iterative approach checking all pairs/subsets.",
    "optimalApproach": "Optimal solution using Dynamic Programming.",
    "simpleExplanation": "Optimal substructure using Fibonacci relation.",
    "subPattern": "postorder_accumulation",
    "patternLevel": "advanced_patterns"
  },
  {
    "id": 24,
    "title": "Search a 2D Matrix",
    "slug": "search-a-2d-matrix",
    "difficulty": "Medium",
    "algorithmType": "binary_search",
    "status": "new",
    "tags": [
      "Binary Search"
    ],
    "primaryPattern": "binary_search",
    "shortPatternReason": "Treating matrix as flattened sorted array.",
    "time_complexity": "O(log(m*n))",
    "space_complexity": "O(1)",
    "problem_statement": "Standard LeetCode problem: Search a 2D Matrix.",
    "constraints": [
      "N <= 10^5"
    ],
    "examples": [],
    "brute_force_explanation": "Iterative approach checking all pairs/subsets.",
    "optimal_explanation": "Optimal solution using Binary Search.",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(log(m*n))",
      "space": "O(1)"
    },
    "patternSignals": [
      "Treating matrix as flattened sorted array."
    ],
    "edgeCases": [
      "Small input",
      "Large values"
    ],
    "thinking_guide": {
      "first_principles": [
        "Understand the goal of Search a 2D Matrix."
      ],
      "pattern_signals": [
        "Treating matrix as flattened sorted array."
      ],
      "naive_approach": [
        "Brute force checking all possibilities."
      ],
      "approach_blueprint": [
        "1. Apply pattern",
        "2. Optimize"
      ]
    },
    "strategyShift": "Optimal solution using Binary Search.",
    "naiveApproach": "Iterative approach checking all pairs/subsets.",
    "optimalApproach": "Optimal solution using Binary Search.",
    "simpleExplanation": "Treating matrix as flattened sorted array.",
    "subPattern": "classic",
    "patternLevel": "core_patterns"
  },
  {
    "id": 25,
    "title": "Minimum Window Substring",
    "slug": "minimum-window-substring",
    "difficulty": "Hard",
    "algorithmType": "sliding_window",
    "status": "new",
    "tags": [
      "Sliding Window"
    ],
    "primaryPattern": "sliding_window",
    "shortPatternReason": "Dynamic window expansion and contraction for constraint.",
    "time_complexity": "O(n+m)",
    "space_complexity": "O(m)",
    "problem_statement": "Standard LeetCode problem: Minimum Window Substring.",
    "constraints": [
      "N <= 10^5"
    ],
    "examples": [],
    "brute_force_explanation": "Iterative approach checking all pairs/subsets.",
    "optimal_explanation": "Optimal solution using Sliding Window.",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(n+m)",
      "space": "O(m)"
    },
    "patternSignals": [
      "Dynamic window expansion and contraction for constraint."
    ],
    "edgeCases": [
      "Small input",
      "Large values"
    ],
    "thinking_guide": {
      "first_principles": [
        "Understand the goal of Minimum Window Substring."
      ],
      "pattern_signals": [
        "Dynamic window expansion and contraction for constraint."
      ],
      "naive_approach": [
        "Brute force checking all possibilities."
      ],
      "approach_blueprint": [
        "1. Apply pattern",
        "2. Optimize"
      ]
    },
    "strategyShift": "Optimal solution using Sliding Window.",
    "naiveApproach": "Iterative approach checking all pairs/subsets.",
    "optimalApproach": "Optimal solution using Sliding Window.",
    "simpleExplanation": "Dynamic window expansion and contraction for constraint.",
    "subPattern": "minimum_type",
    "patternLevel": "core_patterns"
  },
  {
    "id": 26,
    "title": "Subsets",
    "slug": "subsets",
    "difficulty": "Medium",
    "algorithmType": "recursion",
    "status": "new",
    "tags": [
      "Backtracking"
    ],
    "primaryPattern": "graph_traversal",
    "shortPatternReason": "Power set generation via inclusion/exclusion.",
    "time_complexity": "O(n * 2\u207f)",
    "space_complexity": "O(n)",
    "problem_statement": "Standard LeetCode problem: Subsets.",
    "constraints": [
      "N <= 10^5"
    ],
    "examples": [],
    "brute_force_explanation": "Iterative approach checking all pairs/subsets.",
    "optimal_explanation": "Optimal solution using Backtracking.",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(n * 2\u207f)",
      "space": "O(n)"
    },
    "patternSignals": [
      "Power set generation via inclusion/exclusion."
    ],
    "edgeCases": [
      "Small input",
      "Large values"
    ],
    "thinking_guide": {
      "first_principles": [
        "Understand the goal of Subsets."
      ],
      "pattern_signals": [
        "Power set generation via inclusion/exclusion."
      ],
      "naive_approach": [
        "Brute force checking all possibilities."
      ],
      "approach_blueprint": [
        "1. Apply pattern",
        "2. Optimize"
      ]
    },
    "strategyShift": "Optimal solution using Backtracking.",
    "naiveApproach": "Iterative approach checking all pairs/subsets.",
    "optimalApproach": "Optimal solution using Backtracking.",
    "simpleExplanation": "Power set generation via inclusion/exclusion.",
    "subPattern": "dfs_backtracking",
    "patternLevel": "advanced_patterns"
  },
  {
    "id": 27,
    "title": "Word Search",
    "slug": "word-search",
    "difficulty": "Medium",
    "algorithmType": "graph",
    "status": "new",
    "tags": [
      "Backtracking"
    ],
    "primaryPattern": "graph_traversal",
    "shortPatternReason": "DFS traversal with state backtracking on grid.",
    "time_complexity": "O(N * 3\u1d38)",
    "space_complexity": "O(L)",
    "problem_statement": "Standard LeetCode problem: Word Search.",
    "constraints": [
      "N <= 10^5"
    ],
    "examples": [],
    "brute_force_explanation": "Iterative approach checking all pairs/subsets.",
    "optimal_explanation": "Optimal solution using Backtracking.",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(N * 3\u1d38)",
      "space": "O(L)"
    },
    "patternSignals": [
      "DFS traversal with state backtracking on grid."
    ],
    "edgeCases": [
      "Small input",
      "Large values"
    ],
    "thinking_guide": {
      "first_principles": [
        "Understand the goal of Word Search."
      ],
      "pattern_signals": [
        "DFS traversal with state backtracking on grid."
      ],
      "naive_approach": [
        "Brute force checking all possibilities."
      ],
      "approach_blueprint": [
        "1. Apply pattern",
        "2. Optimize"
      ]
    },
    "strategyShift": "Optimal solution using Backtracking.",
    "naiveApproach": "Iterative approach checking all pairs/subsets.",
    "optimalApproach": "Optimal solution using Backtracking.",
    "simpleExplanation": "DFS traversal with state backtracking on grid.",
    "subPattern": "dfs_backtracking",
    "patternLevel": "advanced_patterns"
  },
  {
    "id": 28,
    "title": "Validate Binary Search Tree",
    "slug": "validate-binary-search-tree",
    "difficulty": "Medium",
    "algorithmType": "tree",
    "status": "new",
    "tags": [
      "Recursion"
    ],
    "primaryPattern": "tree_patterns",
    "shortPatternReason": "Recursive range check for child nodes.",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "problem_statement": "Standard LeetCode problem: Validate Binary Search Tree.",
    "constraints": [
      "N <= 10^5"
    ],
    "examples": [],
    "brute_force_explanation": "Iterative approach checking all pairs/subsets.",
    "optimal_explanation": "Optimal solution using Recursion.",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(n)",
      "space": "O(n)"
    },
    "patternSignals": [
      "Recursive range check for child nodes."
    ],
    "edgeCases": [
      "Small input",
      "Large values"
    ],
    "thinking_guide": {
      "first_principles": [
        "Understand the goal of Validate Binary Search Tree."
      ],
      "pattern_signals": [
        "Recursive range check for child nodes."
      ],
      "naive_approach": [
        "Brute force checking all possibilities."
      ],
      "approach_blueprint": [
        "1. Apply pattern",
        "2. Optimize"
      ]
    },
    "strategyShift": "Optimal solution using Recursion.",
    "naiveApproach": "Iterative approach checking all pairs/subsets.",
    "optimalApproach": "Optimal solution using Recursion.",
    "simpleExplanation": "Recursive range check for child nodes.",
    "subPattern": "postorder_accumulation",
    "patternLevel": "advanced_patterns"
  },
  {
    "id": 29,
    "title": "Binary Tree Level Order Traversal",
    "slug": "binary-tree-level-order-traversal",
    "difficulty": "Medium",
    "algorithmType": "tree",
    "status": "new",
    "tags": [
      "Graph (BFS/DFS)"
    ],
    "primaryPattern": "graph_traversal",
    "shortPatternReason": "Queue-based breadth-first visit.",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "problem_statement": "Standard LeetCode problem: Binary Tree Level Order Traversal.",
    "constraints": [
      "N <= 10^5"
    ],
    "examples": [],
    "brute_force_explanation": "Iterative approach checking all pairs/subsets.",
    "optimal_explanation": "Optimal solution using Graph (BFS/DFS).",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(n)",
      "space": "O(n)"
    },
    "patternSignals": [
      "Queue-based breadth-first visit."
    ],
    "edgeCases": [
      "Small input",
      "Large values"
    ],
    "thinking_guide": {
      "first_principles": [
        "Understand the goal of Binary Tree Level Order Traversal."
      ],
      "pattern_signals": [
        "Queue-based breadth-first visit."
      ],
      "naive_approach": [
        "Brute force checking all possibilities."
      ],
      "approach_blueprint": [
        "1. Apply pattern",
        "2. Optimize"
      ]
    },
    "strategyShift": "Optimal solution using Graph (BFS/DFS).",
    "naiveApproach": "Iterative approach checking all pairs/subsets.",
    "optimalApproach": "Optimal solution using Graph (BFS/DFS).",
    "simpleExplanation": "Queue-based breadth-first visit.",
    "subPattern": "bfs_level_order",
    "patternLevel": "advanced_patterns"
  },
  {
    "id": 30,
    "title": "Maximum Depth of Binary Tree",
    "slug": "maximum-depth-of-binary-tree",
    "difficulty": "Easy",
    "algorithmType": "tree",
    "status": "new",
    "tags": [
      "Recursion"
    ],
    "primaryPattern": "tree_patterns",
    "shortPatternReason": "Recursive height calculation (1 + max(L, R)).",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "problem_statement": "Standard LeetCode problem: Maximum Depth of Binary Tree.",
    "constraints": [
      "N <= 10^5"
    ],
    "examples": [],
    "brute_force_explanation": "Iterative approach checking all pairs/subsets.",
    "optimal_explanation": "Optimal solution using Recursion.",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(n)",
      "space": "O(n)"
    },
    "patternSignals": [
      "Recursive height calculation (1 + max(L, R))."
    ],
    "edgeCases": [
      "Small input",
      "Large values"
    ],
    "thinking_guide": {
      "first_principles": [
        "Understand the goal of Maximum Depth of Binary Tree."
      ],
      "pattern_signals": [
        "Recursive height calculation (1 + max(L, R))."
      ],
      "naive_approach": [
        "Brute force checking all possibilities."
      ],
      "approach_blueprint": [
        "1. Apply pattern",
        "2. Optimize"
      ]
    },
    "strategyShift": "Optimal solution using Recursion.",
    "naiveApproach": "Iterative approach checking all pairs/subsets.",
    "optimalApproach": "Optimal solution using Recursion.",
    "simpleExplanation": "Recursive height calculation (1 + max(L, R)).",
    "subPattern": "postorder_accumulation",
    "patternLevel": "advanced_patterns"
  },
  {
    "id": 31,
    "title": "Best Time to Buy and Sell Stock",
    "slug": "best-time-to-buy-and-sell-stock",
    "difficulty": "Easy",
    "algorithmType": "two_pointer",
    "status": "new",
    "tags": [
      "Dynamic Programming"
    ],
    "primaryPattern": "two_pointer",
    "shortPatternReason": "Tracking historical minimum for future profit.",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "problem_statement": "Standard LeetCode problem: Best Time to Buy and Sell Stock.",
    "constraints": [
      "N <= 10^5"
    ],
    "examples": [],
    "brute_force_explanation": "Iterative approach checking all pairs/subsets.",
    "optimal_explanation": "Optimal solution using Dynamic Programming.",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(n)",
      "space": "O(1)"
    },
    "patternSignals": [
      "Tracking historical minimum for future profit."
    ],
    "edgeCases": [
      "Small input",
      "Large values"
    ],
    "thinking_guide": {
      "first_principles": [
        "Understand the goal of Best Time to Buy and Sell Stock."
      ],
      "pattern_signals": [
        "Tracking historical minimum for future profit."
      ],
      "naive_approach": [
        "Brute force checking all possibilities."
      ],
      "approach_blueprint": [
        "1. Apply pattern",
        "2. Optimize"
      ]
    },
    "strategyShift": "Optimal solution using Dynamic Programming.",
    "naiveApproach": "Iterative approach checking all pairs/subsets.",
    "optimalApproach": "Optimal solution using Dynamic Programming.",
    "simpleExplanation": "Tracking historical minimum for future profit.",
    "subPattern": "same_direction",
    "patternLevel": "core_patterns"
  },
  {
    "id": 32,
    "title": "Longest Consecutive Sequence",
    "slug": "longest-consecutive-sequence",
    "difficulty": "Medium",
    "algorithmType": "two_pointer",
    "status": "new",
    "tags": [
      "Array"
    ],
    "primaryPattern": "two_pointer",
    "shortPatternReason": "Unordered set lookup for sequence starts.",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "problem_statement": "Standard LeetCode problem: Longest Consecutive Sequence.",
    "constraints": [
      "N <= 10^5"
    ],
    "examples": [],
    "brute_force_explanation": "Iterative approach checking all pairs/subsets.",
    "optimal_explanation": "Optimal solution using Array.",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(n)",
      "space": "O(n)"
    },
    "patternSignals": [
      "Unordered set lookup for sequence starts."
    ],
    "edgeCases": [
      "Small input",
      "Large values"
    ],
    "thinking_guide": {
      "first_principles": [
        "Understand the goal of Longest Consecutive Sequence."
      ],
      "pattern_signals": [
        "Unordered set lookup for sequence starts."
      ],
      "naive_approach": [
        "Brute force checking all possibilities."
      ],
      "approach_blueprint": [
        "1. Apply pattern",
        "2. Optimize"
      ]
    },
    "strategyShift": "Optimal solution using Array.",
    "naiveApproach": "Iterative approach checking all pairs/subsets.",
    "optimalApproach": "Optimal solution using Array.",
    "simpleExplanation": "Unordered set lookup for sequence starts.",
    "subPattern": "same_direction",
    "patternLevel": "core_patterns"
  },
  {
    "id": 33,
    "title": "Clone Graph",
    "slug": "clone-graph",
    "difficulty": "Medium",
    "algorithmType": "graph",
    "status": "new",
    "tags": [
      "Graph (BFS/DFS)"
    ],
    "primaryPattern": "graph_traversal",
    "shortPatternReason": "Deep copy using traversal and map state.",
    "time_complexity": "O(V+E)",
    "space_complexity": "O(V)",
    "problem_statement": "Standard LeetCode problem: Clone Graph.",
    "constraints": [
      "N <= 10^5"
    ],
    "examples": [],
    "brute_force_explanation": "Iterative approach checking all pairs/subsets.",
    "optimal_explanation": "Optimal solution using Graph (BFS/DFS).",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(V+E)",
      "space": "O(V)"
    },
    "patternSignals": [
      "Deep copy using traversal and map state."
    ],
    "edgeCases": [
      "Small input",
      "Large values"
    ],
    "thinking_guide": {
      "first_principles": [
        "Understand the goal of Clone Graph."
      ],
      "pattern_signals": [
        "Deep copy using traversal and map state."
      ],
      "naive_approach": [
        "Brute force checking all possibilities."
      ],
      "approach_blueprint": [
        "1. Apply pattern",
        "2. Optimize"
      ]
    },
    "strategyShift": "Optimal solution using Graph (BFS/DFS).",
    "naiveApproach": "Iterative approach checking all pairs/subsets.",
    "optimalApproach": "Optimal solution using Graph (BFS/DFS).",
    "simpleExplanation": "Deep copy using traversal and map state.",
    "subPattern": "bfs_level_order",
    "patternLevel": "advanced_patterns"
  },
  {
    "id": 34,
    "title": "Single Number",
    "slug": "single-number",
    "difficulty": "Easy",
    "algorithmType": "two_pointer",
    "status": "new",
    "tags": [
      "Array"
    ],
    "primaryPattern": "two_pointer",
    "shortPatternReason": "XOR property to cancel out duplicates.",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "problem_statement": "Standard LeetCode problem: Single Number.",
    "constraints": [
      "N <= 10^5"
    ],
    "examples": [],
    "brute_force_explanation": "Iterative approach checking all pairs/subsets.",
    "optimal_explanation": "Optimal solution using Array.",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(n)",
      "space": "O(1)"
    },
    "patternSignals": [
      "XOR property to cancel out duplicates."
    ],
    "edgeCases": [
      "Small input",
      "Large values"
    ],
    "thinking_guide": {
      "first_principles": [
        "Understand the goal of Single Number."
      ],
      "pattern_signals": [
        "XOR property to cancel out duplicates."
      ],
      "naive_approach": [
        "Brute force checking all possibilities."
      ],
      "approach_blueprint": [
        "1. Apply pattern",
        "2. Optimize"
      ]
    },
    "strategyShift": "Optimal solution using Array.",
    "naiveApproach": "Iterative approach checking all pairs/subsets.",
    "optimalApproach": "Optimal solution using Array.",
    "simpleExplanation": "XOR property to cancel out duplicates.",
    "subPattern": "same_direction",
    "patternLevel": "core_patterns"
  },
  {
    "id": 35,
    "title": "Word Break",
    "slug": "word-break",
    "difficulty": "Medium",
    "algorithmType": "two_pointer",
    "status": "new",
    "tags": [
      "Dynamic Programming"
    ],
    "primaryPattern": "two_pointer",
    "shortPatternReason": "Boolean DP tracking word segmentability.",
    "time_complexity": "O(n\u00b3)",
    "space_complexity": "O(n)",
    "problem_statement": "Standard LeetCode problem: Word Break.",
    "constraints": [
      "N <= 10^5"
    ],
    "examples": [],
    "brute_force_explanation": "Iterative approach checking all pairs/subsets.",
    "optimal_explanation": "Optimal solution using Dynamic Programming.",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(n\u00b3)",
      "space": "O(n)"
    },
    "patternSignals": [
      "Boolean DP tracking word segmentability."
    ],
    "edgeCases": [
      "Small input",
      "Large values"
    ],
    "thinking_guide": {
      "first_principles": [
        "Understand the goal of Word Break."
      ],
      "pattern_signals": [
        "Boolean DP tracking word segmentability."
      ],
      "naive_approach": [
        "Brute force checking all possibilities."
      ],
      "approach_blueprint": [
        "1. Apply pattern",
        "2. Optimize"
      ]
    },
    "strategyShift": "Optimal solution using Dynamic Programming.",
    "naiveApproach": "Iterative approach checking all pairs/subsets.",
    "optimalApproach": "Optimal solution using Dynamic Programming.",
    "simpleExplanation": "Boolean DP tracking word segmentability.",
    "subPattern": "same_direction",
    "patternLevel": "core_patterns"
  },
  {
    "id": 36,
    "title": "Linked List Cycle",
    "slug": "linked-list-cycle",
    "difficulty": "Easy",
    "algorithmType": "linked_list",
    "status": "new",
    "tags": [
      "Two Pointer"
    ],
    "primaryPattern": "two_pointer",
    "shortPatternReason": "Floyd's Tortoise and Hare detection.",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "problem_statement": "Standard LeetCode problem: Linked List Cycle.",
    "constraints": [
      "N <= 10^5"
    ],
    "examples": [],
    "brute_force_explanation": "Iterative approach checking all pairs/subsets.",
    "optimal_explanation": "Optimal solution using Two Pointer.",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(n)",
      "space": "O(1)"
    },
    "patternSignals": [
      "Floyd's Tortoise and Hare detection."
    ],
    "edgeCases": [
      "Small input",
      "Large values"
    ],
    "thinking_guide": {
      "first_principles": [
        "Understand the goal of Linked List Cycle."
      ],
      "pattern_signals": [
        "Floyd's Tortoise and Hare detection."
      ],
      "naive_approach": [
        "Brute force checking all possibilities."
      ],
      "approach_blueprint": [
        "1. Apply pattern",
        "2. Optimize"
      ]
    },
    "strategyShift": "Optimal solution using Two Pointer.",
    "naiveApproach": "Iterative approach checking all pairs/subsets.",
    "optimalApproach": "Optimal solution using Two Pointer.",
    "simpleExplanation": "Floyd's Tortoise and Hare detection.",
    "subPattern": "same_direction",
    "patternLevel": "core_patterns"
  },
  {
    "id": 37,
    "title": "Maximum Product Subarray",
    "slug": "maximum-product-subarray",
    "difficulty": "Medium",
    "algorithmType": "two_pointer",
    "status": "new",
    "tags": [
      "Dynamic Programming"
    ],
    "primaryPattern": "two_pointer",
    "shortPatternReason": "Tracking current min/max to handle negatives.",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "problem_statement": "Standard LeetCode problem: Maximum Product Subarray.",
    "constraints": [
      "N <= 10^5"
    ],
    "examples": [],
    "brute_force_explanation": "Iterative approach checking all pairs/subsets.",
    "optimal_explanation": "Optimal solution using Dynamic Programming.",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(n)",
      "space": "O(1)"
    },
    "patternSignals": [
      "Tracking current min/max to handle negatives."
    ],
    "edgeCases": [
      "Small input",
      "Large values"
    ],
    "thinking_guide": {
      "first_principles": [
        "Understand the goal of Maximum Product Subarray."
      ],
      "pattern_signals": [
        "Tracking current min/max to handle negatives."
      ],
      "naive_approach": [
        "Brute force checking all possibilities."
      ],
      "approach_blueprint": [
        "1. Apply pattern",
        "2. Optimize"
      ]
    },
    "strategyShift": "Optimal solution using Dynamic Programming.",
    "naiveApproach": "Iterative approach checking all pairs/subsets.",
    "optimalApproach": "Optimal solution using Dynamic Programming.",
    "simpleExplanation": "Tracking current min/max to handle negatives.",
    "subPattern": "same_direction",
    "patternLevel": "core_patterns"
  },
  {
    "id": 38,
    "title": "Find Minimum in Rotated Sorted Array",
    "slug": "find-minimum-in-rotated-sorted-array",
    "difficulty": "Medium",
    "algorithmType": "binary_search",
    "status": "new",
    "tags": [
      "Binary Search"
    ],
    "primaryPattern": "binary_search",
    "shortPatternReason": "Logarithmic search for inflection point.",
    "time_complexity": "O(log n)",
    "space_complexity": "O(1)",
    "problem_statement": "Standard LeetCode problem: Find Minimum in Rotated Sorted Array.",
    "constraints": [
      "N <= 10^5"
    ],
    "examples": [],
    "brute_force_explanation": "Iterative approach checking all pairs/subsets.",
    "optimal_explanation": "Optimal solution using Binary Search.",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(log n)",
      "space": "O(1)"
    },
    "patternSignals": [
      "Logarithmic search for inflection point."
    ],
    "edgeCases": [
      "Small input",
      "Large values"
    ],
    "thinking_guide": {
      "first_principles": [
        "Understand the goal of Find Minimum in Rotated Sorted Array."
      ],
      "pattern_signals": [
        "Logarithmic search for inflection point."
      ],
      "naive_approach": [
        "Brute force checking all possibilities."
      ],
      "approach_blueprint": [
        "1. Apply pattern",
        "2. Optimize"
      ]
    },
    "strategyShift": "Optimal solution using Binary Search.",
    "naiveApproach": "Iterative approach checking all pairs/subsets.",
    "optimalApproach": "Optimal solution using Binary Search.",
    "simpleExplanation": "Logarithmic search for inflection point.",
    "subPattern": "classic",
    "patternLevel": "core_patterns"
  },
  {
    "id": 39,
    "title": "Min Stack",
    "slug": "min-stack",
    "difficulty": "Easy",
    "algorithmType": "stack",
    "status": "new",
    "tags": [
      "Stack"
    ],
    "primaryPattern": "array_basics",
    "shortPatternReason": "Auxiliary stack to track historical minima.",
    "time_complexity": "O(1)",
    "space_complexity": "O(n)",
    "problem_statement": "Standard LeetCode problem: Min Stack.",
    "constraints": [
      "N <= 10^5"
    ],
    "examples": [],
    "brute_force_explanation": "Iterative approach checking all pairs/subsets.",
    "optimal_explanation": "Optimal solution using Stack.",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(1)",
      "space": "O(n)"
    },
    "patternSignals": [
      "Auxiliary stack to track historical minima."
    ],
    "edgeCases": [
      "Small input",
      "Large values"
    ],
    "thinking_guide": {
      "first_principles": [
        "Understand the goal of Min Stack."
      ],
      "pattern_signals": [
        "Auxiliary stack to track historical minima."
      ],
      "naive_approach": [
        "Brute force checking all possibilities."
      ],
      "approach_blueprint": [
        "1. Apply pattern",
        "2. Optimize"
      ]
    },
    "strategyShift": "Optimal solution using Stack.",
    "naiveApproach": "Iterative approach checking all pairs/subsets.",
    "optimalApproach": "Optimal solution using Stack.",
    "simpleExplanation": "Auxiliary stack to track historical minima.",
    "subPattern": "prefix_sum",
    "patternLevel": "foundation"
  },
  {
    "id": 40,
    "title": "House Robber",
    "slug": "house-robber",
    "difficulty": "Medium",
    "algorithmType": "recursion",
    "status": "new",
    "tags": [
      "Dynamic Programming"
    ],
    "primaryPattern": "tree_patterns",
    "shortPatternReason": "Non-adjacent max sum recurrence.",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "problem_statement": "Standard LeetCode problem: House Robber.",
    "constraints": [
      "N <= 10^5"
    ],
    "examples": [],
    "brute_force_explanation": "Iterative approach checking all pairs/subsets.",
    "optimal_explanation": "Optimal solution using Dynamic Programming.",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(n)",
      "space": "O(1)"
    },
    "patternSignals": [
      "Non-adjacent max sum recurrence."
    ],
    "edgeCases": [
      "Small input",
      "Large values"
    ],
    "thinking_guide": {
      "first_principles": [
        "Understand the goal of House Robber."
      ],
      "pattern_signals": [
        "Non-adjacent max sum recurrence."
      ],
      "naive_approach": [
        "Brute force checking all possibilities."
      ],
      "approach_blueprint": [
        "1. Apply pattern",
        "2. Optimize"
      ]
    },
    "strategyShift": "Optimal solution using Dynamic Programming.",
    "naiveApproach": "Iterative approach checking all pairs/subsets.",
    "optimalApproach": "Optimal solution using Dynamic Programming.",
    "simpleExplanation": "Non-adjacent max sum recurrence.",
    "subPattern": "postorder_accumulation",
    "patternLevel": "advanced_patterns"
  },
  {
    "id": 41,
    "title": "Number of Islands",
    "slug": "number-of-islands",
    "difficulty": "Medium",
    "algorithmType": "graph",
    "status": "new",
    "tags": [
      "Graph (BFS/DFS)"
    ],
    "primaryPattern": "graph_traversal",
    "shortPatternReason": "Grid traversal to group connected components.",
    "time_complexity": "O(M*N)",
    "space_complexity": "O(M*N)",
    "problem_statement": "Standard LeetCode problem: Number of Islands.",
    "constraints": [
      "N <= 10^5"
    ],
    "examples": [],
    "brute_force_explanation": "Iterative approach checking all pairs/subsets.",
    "optimal_explanation": "Optimal solution using Graph (BFS/DFS).",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(M*N)",
      "space": "O(M*N)"
    },
    "patternSignals": [
      "Grid traversal to group connected components."
    ],
    "edgeCases": [
      "Small input",
      "Large values"
    ],
    "thinking_guide": {
      "first_principles": [
        "Understand the goal of Number of Islands."
      ],
      "pattern_signals": [
        "Grid traversal to group connected components."
      ],
      "naive_approach": [
        "Brute force checking all possibilities."
      ],
      "approach_blueprint": [
        "1. Apply pattern",
        "2. Optimize"
      ]
    },
    "strategyShift": "Optimal solution using Graph (BFS/DFS).",
    "naiveApproach": "Iterative approach checking all pairs/subsets.",
    "optimalApproach": "Optimal solution using Graph (BFS/DFS).",
    "simpleExplanation": "Grid traversal to group connected components.",
    "subPattern": "bfs_level_order",
    "patternLevel": "advanced_patterns"
  },
  {
    "id": 42,
    "title": "Reverse Linked List",
    "slug": "reverse-linked-list",
    "difficulty": "Easy",
    "algorithmType": "linked_list",
    "status": "new",
    "tags": [
      "Two Pointer"
    ],
    "primaryPattern": "two_pointer",
    "shortPatternReason": "In-place pointer reversal logic.",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "problem_statement": "Standard LeetCode problem: Reverse Linked List.",
    "constraints": [
      "N <= 10^5"
    ],
    "examples": [],
    "brute_force_explanation": "Iterative approach checking all pairs/subsets.",
    "optimal_explanation": "Optimal solution using Two Pointer.",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(n)",
      "space": "O(1)"
    },
    "patternSignals": [
      "In-place pointer reversal logic."
    ],
    "edgeCases": [
      "Small input",
      "Large values"
    ],
    "thinking_guide": {
      "first_principles": [
        "Understand the goal of Reverse Linked List."
      ],
      "pattern_signals": [
        "In-place pointer reversal logic."
      ],
      "naive_approach": [
        "Brute force checking all possibilities."
      ],
      "approach_blueprint": [
        "1. Apply pattern",
        "2. Optimize"
      ]
    },
    "strategyShift": "Optimal solution using Two Pointer.",
    "naiveApproach": "Iterative approach checking all pairs/subsets.",
    "optimalApproach": "Optimal solution using Two Pointer.",
    "simpleExplanation": "In-place pointer reversal logic.",
    "subPattern": "same_direction",
    "patternLevel": "core_patterns"
  },
  {
    "id": 43,
    "title": "Course Schedule",
    "slug": "course-schedule",
    "difficulty": "Medium",
    "algorithmType": "graph",
    "status": "new",
    "tags": [
      "Graph (BFS/DFS)"
    ],
    "primaryPattern": "graph_traversal",
    "shortPatternReason": "Cycle detection in DAG (Topological Sort).",
    "time_complexity": "O(V+E)",
    "space_complexity": "O(V+E)",
    "problem_statement": "Standard LeetCode problem: Course Schedule.",
    "constraints": [
      "N <= 10^5"
    ],
    "examples": [],
    "brute_force_explanation": "Iterative approach checking all pairs/subsets.",
    "optimal_explanation": "Optimal solution using Graph (BFS/DFS).",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(V+E)",
      "space": "O(V+E)"
    },
    "patternSignals": [
      "Cycle detection in DAG (Topological Sort)."
    ],
    "edgeCases": [
      "Small input",
      "Large values"
    ],
    "thinking_guide": {
      "first_principles": [
        "Understand the goal of Course Schedule."
      ],
      "pattern_signals": [
        "Cycle detection in DAG (Topological Sort)."
      ],
      "naive_approach": [
        "Brute force checking all possibilities."
      ],
      "approach_blueprint": [
        "1. Apply pattern",
        "2. Optimize"
      ]
    },
    "strategyShift": "Optimal solution using Graph (BFS/DFS).",
    "naiveApproach": "Iterative approach checking all pairs/subsets.",
    "optimalApproach": "Optimal solution using Graph (BFS/DFS).",
    "simpleExplanation": "Cycle detection in DAG (Topological Sort).",
    "subPattern": "bfs_level_order",
    "patternLevel": "advanced_patterns"
  },
  {
    "id": 44,
    "title": "Implement Trie (Prefix Tree)",
    "slug": "implement-trie-prefix-tree",
    "difficulty": "Medium",
    "algorithmType": "tree",
    "status": "new",
    "tags": [
      "Recursion"
    ],
    "primaryPattern": "tree_patterns",
    "shortPatternReason": "Character-based path traversal logic.",
    "time_complexity": "O(L)",
    "space_complexity": "O(Words * L)",
    "problem_statement": "Standard LeetCode problem: Implement Trie (Prefix Tree).",
    "constraints": [
      "N <= 10^5"
    ],
    "examples": [],
    "brute_force_explanation": "Iterative approach checking all pairs/subsets.",
    "optimal_explanation": "Optimal solution using Recursion.",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(L)",
      "space": "O(Words * L)"
    },
    "patternSignals": [
      "Character-based path traversal logic."
    ],
    "edgeCases": [
      "Small input",
      "Large values"
    ],
    "thinking_guide": {
      "first_principles": [
        "Understand the goal of Implement Trie (Prefix Tree)."
      ],
      "pattern_signals": [
        "Character-based path traversal logic."
      ],
      "naive_approach": [
        "Brute force checking all possibilities."
      ],
      "approach_blueprint": [
        "1. Apply pattern",
        "2. Optimize"
      ]
    },
    "strategyShift": "Optimal solution using Recursion.",
    "naiveApproach": "Iterative approach checking all pairs/subsets.",
    "optimalApproach": "Optimal solution using Recursion.",
    "simpleExplanation": "Character-based path traversal logic.",
    "subPattern": "postorder_accumulation",
    "patternLevel": "advanced_patterns"
  },
  {
    "id": 45,
    "title": "Kth Largest Element in an Array",
    "slug": "kth-largest-element-in-an-array",
    "difficulty": "Medium",
    "algorithmType": "two_pointer",
    "status": "new",
    "tags": [
      "Heap / Priority Queue"
    ],
    "primaryPattern": "two_pointer",
    "shortPatternReason": "Min-heap for tracking top K elements.",
    "time_complexity": "O(n log k)",
    "space_complexity": "O(k)",
    "problem_statement": "Standard LeetCode problem: Kth Largest Element in an Array.",
    "constraints": [
      "N <= 10^5"
    ],
    "examples": [],
    "brute_force_explanation": "Iterative approach checking all pairs/subsets.",
    "optimal_explanation": "Optimal solution using Heap / Priority Queue.",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(n log k)",
      "space": "O(k)"
    },
    "patternSignals": [
      "Min-heap for tracking top K elements."
    ],
    "edgeCases": [
      "Small input",
      "Large values"
    ],
    "thinking_guide": {
      "first_principles": [
        "Understand the goal of Kth Largest Element in an Array."
      ],
      "pattern_signals": [
        "Min-heap for tracking top K elements."
      ],
      "naive_approach": [
        "Brute force checking all possibilities."
      ],
      "approach_blueprint": [
        "1. Apply pattern",
        "2. Optimize"
      ]
    },
    "strategyShift": "Optimal solution using Heap / Priority Queue.",
    "naiveApproach": "Iterative approach checking all pairs/subsets.",
    "optimalApproach": "Optimal solution using Heap / Priority Queue.",
    "simpleExplanation": "Min-heap for tracking top K elements.",
    "subPattern": "same_direction",
    "patternLevel": "core_patterns"
  },
  {
    "id": 46,
    "title": "Invert Binary Tree",
    "slug": "invert-binary-tree",
    "difficulty": "Easy",
    "algorithmType": "tree",
    "status": "new",
    "tags": [
      "Recursion"
    ],
    "primaryPattern": "tree_patterns",
    "shortPatternReason": "Recursive swap of left and right children.",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "problem_statement": "Standard LeetCode problem: Invert Binary Tree.",
    "constraints": [
      "N <= 10^5"
    ],
    "examples": [],
    "brute_force_explanation": "Iterative approach checking all pairs/subsets.",
    "optimal_explanation": "Optimal solution using Recursion.",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(n)",
      "space": "O(n)"
    },
    "patternSignals": [
      "Recursive swap of left and right children."
    ],
    "edgeCases": [
      "Small input",
      "Large values"
    ],
    "thinking_guide": {
      "first_principles": [
        "Understand the goal of Invert Binary Tree."
      ],
      "pattern_signals": [
        "Recursive swap of left and right children."
      ],
      "naive_approach": [
        "Brute force checking all possibilities."
      ],
      "approach_blueprint": [
        "1. Apply pattern",
        "2. Optimize"
      ]
    },
    "strategyShift": "Optimal solution using Recursion.",
    "naiveApproach": "Iterative approach checking all pairs/subsets.",
    "optimalApproach": "Optimal solution using Recursion.",
    "simpleExplanation": "Recursive swap of left and right children.",
    "subPattern": "postorder_accumulation",
    "patternLevel": "advanced_patterns"
  },
  {
    "id": 47,
    "title": "Kth Smallest Element in a BST",
    "slug": "kth-smallest-element-in-a-bst",
    "difficulty": "Medium",
    "algorithmType": "tree",
    "status": "new",
    "tags": [
      "Recursion"
    ],
    "primaryPattern": "tree_patterns",
    "shortPatternReason": "Inorder traversal property of BST.",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "problem_statement": "Standard LeetCode problem: Kth Smallest Element in a BST.",
    "constraints": [
      "N <= 10^5"
    ],
    "examples": [],
    "brute_force_explanation": "Iterative approach checking all pairs/subsets.",
    "optimal_explanation": "Optimal solution using Recursion.",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(n)",
      "space": "O(n)"
    },
    "patternSignals": [
      "Inorder traversal property of BST."
    ],
    "edgeCases": [
      "Small input",
      "Large values"
    ],
    "thinking_guide": {
      "first_principles": [
        "Understand the goal of Kth Smallest Element in a BST."
      ],
      "pattern_signals": [
        "Inorder traversal property of BST."
      ],
      "naive_approach": [
        "Brute force checking all possibilities."
      ],
      "approach_blueprint": [
        "1. Apply pattern",
        "2. Optimize"
      ]
    },
    "strategyShift": "Optimal solution using Recursion.",
    "naiveApproach": "Iterative approach checking all pairs/subsets.",
    "optimalApproach": "Optimal solution using Recursion.",
    "simpleExplanation": "Inorder traversal property of BST.",
    "subPattern": "postorder_accumulation",
    "patternLevel": "advanced_patterns"
  },
  {
    "id": 48,
    "title": "Implement Queue using Stacks",
    "slug": "implement-queue-using-stacks",
    "difficulty": "Easy",
    "algorithmType": "stack",
    "status": "new",
    "tags": [
      "Queue"
    ],
    "primaryPattern": "array_basics",
    "shortPatternReason": "Simulating FIFO with two LIFO stacks.",
    "time_complexity": "O(1) amortized",
    "space_complexity": "O(n)",
    "problem_statement": "Standard LeetCode problem: Implement Queue using Stacks.",
    "constraints": [
      "N <= 10^5"
    ],
    "examples": [],
    "brute_force_explanation": "Iterative approach checking all pairs/subsets.",
    "optimal_explanation": "Optimal solution using Queue.",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(1) amortized",
      "space": "O(n)"
    },
    "patternSignals": [
      "Simulating FIFO with two LIFO stacks."
    ],
    "edgeCases": [
      "Small input",
      "Large values"
    ],
    "thinking_guide": {
      "first_principles": [
        "Understand the goal of Implement Queue using Stacks."
      ],
      "pattern_signals": [
        "Simulating FIFO with two LIFO stacks."
      ],
      "naive_approach": [
        "Brute force checking all possibilities."
      ],
      "approach_blueprint": [
        "1. Apply pattern",
        "2. Optimize"
      ]
    },
    "strategyShift": "Optimal solution using Queue.",
    "naiveApproach": "Iterative approach checking all pairs/subsets.",
    "optimalApproach": "Optimal solution using Queue.",
    "simpleExplanation": "Simulating FIFO with two LIFO stacks.",
    "subPattern": "prefix_sum",
    "patternLevel": "foundation"
  },
  {
    "id": 49,
    "title": "Lowest Common Ancestor of a Binary Tree",
    "slug": "lowest-common-ancestor-of-a-binary-tree",
    "difficulty": "Medium",
    "algorithmType": "tree",
    "status": "new",
    "tags": [
      "Recursion"
    ],
    "primaryPattern": "tree_patterns",
    "shortPatternReason": "Recursive parent search with split logic.",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "problem_statement": "Standard LeetCode problem: Lowest Common Ancestor of a Binary Tree.",
    "constraints": [
      "N <= 10^5"
    ],
    "examples": [],
    "brute_force_explanation": "Iterative approach checking all pairs/subsets.",
    "optimal_explanation": "Optimal solution using Recursion.",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(n)",
      "space": "O(n)"
    },
    "patternSignals": [
      "Recursive parent search with split logic."
    ],
    "edgeCases": [
      "Small input",
      "Large values"
    ],
    "thinking_guide": {
      "first_principles": [
        "Understand the goal of Lowest Common Ancestor of a Binary Tree."
      ],
      "pattern_signals": [
        "Recursive parent search with split logic."
      ],
      "naive_approach": [
        "Brute force checking all possibilities."
      ],
      "approach_blueprint": [
        "1. Apply pattern",
        "2. Optimize"
      ]
    },
    "strategyShift": "Optimal solution using Recursion.",
    "naiveApproach": "Iterative approach checking all pairs/subsets.",
    "optimalApproach": "Optimal solution using Recursion.",
    "simpleExplanation": "Recursive parent search with split logic.",
    "subPattern": "postorder_accumulation",
    "patternLevel": "advanced_patterns"
  },
  {
    "id": 50,
    "title": "Product of Array Except Self",
    "slug": "product-of-array-except-self",
    "difficulty": "Medium",
    "algorithmType": "two_pointer",
    "status": "new",
    "tags": [
      "Prefix Sum"
    ],
    "primaryPattern": "two_pointer",
    "shortPatternReason": "Prefix and suffix product arrays.",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "problem_statement": "Standard LeetCode problem: Product of Array Except Self.",
    "constraints": [
      "N <= 10^5"
    ],
    "examples": [],
    "brute_force_explanation": "Iterative approach checking all pairs/subsets.",
    "optimal_explanation": "Optimal solution using Prefix Sum.",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(n)",
      "space": "O(1)"
    },
    "patternSignals": [
      "Prefix and suffix product arrays."
    ],
    "edgeCases": [
      "Small input",
      "Large values"
    ],
    "thinking_guide": {
      "first_principles": [
        "Understand the goal of Product of Array Except Self."
      ],
      "pattern_signals": [
        "Prefix and suffix product arrays."
      ],
      "naive_approach": [
        "Brute force checking all possibilities."
      ],
      "approach_blueprint": [
        "1. Apply pattern",
        "2. Optimize"
      ]
    },
    "strategyShift": "Optimal solution using Prefix Sum.",
    "naiveApproach": "Iterative approach checking all pairs/subsets.",
    "optimalApproach": "Optimal solution using Prefix Sum.",
    "simpleExplanation": "Prefix and suffix product arrays.",
    "subPattern": "same_direction",
    "patternLevel": "core_patterns"
  },
  {
    "id": 51,
    "title": "Sliding Window Maximum",
    "slug": "sliding-window-maximum",
    "difficulty": "Hard",
    "algorithmType": "sliding_window",
    "status": "new",
    "tags": [
      "Sliding Window"
    ],
    "primaryPattern": "sliding_window",
    "shortPatternReason": "Deque-based monotonic max tracking.",
    "time_complexity": "O(n)",
    "space_complexity": "O(k)",
    "problem_statement": "Standard LeetCode problem: Sliding Window Maximum.",
    "constraints": [
      "N <= 10^5"
    ],
    "examples": [],
    "brute_force_explanation": "Iterative approach checking all pairs/subsets.",
    "optimal_explanation": "Optimal solution using Sliding Window.",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(n)",
      "space": "O(k)"
    },
    "patternSignals": [
      "Deque-based monotonic max tracking."
    ],
    "edgeCases": [
      "Small input",
      "Large values"
    ],
    "thinking_guide": {
      "first_principles": [
        "Understand the goal of Sliding Window Maximum."
      ],
      "pattern_signals": [
        "Deque-based monotonic max tracking."
      ],
      "naive_approach": [
        "Brute force checking all possibilities."
      ],
      "approach_blueprint": [
        "1. Apply pattern",
        "2. Optimize"
      ]
    },
    "strategyShift": "Optimal solution using Sliding Window.",
    "naiveApproach": "Iterative approach checking all pairs/subsets.",
    "optimalApproach": "Optimal solution using Sliding Window.",
    "simpleExplanation": "Deque-based monotonic max tracking.",
    "subPattern": "fixed_window",
    "patternLevel": "core_patterns"
  },
  {
    "id": 52,
    "title": "Longest Increasing Subsequence",
    "slug": "longest-increasing-subsequence",
    "difficulty": "Medium",
    "algorithmType": "two_pointer",
    "status": "new",
    "tags": [
      "Dynamic Programming"
    ],
    "primaryPattern": "two_pointer",
    "shortPatternReason": "DP relation or patience sorting logic.",
    "time_complexity": "O(n log n)",
    "space_complexity": "O(n)",
    "problem_statement": "Standard LeetCode problem: Longest Increasing Subsequence.",
    "constraints": [
      "N <= 10^5"
    ],
    "examples": [],
    "brute_force_explanation": "Iterative approach checking all pairs/subsets.",
    "optimal_explanation": "Optimal solution using Dynamic Programming.",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(n log n)",
      "space": "O(n)"
    },
    "patternSignals": [
      "DP relation or patience sorting logic."
    ],
    "edgeCases": [
      "Small input",
      "Large values"
    ],
    "thinking_guide": {
      "first_principles": [
        "Understand the goal of Longest Increasing Subsequence."
      ],
      "pattern_signals": [
        "DP relation or patience sorting logic."
      ],
      "naive_approach": [
        "Brute force checking all possibilities."
      ],
      "approach_blueprint": [
        "1. Apply pattern",
        "2. Optimize"
      ]
    },
    "strategyShift": "Optimal solution using Dynamic Programming.",
    "naiveApproach": "Iterative approach checking all pairs/subsets.",
    "optimalApproach": "Optimal solution using Dynamic Programming.",
    "simpleExplanation": "DP relation or patience sorting logic.",
    "subPattern": "same_direction",
    "patternLevel": "core_patterns"
  },
  {
    "id": 53,
    "title": "Coin Change",
    "slug": "coin-change",
    "difficulty": "Medium",
    "algorithmType": "recursion",
    "status": "new",
    "tags": [
      "Dynamic Programming"
    ],
    "primaryPattern": "tree_patterns",
    "shortPatternReason": "Bottom-up min combination optimization.",
    "time_complexity": "O(S*n)",
    "space_complexity": "O(S)",
    "problem_statement": "Standard LeetCode problem: Coin Change.",
    "constraints": [
      "N <= 10^5"
    ],
    "examples": [],
    "brute_force_explanation": "Iterative approach checking all pairs/subsets.",
    "optimal_explanation": "Optimal solution using Dynamic Programming.",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(S*n)",
      "space": "O(S)"
    },
    "patternSignals": [
      "Bottom-up min combination optimization."
    ],
    "edgeCases": [
      "Small input",
      "Large values"
    ],
    "thinking_guide": {
      "first_principles": [
        "Understand the goal of Coin Change."
      ],
      "pattern_signals": [
        "Bottom-up min combination optimization."
      ],
      "naive_approach": [
        "Brute force checking all possibilities."
      ],
      "approach_blueprint": [
        "1. Apply pattern",
        "2. Optimize"
      ]
    },
    "strategyShift": "Optimal solution using Dynamic Programming.",
    "naiveApproach": "Iterative approach checking all pairs/subsets.",
    "optimalApproach": "Optimal solution using Dynamic Programming.",
    "simpleExplanation": "Bottom-up min combination optimization.",
    "subPattern": "postorder_accumulation",
    "patternLevel": "advanced_patterns"
  },
  {
    "id": 54,
    "title": "Top K Frequent Elements",
    "slug": "top-k-frequent-elements",
    "difficulty": "Medium",
    "algorithmType": "two_pointer",
    "status": "new",
    "tags": [
      "Heap / Priority Queue"
    ],
    "primaryPattern": "two_pointer",
    "shortPatternReason": "Frequency map + bucket sort or heap.",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "problem_statement": "Standard LeetCode problem: Top K Frequent Elements.",
    "constraints": [
      "N <= 10^5"
    ],
    "examples": [],
    "brute_force_explanation": "Iterative approach checking all pairs/subsets.",
    "optimal_explanation": "Optimal solution using Heap / Priority Queue.",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(n)",
      "space": "O(n)"
    },
    "patternSignals": [
      "Frequency map + bucket sort or heap."
    ],
    "edgeCases": [
      "Small input",
      "Large values"
    ],
    "thinking_guide": {
      "first_principles": [
        "Understand the goal of Top K Frequent Elements."
      ],
      "pattern_signals": [
        "Frequency map + bucket sort or heap."
      ],
      "naive_approach": [
        "Brute force checking all possibilities."
      ],
      "approach_blueprint": [
        "1. Apply pattern",
        "2. Optimize"
      ]
    },
    "strategyShift": "Optimal solution using Heap / Priority Queue.",
    "naiveApproach": "Iterative approach checking all pairs/subsets.",
    "optimalApproach": "Optimal solution using Heap / Priority Queue.",
    "simpleExplanation": "Frequency map + bucket sort or heap.",
    "subPattern": "same_direction",
    "patternLevel": "core_patterns"
  },
  {
    "id": 55,
    "title": "Decode String",
    "slug": "decode-string",
    "difficulty": "Medium",
    "algorithmType": "stack",
    "status": "new",
    "tags": [
      "Stack"
    ],
    "primaryPattern": "array_basics",
    "shortPatternReason": "Nested expansion using count/string stacks.",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "problem_statement": "Standard LeetCode problem: Decode String.",
    "constraints": [
      "N <= 10^5"
    ],
    "examples": [],
    "brute_force_explanation": "Iterative approach checking all pairs/subsets.",
    "optimal_explanation": "Optimal solution using Stack.",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(n)",
      "space": "O(n)"
    },
    "patternSignals": [
      "Nested expansion using count/string stacks."
    ],
    "edgeCases": [
      "Small input",
      "Large values"
    ],
    "thinking_guide": {
      "first_principles": [
        "Understand the goal of Decode String."
      ],
      "pattern_signals": [
        "Nested expansion using count/string stacks."
      ],
      "naive_approach": [
        "Brute force checking all possibilities."
      ],
      "approach_blueprint": [
        "1. Apply pattern",
        "2. Optimize"
      ]
    },
    "strategyShift": "Optimal solution using Stack.",
    "naiveApproach": "Iterative approach checking all pairs/subsets.",
    "optimalApproach": "Optimal solution using Stack.",
    "simpleExplanation": "Nested expansion using count/string stacks.",
    "subPattern": "prefix_sum",
    "patternLevel": "foundation"
  },
  {
    "id": 56,
    "title": "Partition Equal Subset Sum",
    "slug": "partition-equal-subset-sum",
    "difficulty": "Medium",
    "algorithmType": "recursion",
    "status": "new",
    "tags": [
      "Dynamic Programming"
    ],
    "primaryPattern": "tree_patterns",
    "shortPatternReason": "Subset sum variation (0/1 Knapsack).",
    "time_complexity": "O(n * target)",
    "space_complexity": "O(target)",
    "problem_statement": "Standard LeetCode problem: Partition Equal Subset Sum.",
    "constraints": [
      "N <= 10^5"
    ],
    "examples": [],
    "brute_force_explanation": "Iterative approach checking all pairs/subsets.",
    "optimal_explanation": "Optimal solution using Dynamic Programming.",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(n * target)",
      "space": "O(target)"
    },
    "patternSignals": [
      "Subset sum variation (0/1 Knapsack)."
    ],
    "edgeCases": [
      "Small input",
      "Large values"
    ],
    "thinking_guide": {
      "first_principles": [
        "Understand the goal of Partition Equal Subset Sum."
      ],
      "pattern_signals": [
        "Subset sum variation (0/1 Knapsack)."
      ],
      "naive_approach": [
        "Brute force checking all possibilities."
      ],
      "approach_blueprint": [
        "1. Apply pattern",
        "2. Optimize"
      ]
    },
    "strategyShift": "Optimal solution using Dynamic Programming.",
    "naiveApproach": "Iterative approach checking all pairs/subsets.",
    "optimalApproach": "Optimal solution using Dynamic Programming.",
    "simpleExplanation": "Subset sum variation (0/1 Knapsack).",
    "subPattern": "postorder_accumulation",
    "patternLevel": "advanced_patterns"
  },
  {
    "id": 57,
    "title": "Find All Anagrams in a String",
    "slug": "find-all-anagrams-in-a-string",
    "difficulty": "Medium",
    "algorithmType": "sliding_window",
    "status": "new",
    "tags": [
      "Sliding Window"
    ],
    "primaryPattern": "sliding_window",
    "shortPatternReason": "Fixed-size window frequency check.",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "problem_statement": "Standard LeetCode problem: Find All Anagrams in a String.",
    "constraints": [
      "N <= 10^5"
    ],
    "examples": [],
    "brute_force_explanation": "Iterative approach checking all pairs/subsets.",
    "optimal_explanation": "Optimal solution using Sliding Window.",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(n)",
      "space": "O(1)"
    },
    "patternSignals": [
      "Fixed-size window frequency check."
    ],
    "edgeCases": [
      "Small input",
      "Large values"
    ],
    "thinking_guide": {
      "first_principles": [
        "Understand the goal of Find All Anagrams in a String."
      ],
      "pattern_signals": [
        "Fixed-size window frequency check."
      ],
      "naive_approach": [
        "Brute force checking all possibilities."
      ],
      "approach_blueprint": [
        "1. Apply pattern",
        "2. Optimize"
      ]
    },
    "strategyShift": "Optimal solution using Sliding Window.",
    "naiveApproach": "Iterative approach checking all pairs/subsets.",
    "optimalApproach": "Optimal solution using Sliding Window.",
    "simpleExplanation": "Fixed-size window frequency check.",
    "subPattern": "variable_window",
    "patternLevel": "core_patterns"
  },
  {
    "id": 58,
    "title": "Diameter of Binary Tree",
    "slug": "diameter-of-binary-tree",
    "difficulty": "Easy",
    "algorithmType": "tree",
    "status": "new",
    "tags": [
      "Recursion"
    ],
    "primaryPattern": "tree_patterns",
    "shortPatternReason": "Recursive max path tracking through root.",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "problem_statement": "Standard LeetCode problem: Diameter of Binary Tree.",
    "constraints": [
      "N <= 10^5"
    ],
    "examples": [],
    "brute_force_explanation": "Iterative approach checking all pairs/subsets.",
    "optimal_explanation": "Optimal solution using Recursion.",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(n)",
      "space": "O(n)"
    },
    "patternSignals": [
      "Recursive max path tracking through root."
    ],
    "edgeCases": [
      "Small input",
      "Large values"
    ],
    "thinking_guide": {
      "first_principles": [
        "Understand the goal of Diameter of Binary Tree."
      ],
      "pattern_signals": [
        "Recursive max path tracking through root."
      ],
      "naive_approach": [
        "Brute force checking all possibilities."
      ],
      "approach_blueprint": [
        "1. Apply pattern",
        "2. Optimize"
      ]
    },
    "strategyShift": "Optimal solution using Recursion.",
    "naiveApproach": "Iterative approach checking all pairs/subsets.",
    "optimalApproach": "Optimal solution using Recursion.",
    "simpleExplanation": "Recursive max path tracking through root.",
    "subPattern": "postorder_accumulation",
    "patternLevel": "advanced_patterns"
  },
  {
    "id": 59,
    "title": "Subarray Sum Equals K",
    "slug": "subarray-sum-equals-k",
    "difficulty": "Medium",
    "algorithmType": "two_pointer",
    "status": "new",
    "tags": [
      "Prefix Sum"
    ],
    "primaryPattern": "two_pointer",
    "shortPatternReason": "Prefix sums + map of frequencies.",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "problem_statement": "Standard LeetCode problem: Subarray Sum Equals K.",
    "constraints": [
      "N <= 10^5"
    ],
    "examples": [],
    "brute_force_explanation": "Iterative approach checking all pairs/subsets.",
    "optimal_explanation": "Optimal solution using Prefix Sum.",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(n)",
      "space": "O(n)"
    },
    "patternSignals": [
      "Prefix sums + map of frequencies."
    ],
    "edgeCases": [
      "Small input",
      "Large values"
    ],
    "thinking_guide": {
      "first_principles": [
        "Understand the goal of Subarray Sum Equals K."
      ],
      "pattern_signals": [
        "Prefix sums + map of frequencies."
      ],
      "naive_approach": [
        "Brute force checking all possibilities."
      ],
      "approach_blueprint": [
        "1. Apply pattern",
        "2. Optimize"
      ]
    },
    "strategyShift": "Optimal solution using Prefix Sum.",
    "naiveApproach": "Iterative approach checking all pairs/subsets.",
    "optimalApproach": "Optimal solution using Prefix Sum.",
    "simpleExplanation": "Prefix sums + map of frequencies.",
    "subPattern": "same_direction",
    "patternLevel": "core_patterns"
  },
  {
    "id": 60,
    "title": "Binary Search",
    "slug": "binary-search",
    "difficulty": "Easy",
    "algorithmType": "binary_search",
    "status": "new",
    "tags": [
      "Binary Search"
    ],
    "primaryPattern": "binary_search",
    "shortPatternReason": "Standard logarithmic target lookup.",
    "time_complexity": "O(log n)",
    "space_complexity": "O(1)",
    "problem_statement": "Standard LeetCode problem: Binary Search.",
    "constraints": [
      "N <= 10^5"
    ],
    "examples": [],
    "brute_force_explanation": "Iterative approach checking all pairs/subsets.",
    "optimal_explanation": "Optimal solution using Binary Search.",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(log n)",
      "space": "O(1)"
    },
    "patternSignals": [
      "Standard logarithmic target lookup."
    ],
    "edgeCases": [
      "Small input",
      "Large values"
    ],
    "thinking_guide": {
      "first_principles": [
        "Understand the goal of Binary Search."
      ],
      "pattern_signals": [
        "Standard logarithmic target lookup."
      ],
      "naive_approach": [
        "Brute force checking all possibilities."
      ],
      "approach_blueprint": [
        "1. Apply pattern",
        "2. Optimize"
      ]
    },
    "strategyShift": "Optimal solution using Binary Search.",
    "naiveApproach": "Iterative approach checking all pairs/subsets.",
    "optimalApproach": "Optimal solution using Binary Search.",
    "simpleExplanation": "Standard logarithmic target lookup.",
    "subPattern": "classic",
    "patternLevel": "core_patterns"
  },
  {
    "id": 61,
    "title": "Daily Temperatures",
    "slug": "daily-temperatures",
    "difficulty": "Medium",
    "algorithmType": "stack",
    "status": "new",
    "tags": [
      "Stack"
    ],
    "primaryPattern": "array_basics",
    "shortPatternReason": "Monotonic stack for next-greater tracking.",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "problem_statement": "Standard LeetCode problem: Daily Temperatures.",
    "constraints": [
      "N <= 10^5"
    ],
    "examples": [],
    "brute_force_explanation": "Iterative approach checking all pairs/subsets.",
    "optimal_explanation": "Optimal solution using Stack.",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(n)",
      "space": "O(n)"
    },
    "patternSignals": [
      "Monotonic stack for next-greater tracking."
    ],
    "edgeCases": [
      "Small input",
      "Large values"
    ],
    "thinking_guide": {
      "first_principles": [
        "Understand the goal of Daily Temperatures."
      ],
      "pattern_signals": [
        "Monotonic stack for next-greater tracking."
      ],
      "naive_approach": [
        "Brute force checking all possibilities."
      ],
      "approach_blueprint": [
        "1. Apply pattern",
        "2. Optimize"
      ]
    },
    "strategyShift": "Optimal solution using Stack.",
    "naiveApproach": "Iterative approach checking all pairs/subsets.",
    "optimalApproach": "Optimal solution using Stack.",
    "simpleExplanation": "Monotonic stack for next-greater tracking.",
    "subPattern": "prefix_sum",
    "patternLevel": "foundation"
  },
  {
    "id": 62,
    "title": "Rotting Oranges",
    "slug": "rotting-oranges",
    "difficulty": "Medium",
    "algorithmType": "graph",
    "status": "new",
    "tags": [
      "Graph (BFS/DFS)"
    ],
    "primaryPattern": "graph_traversal",
    "shortPatternReason": "BFS for shortest time level-by-level decay.",
    "time_complexity": "O(m*n)",
    "space_complexity": "O(m*n)",
    "problem_statement": "Standard LeetCode problem: Rotting Oranges.",
    "constraints": [
      "N <= 10^5"
    ],
    "examples": [],
    "brute_force_explanation": "Iterative approach checking all pairs/subsets.",
    "optimal_explanation": "Optimal solution using Graph (BFS/DFS).",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(m*n)",
      "space": "O(m*n)"
    },
    "patternSignals": [
      "BFS for shortest time level-by-level decay."
    ],
    "edgeCases": [
      "Small input",
      "Large values"
    ],
    "thinking_guide": {
      "first_principles": [
        "Understand the goal of Rotting Oranges."
      ],
      "pattern_signals": [
        "BFS for shortest time level-by-level decay."
      ],
      "naive_approach": [
        "Brute force checking all possibilities."
      ],
      "approach_blueprint": [
        "1. Apply pattern",
        "2. Optimize"
      ]
    },
    "strategyShift": "Optimal solution using Graph (BFS/DFS).",
    "naiveApproach": "Iterative approach checking all pairs/subsets.",
    "optimalApproach": "Optimal solution using Graph (BFS/DFS).",
    "simpleExplanation": "BFS for shortest time level-by-level decay.",
    "subPattern": "bfs_level_order",
    "patternLevel": "advanced_patterns"
  },
  {
    "id": 63,
    "title": "Pattern Drill 63",
    "slug": "pattern-drill-63",
    "difficulty": "Easy",
    "algorithmType": "two_pointer",
    "status": "new",
    "tags": [
      "Stack"
    ],
    "primaryPattern": "two_pointer",
    "shortPatternReason": "Fundamental drill for Stack recognition.",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "problem_statement": "Practice your Stack skills with this scenario.",
    "constraints": [],
    "examples": [],
    "brute_force_explanation": "",
    "optimal_explanation": "",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(n)",
      "space": "O(1)"
    },
    "strategyShift": "",
    "naiveApproach": "",
    "optimalApproach": "",
    "simpleExplanation": "Fundamental drill for Stack recognition.",
    "patternSignals": [],
    "edgeCases": [],
    "subPattern": "same_direction",
    "patternLevel": "core_patterns"
  },
  {
    "id": 64,
    "title": "Pattern Drill 64",
    "slug": "pattern-drill-64",
    "difficulty": "Medium",
    "algorithmType": "two_pointer",
    "status": "new",
    "tags": [
      "Queue"
    ],
    "primaryPattern": "two_pointer",
    "shortPatternReason": "Fundamental drill for Queue recognition.",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "problem_statement": "Practice your Queue skills with this scenario.",
    "constraints": [],
    "examples": [],
    "brute_force_explanation": "",
    "optimal_explanation": "",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(n)",
      "space": "O(1)"
    },
    "strategyShift": "",
    "naiveApproach": "",
    "optimalApproach": "",
    "simpleExplanation": "Fundamental drill for Queue recognition.",
    "patternSignals": [],
    "edgeCases": [],
    "subPattern": "same_direction",
    "patternLevel": "core_patterns"
  },
  {
    "id": 65,
    "title": "Pattern Drill 65",
    "slug": "pattern-drill-65",
    "difficulty": "Easy",
    "algorithmType": "two_pointer",
    "status": "new",
    "tags": [
      "Linked List"
    ],
    "primaryPattern": "two_pointer",
    "shortPatternReason": "Fundamental drill for Linked List recognition.",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "problem_statement": "Practice your Linked List skills with this scenario.",
    "constraints": [],
    "examples": [],
    "brute_force_explanation": "",
    "optimal_explanation": "",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(n)",
      "space": "O(1)"
    },
    "strategyShift": "",
    "naiveApproach": "",
    "optimalApproach": "",
    "simpleExplanation": "Fundamental drill for Linked List recognition.",
    "patternSignals": [],
    "edgeCases": [],
    "subPattern": "same_direction",
    "patternLevel": "core_patterns"
  },
  {
    "id": 66,
    "title": "Pattern Drill 66",
    "slug": "pattern-drill-66",
    "difficulty": "Easy",
    "algorithmType": "two_pointer",
    "status": "new",
    "tags": [
      "Graph (BFS/DFS)"
    ],
    "primaryPattern": "two_pointer",
    "shortPatternReason": "Fundamental drill for Graph (BFS/DFS) recognition.",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "problem_statement": "Practice your Graph (BFS/DFS) skills with this scenario.",
    "constraints": [],
    "examples": [],
    "brute_force_explanation": "",
    "optimal_explanation": "",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(n)",
      "space": "O(1)"
    },
    "strategyShift": "",
    "naiveApproach": "",
    "optimalApproach": "",
    "simpleExplanation": "Fundamental drill for Graph (BFS/DFS) recognition.",
    "patternSignals": [],
    "edgeCases": [],
    "subPattern": "same_direction",
    "patternLevel": "core_patterns"
  },
  {
    "id": 67,
    "title": "Pattern Drill 67",
    "slug": "pattern-drill-67",
    "difficulty": "Medium",
    "algorithmType": "two_pointer",
    "status": "new",
    "tags": [
      "Heap / Priority Queue"
    ],
    "primaryPattern": "two_pointer",
    "shortPatternReason": "Fundamental drill for Heap / Priority Queue recognition.",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "problem_statement": "Practice your Heap / Priority Queue skills with this scenario.",
    "constraints": [],
    "examples": [],
    "brute_force_explanation": "",
    "optimal_explanation": "",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(n)",
      "space": "O(1)"
    },
    "strategyShift": "",
    "naiveApproach": "",
    "optimalApproach": "",
    "simpleExplanation": "Fundamental drill for Heap / Priority Queue recognition.",
    "patternSignals": [],
    "edgeCases": [],
    "subPattern": "same_direction",
    "patternLevel": "core_patterns"
  },
  {
    "id": 68,
    "title": "Pattern Drill 68",
    "slug": "pattern-drill-68",
    "difficulty": "Easy",
    "algorithmType": "two_pointer",
    "status": "new",
    "tags": [
      "Greedy"
    ],
    "primaryPattern": "two_pointer",
    "shortPatternReason": "Fundamental drill for Greedy recognition.",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "problem_statement": "Practice your Greedy skills with this scenario.",
    "constraints": [],
    "examples": [],
    "brute_force_explanation": "",
    "optimal_explanation": "",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(n)",
      "space": "O(1)"
    },
    "strategyShift": "",
    "naiveApproach": "",
    "optimalApproach": "",
    "simpleExplanation": "Fundamental drill for Greedy recognition.",
    "patternSignals": [],
    "edgeCases": [],
    "subPattern": "same_direction",
    "patternLevel": "core_patterns"
  },
  {
    "id": 69,
    "title": "Pattern Drill 69",
    "slug": "pattern-drill-69",
    "difficulty": "Easy",
    "algorithmType": "two_pointer",
    "status": "new",
    "tags": [
      "Prefix Sum"
    ],
    "primaryPattern": "two_pointer",
    "shortPatternReason": "Fundamental drill for Prefix Sum recognition.",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "problem_statement": "Practice your Prefix Sum skills with this scenario.",
    "constraints": [],
    "examples": [],
    "brute_force_explanation": "",
    "optimal_explanation": "",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(n)",
      "space": "O(1)"
    },
    "strategyShift": "",
    "naiveApproach": "",
    "optimalApproach": "",
    "simpleExplanation": "Fundamental drill for Prefix Sum recognition.",
    "patternSignals": [],
    "edgeCases": [],
    "subPattern": "same_direction",
    "patternLevel": "core_patterns"
  },
  {
    "id": 70,
    "title": "Pattern Drill 70",
    "slug": "pattern-drill-70",
    "difficulty": "Medium",
    "algorithmType": "two_pointer",
    "status": "new",
    "tags": [
      "Dynamic Programming"
    ],
    "primaryPattern": "two_pointer",
    "shortPatternReason": "Fundamental drill for Dynamic Programming recognition.",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "problem_statement": "Practice your Dynamic Programming skills with this scenario.",
    "constraints": [],
    "examples": [],
    "brute_force_explanation": "",
    "optimal_explanation": "",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(n)",
      "space": "O(1)"
    },
    "strategyShift": "",
    "naiveApproach": "",
    "optimalApproach": "",
    "simpleExplanation": "Fundamental drill for Dynamic Programming recognition.",
    "patternSignals": [],
    "edgeCases": [],
    "subPattern": "same_direction",
    "patternLevel": "core_patterns"
  },
  {
    "id": 71,
    "title": "Pattern Drill 71",
    "slug": "pattern-drill-71",
    "difficulty": "Easy",
    "algorithmType": "two_pointer",
    "status": "new",
    "tags": [
      "Array"
    ],
    "primaryPattern": "two_pointer",
    "shortPatternReason": "Fundamental drill for Array recognition.",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "problem_statement": "Practice your Array skills with this scenario.",
    "constraints": [],
    "examples": [],
    "brute_force_explanation": "",
    "optimal_explanation": "",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(n)",
      "space": "O(1)"
    },
    "strategyShift": "",
    "naiveApproach": "",
    "optimalApproach": "",
    "simpleExplanation": "Fundamental drill for Array recognition.",
    "patternSignals": [],
    "edgeCases": [],
    "subPattern": "same_direction",
    "patternLevel": "core_patterns"
  },
  {
    "id": 72,
    "title": "Pattern Drill 72",
    "slug": "pattern-drill-72",
    "difficulty": "Easy",
    "algorithmType": "two_pointer",
    "status": "new",
    "tags": [
      "Two Pointer"
    ],
    "primaryPattern": "two_pointer",
    "shortPatternReason": "Fundamental drill for Two Pointer recognition.",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "problem_statement": "Practice your Two Pointer skills with this scenario.",
    "constraints": [],
    "examples": [],
    "brute_force_explanation": "",
    "optimal_explanation": "",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(n)",
      "space": "O(1)"
    },
    "strategyShift": "",
    "naiveApproach": "",
    "optimalApproach": "",
    "simpleExplanation": "Fundamental drill for Two Pointer recognition.",
    "patternSignals": [],
    "edgeCases": [],
    "subPattern": "same_direction",
    "patternLevel": "core_patterns"
  },
  {
    "id": 73,
    "title": "Pattern Drill 73",
    "slug": "pattern-drill-73",
    "difficulty": "Medium",
    "algorithmType": "two_pointer",
    "status": "new",
    "tags": [
      "Sliding Window"
    ],
    "primaryPattern": "two_pointer",
    "shortPatternReason": "Fundamental drill for Sliding Window recognition.",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "problem_statement": "Practice your Sliding Window skills with this scenario.",
    "constraints": [],
    "examples": [],
    "brute_force_explanation": "",
    "optimal_explanation": "",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(n)",
      "space": "O(1)"
    },
    "strategyShift": "",
    "naiveApproach": "",
    "optimalApproach": "",
    "simpleExplanation": "Fundamental drill for Sliding Window recognition.",
    "patternSignals": [],
    "edgeCases": [],
    "subPattern": "same_direction",
    "patternLevel": "core_patterns"
  },
  {
    "id": 74,
    "title": "Pattern Drill 74",
    "slug": "pattern-drill-74",
    "difficulty": "Easy",
    "algorithmType": "two_pointer",
    "status": "new",
    "tags": [
      "Binary Search"
    ],
    "primaryPattern": "two_pointer",
    "shortPatternReason": "Fundamental drill for Binary Search recognition.",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "problem_statement": "Practice your Binary Search skills with this scenario.",
    "constraints": [],
    "examples": [],
    "brute_force_explanation": "",
    "optimal_explanation": "",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(n)",
      "space": "O(1)"
    },
    "strategyShift": "",
    "naiveApproach": "",
    "optimalApproach": "",
    "simpleExplanation": "Fundamental drill for Binary Search recognition.",
    "patternSignals": [],
    "edgeCases": [],
    "subPattern": "same_direction",
    "patternLevel": "core_patterns"
  },
  {
    "id": 75,
    "title": "Pattern Drill 75",
    "slug": "pattern-drill-75",
    "difficulty": "Easy",
    "algorithmType": "two_pointer",
    "status": "new",
    "tags": [
      "Recursion"
    ],
    "primaryPattern": "two_pointer",
    "shortPatternReason": "Fundamental drill for Recursion recognition.",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "problem_statement": "Practice your Recursion skills with this scenario.",
    "constraints": [],
    "examples": [],
    "brute_force_explanation": "",
    "optimal_explanation": "",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(n)",
      "space": "O(1)"
    },
    "strategyShift": "",
    "naiveApproach": "",
    "optimalApproach": "",
    "simpleExplanation": "Fundamental drill for Recursion recognition.",
    "patternSignals": [],
    "edgeCases": [],
    "subPattern": "same_direction",
    "patternLevel": "core_patterns"
  },
  {
    "id": 76,
    "title": "Pattern Drill 76",
    "slug": "pattern-drill-76",
    "difficulty": "Medium",
    "algorithmType": "two_pointer",
    "status": "new",
    "tags": [
      "Backtracking"
    ],
    "primaryPattern": "two_pointer",
    "shortPatternReason": "Fundamental drill for Backtracking recognition.",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "problem_statement": "Practice your Backtracking skills with this scenario.",
    "constraints": [],
    "examples": [],
    "brute_force_explanation": "",
    "optimal_explanation": "",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(n)",
      "space": "O(1)"
    },
    "strategyShift": "",
    "naiveApproach": "",
    "optimalApproach": "",
    "simpleExplanation": "Fundamental drill for Backtracking recognition.",
    "patternSignals": [],
    "edgeCases": [],
    "subPattern": "same_direction",
    "patternLevel": "core_patterns"
  },
  {
    "id": 77,
    "title": "Pattern Drill 77",
    "slug": "pattern-drill-77",
    "difficulty": "Easy",
    "algorithmType": "two_pointer",
    "status": "new",
    "tags": [
      "Stack"
    ],
    "primaryPattern": "two_pointer",
    "shortPatternReason": "Fundamental drill for Stack recognition.",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "problem_statement": "Practice your Stack skills with this scenario.",
    "constraints": [],
    "examples": [],
    "brute_force_explanation": "",
    "optimal_explanation": "",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(n)",
      "space": "O(1)"
    },
    "strategyShift": "",
    "naiveApproach": "",
    "optimalApproach": "",
    "simpleExplanation": "Fundamental drill for Stack recognition.",
    "patternSignals": [],
    "edgeCases": [],
    "subPattern": "same_direction",
    "patternLevel": "core_patterns"
  },
  {
    "id": 78,
    "title": "Pattern Drill 78",
    "slug": "pattern-drill-78",
    "difficulty": "Easy",
    "algorithmType": "two_pointer",
    "status": "new",
    "tags": [
      "Queue"
    ],
    "primaryPattern": "two_pointer",
    "shortPatternReason": "Fundamental drill for Queue recognition.",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "problem_statement": "Practice your Queue skills with this scenario.",
    "constraints": [],
    "examples": [],
    "brute_force_explanation": "",
    "optimal_explanation": "",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(n)",
      "space": "O(1)"
    },
    "strategyShift": "",
    "naiveApproach": "",
    "optimalApproach": "",
    "simpleExplanation": "Fundamental drill for Queue recognition.",
    "patternSignals": [],
    "edgeCases": [],
    "subPattern": "same_direction",
    "patternLevel": "core_patterns"
  },
  {
    "id": 79,
    "title": "Pattern Drill 79",
    "slug": "pattern-drill-79",
    "difficulty": "Medium",
    "algorithmType": "two_pointer",
    "status": "new",
    "tags": [
      "Linked List"
    ],
    "primaryPattern": "two_pointer",
    "shortPatternReason": "Fundamental drill for Linked List recognition.",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "problem_statement": "Practice your Linked List skills with this scenario.",
    "constraints": [],
    "examples": [],
    "brute_force_explanation": "",
    "optimal_explanation": "",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(n)",
      "space": "O(1)"
    },
    "strategyShift": "",
    "naiveApproach": "",
    "optimalApproach": "",
    "simpleExplanation": "Fundamental drill for Linked List recognition.",
    "patternSignals": [],
    "edgeCases": [],
    "subPattern": "same_direction",
    "patternLevel": "core_patterns"
  },
  {
    "id": 80,
    "title": "Pattern Drill 80",
    "slug": "pattern-drill-80",
    "difficulty": "Easy",
    "algorithmType": "two_pointer",
    "status": "new",
    "tags": [
      "Graph (BFS/DFS)"
    ],
    "primaryPattern": "two_pointer",
    "shortPatternReason": "Fundamental drill for Graph (BFS/DFS) recognition.",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "problem_statement": "Practice your Graph (BFS/DFS) skills with this scenario.",
    "constraints": [],
    "examples": [],
    "brute_force_explanation": "",
    "optimal_explanation": "",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(n)",
      "space": "O(1)"
    },
    "strategyShift": "",
    "naiveApproach": "",
    "optimalApproach": "",
    "simpleExplanation": "Fundamental drill for Graph (BFS/DFS) recognition.",
    "patternSignals": [],
    "edgeCases": [],
    "subPattern": "same_direction",
    "patternLevel": "core_patterns"
  },
  {
    "id": 81,
    "title": "Pattern Drill 81",
    "slug": "pattern-drill-81",
    "difficulty": "Easy",
    "algorithmType": "two_pointer",
    "status": "new",
    "tags": [
      "Heap / Priority Queue"
    ],
    "primaryPattern": "two_pointer",
    "shortPatternReason": "Fundamental drill for Heap / Priority Queue recognition.",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "problem_statement": "Practice your Heap / Priority Queue skills with this scenario.",
    "constraints": [],
    "examples": [],
    "brute_force_explanation": "",
    "optimal_explanation": "",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(n)",
      "space": "O(1)"
    },
    "strategyShift": "",
    "naiveApproach": "",
    "optimalApproach": "",
    "simpleExplanation": "Fundamental drill for Heap / Priority Queue recognition.",
    "patternSignals": [],
    "edgeCases": [],
    "subPattern": "same_direction",
    "patternLevel": "core_patterns"
  },
  {
    "id": 82,
    "title": "Pattern Drill 82",
    "slug": "pattern-drill-82",
    "difficulty": "Medium",
    "algorithmType": "two_pointer",
    "status": "new",
    "tags": [
      "Greedy"
    ],
    "primaryPattern": "two_pointer",
    "shortPatternReason": "Fundamental drill for Greedy recognition.",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "problem_statement": "Practice your Greedy skills with this scenario.",
    "constraints": [],
    "examples": [],
    "brute_force_explanation": "",
    "optimal_explanation": "",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(n)",
      "space": "O(1)"
    },
    "strategyShift": "",
    "naiveApproach": "",
    "optimalApproach": "",
    "simpleExplanation": "Fundamental drill for Greedy recognition.",
    "patternSignals": [],
    "edgeCases": [],
    "subPattern": "same_direction",
    "patternLevel": "core_patterns"
  },
  {
    "id": 83,
    "title": "Pattern Drill 83",
    "slug": "pattern-drill-83",
    "difficulty": "Easy",
    "algorithmType": "two_pointer",
    "status": "new",
    "tags": [
      "Prefix Sum"
    ],
    "primaryPattern": "two_pointer",
    "shortPatternReason": "Fundamental drill for Prefix Sum recognition.",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "problem_statement": "Practice your Prefix Sum skills with this scenario.",
    "constraints": [],
    "examples": [],
    "brute_force_explanation": "",
    "optimal_explanation": "",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(n)",
      "space": "O(1)"
    },
    "strategyShift": "",
    "naiveApproach": "",
    "optimalApproach": "",
    "simpleExplanation": "Fundamental drill for Prefix Sum recognition.",
    "patternSignals": [],
    "edgeCases": [],
    "subPattern": "same_direction",
    "patternLevel": "core_patterns"
  },
  {
    "id": 84,
    "title": "Pattern Drill 84",
    "slug": "pattern-drill-84",
    "difficulty": "Easy",
    "algorithmType": "two_pointer",
    "status": "new",
    "tags": [
      "Dynamic Programming"
    ],
    "primaryPattern": "two_pointer",
    "shortPatternReason": "Fundamental drill for Dynamic Programming recognition.",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "problem_statement": "Practice your Dynamic Programming skills with this scenario.",
    "constraints": [],
    "examples": [],
    "brute_force_explanation": "",
    "optimal_explanation": "",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(n)",
      "space": "O(1)"
    },
    "strategyShift": "",
    "naiveApproach": "",
    "optimalApproach": "",
    "simpleExplanation": "Fundamental drill for Dynamic Programming recognition.",
    "patternSignals": [],
    "edgeCases": [],
    "subPattern": "same_direction",
    "patternLevel": "core_patterns"
  },
  {
    "id": 85,
    "title": "Pattern Drill 85",
    "slug": "pattern-drill-85",
    "difficulty": "Medium",
    "algorithmType": "two_pointer",
    "status": "new",
    "tags": [
      "Array"
    ],
    "primaryPattern": "two_pointer",
    "shortPatternReason": "Fundamental drill for Array recognition.",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "problem_statement": "Practice your Array skills with this scenario.",
    "constraints": [],
    "examples": [],
    "brute_force_explanation": "",
    "optimal_explanation": "",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(n)",
      "space": "O(1)"
    },
    "strategyShift": "",
    "naiveApproach": "",
    "optimalApproach": "",
    "simpleExplanation": "Fundamental drill for Array recognition.",
    "patternSignals": [],
    "edgeCases": [],
    "subPattern": "same_direction",
    "patternLevel": "core_patterns"
  },
  {
    "id": 86,
    "title": "Pattern Drill 86",
    "slug": "pattern-drill-86",
    "difficulty": "Easy",
    "algorithmType": "two_pointer",
    "status": "new",
    "tags": [
      "Two Pointer"
    ],
    "primaryPattern": "two_pointer",
    "shortPatternReason": "Fundamental drill for Two Pointer recognition.",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "problem_statement": "Practice your Two Pointer skills with this scenario.",
    "constraints": [],
    "examples": [],
    "brute_force_explanation": "",
    "optimal_explanation": "",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(n)",
      "space": "O(1)"
    },
    "strategyShift": "",
    "naiveApproach": "",
    "optimalApproach": "",
    "simpleExplanation": "Fundamental drill for Two Pointer recognition.",
    "patternSignals": [],
    "edgeCases": [],
    "subPattern": "same_direction",
    "patternLevel": "core_patterns"
  },
  {
    "id": 87,
    "title": "Pattern Drill 87",
    "slug": "pattern-drill-87",
    "difficulty": "Easy",
    "algorithmType": "two_pointer",
    "status": "new",
    "tags": [
      "Sliding Window"
    ],
    "primaryPattern": "two_pointer",
    "shortPatternReason": "Fundamental drill for Sliding Window recognition.",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "problem_statement": "Practice your Sliding Window skills with this scenario.",
    "constraints": [],
    "examples": [],
    "brute_force_explanation": "",
    "optimal_explanation": "",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(n)",
      "space": "O(1)"
    },
    "strategyShift": "",
    "naiveApproach": "",
    "optimalApproach": "",
    "simpleExplanation": "Fundamental drill for Sliding Window recognition.",
    "patternSignals": [],
    "edgeCases": [],
    "subPattern": "same_direction",
    "patternLevel": "core_patterns"
  },
  {
    "id": 88,
    "title": "Pattern Drill 88",
    "slug": "pattern-drill-88",
    "difficulty": "Medium",
    "algorithmType": "two_pointer",
    "status": "new",
    "tags": [
      "Binary Search"
    ],
    "primaryPattern": "two_pointer",
    "shortPatternReason": "Fundamental drill for Binary Search recognition.",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "problem_statement": "Practice your Binary Search skills with this scenario.",
    "constraints": [],
    "examples": [],
    "brute_force_explanation": "",
    "optimal_explanation": "",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(n)",
      "space": "O(1)"
    },
    "strategyShift": "",
    "naiveApproach": "",
    "optimalApproach": "",
    "simpleExplanation": "Fundamental drill for Binary Search recognition.",
    "patternSignals": [],
    "edgeCases": [],
    "subPattern": "same_direction",
    "patternLevel": "core_patterns"
  },
  {
    "id": 89,
    "title": "Pattern Drill 89",
    "slug": "pattern-drill-89",
    "difficulty": "Easy",
    "algorithmType": "two_pointer",
    "status": "new",
    "tags": [
      "Recursion"
    ],
    "primaryPattern": "two_pointer",
    "shortPatternReason": "Fundamental drill for Recursion recognition.",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "problem_statement": "Practice your Recursion skills with this scenario.",
    "constraints": [],
    "examples": [],
    "brute_force_explanation": "",
    "optimal_explanation": "",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(n)",
      "space": "O(1)"
    },
    "strategyShift": "",
    "naiveApproach": "",
    "optimalApproach": "",
    "simpleExplanation": "Fundamental drill for Recursion recognition.",
    "patternSignals": [],
    "edgeCases": [],
    "subPattern": "same_direction",
    "patternLevel": "core_patterns"
  },
  {
    "id": 90,
    "title": "Pattern Drill 90",
    "slug": "pattern-drill-90",
    "difficulty": "Easy",
    "algorithmType": "two_pointer",
    "status": "new",
    "tags": [
      "Backtracking"
    ],
    "primaryPattern": "two_pointer",
    "shortPatternReason": "Fundamental drill for Backtracking recognition.",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "problem_statement": "Practice your Backtracking skills with this scenario.",
    "constraints": [],
    "examples": [],
    "brute_force_explanation": "",
    "optimal_explanation": "",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(n)",
      "space": "O(1)"
    },
    "strategyShift": "",
    "naiveApproach": "",
    "optimalApproach": "",
    "simpleExplanation": "Fundamental drill for Backtracking recognition.",
    "patternSignals": [],
    "edgeCases": [],
    "subPattern": "same_direction",
    "patternLevel": "core_patterns"
  },
  {
    "id": 91,
    "title": "Pattern Drill 91",
    "slug": "pattern-drill-91",
    "difficulty": "Medium",
    "algorithmType": "two_pointer",
    "status": "new",
    "tags": [
      "Stack"
    ],
    "primaryPattern": "two_pointer",
    "shortPatternReason": "Fundamental drill for Stack recognition.",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "problem_statement": "Practice your Stack skills with this scenario.",
    "constraints": [],
    "examples": [],
    "brute_force_explanation": "",
    "optimal_explanation": "",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(n)",
      "space": "O(1)"
    },
    "strategyShift": "",
    "naiveApproach": "",
    "optimalApproach": "",
    "simpleExplanation": "Fundamental drill for Stack recognition.",
    "patternSignals": [],
    "edgeCases": [],
    "subPattern": "same_direction",
    "patternLevel": "core_patterns"
  },
  {
    "id": 92,
    "title": "Pattern Drill 92",
    "slug": "pattern-drill-92",
    "difficulty": "Easy",
    "algorithmType": "two_pointer",
    "status": "new",
    "tags": [
      "Queue"
    ],
    "primaryPattern": "two_pointer",
    "shortPatternReason": "Fundamental drill for Queue recognition.",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "problem_statement": "Practice your Queue skills with this scenario.",
    "constraints": [],
    "examples": [],
    "brute_force_explanation": "",
    "optimal_explanation": "",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(n)",
      "space": "O(1)"
    },
    "strategyShift": "",
    "naiveApproach": "",
    "optimalApproach": "",
    "simpleExplanation": "Fundamental drill for Queue recognition.",
    "patternSignals": [],
    "edgeCases": [],
    "subPattern": "same_direction",
    "patternLevel": "core_patterns"
  },
  {
    "id": 93,
    "title": "Pattern Drill 93",
    "slug": "pattern-drill-93",
    "difficulty": "Easy",
    "algorithmType": "two_pointer",
    "status": "new",
    "tags": [
      "Linked List"
    ],
    "primaryPattern": "two_pointer",
    "shortPatternReason": "Fundamental drill for Linked List recognition.",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "problem_statement": "Practice your Linked List skills with this scenario.",
    "constraints": [],
    "examples": [],
    "brute_force_explanation": "",
    "optimal_explanation": "",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(n)",
      "space": "O(1)"
    },
    "strategyShift": "",
    "naiveApproach": "",
    "optimalApproach": "",
    "simpleExplanation": "Fundamental drill for Linked List recognition.",
    "patternSignals": [],
    "edgeCases": [],
    "subPattern": "same_direction",
    "patternLevel": "core_patterns"
  },
  {
    "id": 94,
    "title": "Pattern Drill 94",
    "slug": "pattern-drill-94",
    "difficulty": "Medium",
    "algorithmType": "two_pointer",
    "status": "new",
    "tags": [
      "Graph (BFS/DFS)"
    ],
    "primaryPattern": "two_pointer",
    "shortPatternReason": "Fundamental drill for Graph (BFS/DFS) recognition.",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "problem_statement": "Practice your Graph (BFS/DFS) skills with this scenario.",
    "constraints": [],
    "examples": [],
    "brute_force_explanation": "",
    "optimal_explanation": "",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(n)",
      "space": "O(1)"
    },
    "strategyShift": "",
    "naiveApproach": "",
    "optimalApproach": "",
    "simpleExplanation": "Fundamental drill for Graph (BFS/DFS) recognition.",
    "patternSignals": [],
    "edgeCases": [],
    "subPattern": "same_direction",
    "patternLevel": "core_patterns"
  },
  {
    "id": 95,
    "title": "Pattern Drill 95",
    "slug": "pattern-drill-95",
    "difficulty": "Easy",
    "algorithmType": "two_pointer",
    "status": "new",
    "tags": [
      "Heap / Priority Queue"
    ],
    "primaryPattern": "two_pointer",
    "shortPatternReason": "Fundamental drill for Heap / Priority Queue recognition.",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "problem_statement": "Practice your Heap / Priority Queue skills with this scenario.",
    "constraints": [],
    "examples": [],
    "brute_force_explanation": "",
    "optimal_explanation": "",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(n)",
      "space": "O(1)"
    },
    "strategyShift": "",
    "naiveApproach": "",
    "optimalApproach": "",
    "simpleExplanation": "Fundamental drill for Heap / Priority Queue recognition.",
    "patternSignals": [],
    "edgeCases": [],
    "subPattern": "same_direction",
    "patternLevel": "core_patterns"
  },
  {
    "id": 96,
    "title": "Pattern Drill 96",
    "slug": "pattern-drill-96",
    "difficulty": "Easy",
    "algorithmType": "two_pointer",
    "status": "new",
    "tags": [
      "Greedy"
    ],
    "primaryPattern": "two_pointer",
    "shortPatternReason": "Fundamental drill for Greedy recognition.",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "problem_statement": "Practice your Greedy skills with this scenario.",
    "constraints": [],
    "examples": [],
    "brute_force_explanation": "",
    "optimal_explanation": "",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(n)",
      "space": "O(1)"
    },
    "strategyShift": "",
    "naiveApproach": "",
    "optimalApproach": "",
    "simpleExplanation": "Fundamental drill for Greedy recognition.",
    "patternSignals": [],
    "edgeCases": [],
    "subPattern": "same_direction",
    "patternLevel": "core_patterns"
  },
  {
    "id": 97,
    "title": "Pattern Drill 97",
    "slug": "pattern-drill-97",
    "difficulty": "Medium",
    "algorithmType": "two_pointer",
    "status": "new",
    "tags": [
      "Prefix Sum"
    ],
    "primaryPattern": "two_pointer",
    "shortPatternReason": "Fundamental drill for Prefix Sum recognition.",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "problem_statement": "Practice your Prefix Sum skills with this scenario.",
    "constraints": [],
    "examples": [],
    "brute_force_explanation": "",
    "optimal_explanation": "",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(n)",
      "space": "O(1)"
    },
    "strategyShift": "",
    "naiveApproach": "",
    "optimalApproach": "",
    "simpleExplanation": "Fundamental drill for Prefix Sum recognition.",
    "patternSignals": [],
    "edgeCases": [],
    "subPattern": "same_direction",
    "patternLevel": "core_patterns"
  },
  {
    "id": 98,
    "title": "Pattern Drill 98",
    "slug": "pattern-drill-98",
    "difficulty": "Easy",
    "algorithmType": "two_pointer",
    "status": "new",
    "tags": [
      "Dynamic Programming"
    ],
    "primaryPattern": "two_pointer",
    "shortPatternReason": "Fundamental drill for Dynamic Programming recognition.",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "problem_statement": "Practice your Dynamic Programming skills with this scenario.",
    "constraints": [],
    "examples": [],
    "brute_force_explanation": "",
    "optimal_explanation": "",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(n)",
      "space": "O(1)"
    },
    "strategyShift": "",
    "naiveApproach": "",
    "optimalApproach": "",
    "simpleExplanation": "Fundamental drill for Dynamic Programming recognition.",
    "patternSignals": [],
    "edgeCases": [],
    "subPattern": "same_direction",
    "patternLevel": "core_patterns"
  },
  {
    "id": 99,
    "title": "Pattern Drill 99",
    "slug": "pattern-drill-99",
    "difficulty": "Easy",
    "algorithmType": "two_pointer",
    "status": "new",
    "tags": [
      "Array"
    ],
    "primaryPattern": "two_pointer",
    "shortPatternReason": "Fundamental drill for Array recognition.",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "problem_statement": "Practice your Array skills with this scenario.",
    "constraints": [],
    "examples": [],
    "brute_force_explanation": "",
    "optimal_explanation": "",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(n)",
      "space": "O(1)"
    },
    "strategyShift": "",
    "naiveApproach": "",
    "optimalApproach": "",
    "simpleExplanation": "Fundamental drill for Array recognition.",
    "patternSignals": [],
    "edgeCases": [],
    "subPattern": "same_direction",
    "patternLevel": "core_patterns"
  },
  {
    "id": 100,
    "title": "Pattern Drill 100",
    "slug": "pattern-drill-100",
    "difficulty": "Medium",
    "algorithmType": "two_pointer",
    "status": "new",
    "tags": [
      "Two Pointer"
    ],
    "primaryPattern": "two_pointer",
    "shortPatternReason": "Fundamental drill for Two Pointer recognition.",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "problem_statement": "Practice your Two Pointer skills with this scenario.",
    "constraints": [],
    "examples": [],
    "brute_force_explanation": "",
    "optimal_explanation": "",
    "brute_force_steps": [],
    "optimal_steps": [],
    "complexity": {
      "brute": "O(n\u00b2)",
      "optimal": "O(n)",
      "space": "O(1)"
    },
    "strategyShift": "",
    "naiveApproach": "",
    "optimalApproach": "",
    "simpleExplanation": "Fundamental drill for Two Pointer recognition.",
    "patternSignals": [],
    "edgeCases": [],
    "subPattern": "same_direction",
    "patternLevel": "core_patterns"
  },
  {
    "id": 101,
    "title": "Maximum Sum Subarray of Size K",
    "slug": "max-sum-subarray-size-k",
    "difficulty": "Easy",
    "algorithmType": "sliding_window",
    "status": "new",
    "tags": [
      "Array",
      "Sliding Window"
    ],
    "primaryPattern": "sliding_window",
    "subPattern": "fixed_window",
    "patternLevel": "core_patterns",
    "shortPatternReason": "Finding max sum in a fixed size window.",
    "problem_statement": "Given an array of integers and a number K, find the maximum sum of a subarray of size K.",
    "constraints": [
      "1 <= K <= N"
    ],
    "examples": [],
    "complexity": {
      "brute": "O(N*K)",
      "optimal": "O(N)",
      "space": "O(1)"
    },
    "pattern_capsule": {
      "invariant": "Window Size == K.",
      "trigger": "Max sum of size K.",
      "mistake": "Recomputing sum from scratch."
    },
    "thinking_guide": {
      "first_principles": [
        "Window slides one step at a time.",
        "Reuse sum: subtract left, add right."
      ],
      "pattern_signals": [
        "Fixed Size K",
        "Contiguous Subarray",
        "Max Sum"
      ],
      "naive_approach": [
        "Calculate sum for every K-sized subarray."
      ],
      "approach_blueprint": [
        "Init window sum.",
        "Slide: sum += arr[R] - arr[L]. Update max."
      ]
    },
    "brute_force_steps": [],
    "optimal_steps": []
  },
  {
    "id": 102,
    "title": "Average of Subarrays of Size K",
    "slug": "average-of-subarrays-size-k",
    "difficulty": "Easy",
    "algorithmType": "sliding_window",
    "status": "new",
    "tags": [
      "Array",
      "Sliding Window"
    ],
    "primaryPattern": "sliding_window",
    "subPattern": "fixed_window",
    "patternLevel": "core_patterns",
    "shortPatternReason": "Compute average for every fixed window.",
    "problem_statement": "Given an array, find the average of all contiguous subarrays of size K.",
    "constraints": [],
    "examples": [],
    "complexity": {
      "brute": "O(N*K)",
      "optimal": "O(N)",
      "space": "O(N)"
    },
    "pattern_capsule": {
      "invariant": "Window Size == K.",
      "trigger": "Average of size K.",
      "mistake": "Dividing by K inside the loop unnecessarily."
    },
    "thinking_guide": {
      "first_principles": [
        "Same as Max Sum, but divide by K."
      ],
      "pattern_signals": [
        "Fixed Size K",
        "Average"
      ],
      "naive_approach": [
        "Loop boundaries."
      ],
      "approach_blueprint": [
        "Maintain sum.",
        "Result[i] = sum / K."
      ]
    },
    "brute_force_steps": [],
    "optimal_steps": []
  },
  {
    "id": 103,
    "title": "Longest Repeating Character Replacement",
    "slug": "longest-repeating-character-replacement",
    "difficulty": "Medium",
    "algorithmType": "sliding_window",
    "status": "new",
    "tags": [
      "String",
      "Sliding Window"
    ],
    "primaryPattern": "sliding_window",
    "subPattern": "variable_window",
    "patternLevel": "core_patterns",
    "shortPatternReason": "Expand valid window, shrink when replacements > K.",
    "problem_statement": "You are given a string s and an integer k. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most k times. Return the length of the longest substring containing the same letter you can get after performing the above operations.",
    "constraints": [
      "s.length <= 10^5"
    ],
    "examples": [],
    "complexity": {
      "brute": "O(N^2)",
      "optimal": "O(N)",
      "space": "O(26)"
    },
    "pattern_capsule": {
      "invariant": "Window Length - MaxFrequency <= K",
      "trigger": "Longest substring with K changes.",
      "mistake": "Shrinking completely instead of just checking validity."
    },
    "thinking_guide": {
      "first_principles": [
        "Valid if (len - max_count) <= k."
      ],
      "pattern_signals": [
        "Longest Substring",
        "Replace K chars"
      ],
      "naive_approach": [
        "Check all substrings."
      ],
      "approach_blueprint": [
        "Expand R.",
        "Update specific char count.",
        "If (R-L+1) - maxFreq > k, shrink L."
      ]
    },
    "brute_force_steps": [],
    "optimal_steps": []
  },
  {
    "id": 104,
    "title": "Minimum Size Subarray Sum",
    "slug": "minimum-size-subarray-sum",
    "difficulty": "Medium",
    "algorithmType": "sliding_window",
    "status": "new",
    "tags": [
      "Array",
      "Sliding Window",
      "Binary Search"
    ],
    "primaryPattern": "sliding_window",
    "subPattern": "minimum_type",
    "patternLevel": "core_patterns",
    "shortPatternReason": "Shrink window to find minimum size.",
    "problem_statement": "Given an array of positive integers nums and a positive integer target, return the minimal length of a subarray whose sum is greater than or equal to target. If there is no such subarray, return 0 instead.",
    "constraints": [
      "nums[i] > 0"
    ],
    "examples": [],
    "complexity": {
      "brute": "O(N^2)",
      "optimal": "O(N)",
      "space": "O(1)"
    },
    "pattern_capsule": {
      "invariant": "While sum >= target, try to shrink.",
      "trigger": "Smallest subarray with sum >= S.",
      "mistake": "Not shrinking enough (using 'if' instead of 'while')."
    },
    "thinking_guide": {
      "first_principles": [
        "Window needs to be as small as possible while Sum >= Target."
      ],
      "pattern_signals": [
        "Smallest Subarray",
        "Sum >= Target"
      ],
      "naive_approach": [
        "O(N^2) sums."
      ],
      "approach_blueprint": [
        "Expand R adding to sum.",
        "While sum >= target: update MinLength, subtract arr[L], L++."
      ]
    },
    "brute_force_steps": [],
    "optimal_steps": []
  },
  {
    "id": 105,
    "title": "Subarrays with At Most K Distinct Integers",
    "slug": "subarrays-with-at-most-k-distinct-integers",
    "difficulty": "Medium",
    "algorithmType": "sliding_window",
    "status": "new",
    "tags": [
      "Array",
      "Sliding Window",
      "Counting"
    ],
    "primaryPattern": "sliding_window",
    "subPattern": "at_most_k",
    "patternLevel": "core_patterns",
    "shortPatternReason": "Count of subarrays ending at R with <= K distinct.",
    "problem_statement": "Given an integer array nums and an integer k, return the number of subarrays where the number of distinct integers is at most k.",
    "constraints": [],
    "examples": [],
    "complexity": {
      "brute": "O(N^2)",
      "optimal": "O(N)",
      "space": "O(N)"
    },
    "pattern_capsule": {
      "invariant": "Contrib = R - L + 1.",
      "trigger": "Count subarrays with at most K distinct.",
      "mistake": "Thinking this solves 'Exactly K' directly."
    },
    "thinking_guide": {
      "first_principles": [
        "If [L...R] has <= K distinct, then all subarrays ending at R starting from L to R are valid."
      ],
      "pattern_signals": [
        "Count subarrays",
        "At Most K Distinct"
      ],
      "naive_approach": [
        "Check all subarrays."
      ],
      "approach_blueprint": [
        "Expand R.",
        "If distinct > k, shrink L.",
        "Ans += R - L + 1."
      ]
    },
    "brute_force_steps": [],
    "optimal_steps": []
  },
  {
    "id": 106,
    "title": "Fruit Into Baskets",
    "slug": "fruit-into-baskets",
    "difficulty": "Medium",
    "algorithmType": "sliding_window",
    "status": "new",
    "tags": [
      "Array",
      "Sliding Window",
      "Hash Map"
    ],
    "primaryPattern": "sliding_window",
    "subPattern": "at_most_k",
    "patternLevel": "core_patterns",
    "shortPatternReason": "Max subarray with at most 2 distinct types.",
    "problem_statement": "Longest subarray with at most 2 distinct integers (types of fruit).",
    "constraints": [],
    "examples": [],
    "complexity": {
      "brute": "O(N^2)",
      "optimal": "O(N)",
      "space": "O(1)"
    },
    "pattern_capsule": {
      "invariant": "Distinct types <= 2.",
      "trigger": "Longest subarray with 2 types.",
      "mistake": "Complicating the '2 types' logic."
    },
    "thinking_guide": {
      "first_principles": [
        "Same as At Most K Distinct, but K=2 and we want Length, not Count."
      ],
      "pattern_signals": [
        "2 Baskets",
        "Types of Fruit"
      ],
      "naive_approach": [],
      "approach_blueprint": [
        "Standard At Most K logic with K=2.",
        "Track Max Length."
      ]
    },
    "brute_force_steps": [],
    "optimal_steps": []
  },
  {
    "id": 107,
    "title": "Subarrays with Exactly K Distinct Integers",
    "slug": "subarrays-with-exactly-k-distinct-integers",
    "difficulty": "Hard",
    "algorithmType": "sliding_window",
    "status": "new",
    "tags": [
      "Array",
      "Sliding Window",
      "Counting"
    ],
    "primaryPattern": "sliding_window",
    "subPattern": "exact_k",
    "patternLevel": "core_patterns",
    "shortPatternReason": "Composition of AtMost(K) - AtMost(K-1).",
    "problem_statement": "Given an integer array nums and an integer k, return the number of subarrays with exactly k distinct integers.",
    "constraints": [],
    "examples": [],
    "complexity": {
      "brute": "O(N^2)",
      "optimal": "O(N)",
      "space": "O(N)"
    },
    "pattern_capsule": {
      "invariant": "Exact(K) = AtMost(K) - AtMost(K-1).",
      "trigger": "Exactly K distinct.",
      "mistake": "Trying to solve directly with one window."
    },
    "thinking_guide": {
      "first_principles": [
        "It's hard to track 'exactly K' because shrinking can validly keep it at K or drop to K-1."
      ],
      "pattern_signals": [
        "Exactly K Distinct"
      ],
      "naive_approach": [],
      "approach_blueprint": [
        "Implement helper `atMost(k)`.",
        "Result = atMost(k) - atMost(k-1)."
      ]
    },
    "brute_force_steps": [],
    "optimal_steps": []
  },
  {
    "id": 108,
    "title": "Minimum Window Substring",
    "slug": "minimum-window-substring",
    "difficulty": "Hard",
    "algorithmType": "sliding_window",
    "status": "new",
    "tags": [
      "String",
      "Sliding Window",
      "Hash Table"
    ],
    "primaryPattern": "sliding_window",
    "subPattern": "minimum_type",
    "patternLevel": "core_patterns",
    "shortPatternReason": "Shrink window while covering all chars of T.",
    "problem_statement": "Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string \"\".",
    "constraints": [],
    "examples": [],
    "complexity": {
      "brute": "O(N^2)",
      "optimal": "O(N + M)",
      "space": "O(1)"
    },
    "pattern_capsule": {
      "invariant": "If window covers T, try to shrink.",
      "trigger": "Minimum window containing all characters.",
      "mistake": "Incorrectly counting checks."
    },
    "thinking_guide": {
      "first_principles": [
        "Need frequency map of T.",
        "Expand R.",
        "When window valid, Shrink L to minimize."
      ],
      "pattern_signals": [
        "Minimum Window",
        "Contain all characters"
      ],
      "naive_approach": [],
      "approach_blueprint": [
        "Frequency Map for T.",
        "Count 'matched' rule.",
        "Expand R.",
        "While matched == required, update Min, shrink L."
      ]
    },
    "brute_force_steps": [],
    "optimal_steps": []
  }
]