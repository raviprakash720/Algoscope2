[
  {
    "id": "data_structures",
    "title": "Data Structures",
    "description": "The atomic blocks of memory and logic.",
    "icon": "Database",
    "modules": [
      {
        "id": "arrays",
        "title": "Array",
        "family": "Data Structures",
        "difficulty": "Novice",
        "description": "Contiguous memory blocks for O(1) access.",
        "definition": "A collection of items stored at contiguous memory locations.",
        "hero": {
          "analogy": "The Contiguous Parking Lot",
          "analogyImage": "array_parking",
          "realWorldExample": "A street with numbered houses. You can go directly to house #5 without checking #1-#4.",
          "whenToUse": [
            "Random access by index",
            "Fixed-size collections",
            "Frequent iterations"
          ],
          "quickComplexity": [
            {
              "operation": "Access",
              "time": "O(1)",
              "space": "O(1)"
            },
            {
              "operation": "Search",
              "time": "O(N)",
              "space": "O(1)"
            },
            {
              "operation": "Insertion (End)",
              "time": "O(1)",
              "space": "O(1)"
            }
          ]
        },
        "whatProblemItSolves": "Solves the problem of organizing data that needs to be accessed quickly via a numerical position. It provides the foundation for most other data structures.",
        "memoryRepresentation": "Arrays occupy a single continuous block of RAM. If an array starts at address X, the element at index i is at address X + (i * size_of_element).",
        "internalWorking": "When an array is created, the system allocates a block of memory. Access is O(1) because the CPU calculates the address directly using the index. Resizing usually involves allocating a new, larger block and copying all elements.",
        "progression": {
          "fundamentals": {
            "title": "Level 1 \u2013 Fundamentals",
            "description": "Basic array operations and linear scans.",
            "concepts": [
              {
                "title": "Index Access",
                "explanation": "Directly fetching an element using its zero-based position."
              },
              {
                "title": "Linear Traversal",
                "explanation": "Visiting every element from index 0 to N-1."
              }
            ],
            "problems": [
              1,
              283
            ]
          },
          "patterns": {
            "title": "Level 2 \u2013 Pattern Usage",
            "description": "How arrays power advanced strategies.",
            "concepts": [
              {
                "title": "Two Pointers",
                "explanation": "Moving two indices towards each other or at different speeds."
              },
              {
                "title": "Sliding Window",
                "explanation": "Maintaining a range of elements that 'slides' through the array."
              }
            ],
            "problems": [
              53,
              121
            ]
          },
          "advanced": {
            "title": "Level 3 \u2013 Advanced Mode",
            "description": "Memory optimizations and amortized analysis.",
            "concepts": [
              {
                "title": "Dynamic Resizing",
                "explanation": "Understanding amortized O(1) for push operations in dynamic arrays."
              },
              {
                "title": "Cache Locality",
                "explanation": "How contiguous memory maximizes CPU cache hits."
              }
            ],
            "problems": [
              41,
              152
            ]
          }
        },
        "visualizerType": "array",
        "patternMapping": {
          "relatedPatterns": [
            {
              "id": "two_pointers",
              "label": "Two Pointers",
              "reason": "Requires constant time index access."
            },
            {
              "id": "sliding_window",
              "label": "Sliding Window",
              "reason": "Efficiently processes ranges."
            }
          ],
          "dependencyGraph": {
            "nodes": [
              {
                "id": "arrays",
                "label": "Arrays",
                "type": "root"
              },
              {
                "id": "two_pointers",
                "label": "Two Pointers",
                "type": "pattern"
              },
              {
                "id": "sliding_window",
                "label": "Sliding Window",
                "type": "pattern"
              },
              {
                "id": "prefix_sum",
                "label": "Prefix Sum",
                "type": "pattern"
              }
            ],
            "edges": [
              {
                "from": "arrays",
                "to": "two_pointers",
                "label": "O(1) Access"
              },
              {
                "from": "arrays",
                "to": "sliding_window",
                "label": "Contiguous Range"
              },
              {
                "from": "arrays",
                "to": "prefix_sum",
                "label": "Subarray Queries"
              }
            ]
          }
        },
        "comparisons": [
          {
            "targetId": "linked_lists",
            "title": "Array vs Linked List",
            "metrics": [
              {
                "label": "Access",
                "values": {
                  "Array": "O(1)",
                  "Linked List": "O(N)"
                }
              },
              {
                "label": "Insertion",
                "values": {
                  "Array": "O(N)",
                  "Linked List": "O(1)"
                }
              }
            ],
            "tradeoff": "Arrays are better for read-heavy apps, while Linked Lists excel at frequent insertions/deletions."
          }
        ],
        "interviewSim": {
          "commonMistakes": [
            {
              "title": "Off-by-one",
              "explanation": "Accessing index N in size N array.",
              "warning": "Indices are 0 to N-1."
            }
          ],
          "constraints": [
            "N < 10^5 (O(N) search OK)",
            "N < 10^8 (Requires O(log N))"
          ],
          "practiceProblems": [
            1,
            53
          ]
        },
        "deepDive": {
          "foundation": "Arrays are the most fundamental data structure. They represent a contiguous block of memory where each element is located at an offset from the start address. This deterministic nature is what allows for O(1) random access.",
          "engine": "Modern CPU architectures optimize for arrays using 'Spatial Locality'. When you access index 0, the CPU fetches more than just that one byte; it pulls a 'Cache Line' of surrounding data into the L1 cache, making sequential access lightning fast.",
          "storage": "Storage is purely linear. If an array starts at address 0x100 and stores 4-byte integers, index 5 is guaranteed to be at 0x100 + (5 * 4) = 0x114. No metadata is stored with individual elements, making it the most space-efficient structure.",
          "visualization": {
            "type": "memory_grid",
            "layers": [
              {
                "name": "Logical View",
                "description": "Numbered slots [0...N]"
              },
              {
                "name": "Physical View",
                "description": "Hexadecimal memory addresses"
              },
              {
                "name": "Hardware View",
                "description": "CPU Cache Line blocks"
              }
            ]
          }
        },
        "relatedProblems": [
          1,
          53,
          121,
          283
        ],
        "subPatterns": [
          {
            "id": "linear_scan",
            "title": "Linear Scan",
            "description": "Iterating through the array from start to end.",
            "signals": [
              "Find max/min",
              "Count occurrences",
              "Accumulate result"
            ],
            "invariant": "i increases from 0 to N-1",
            "formula": "for x in arr: process(x)",
            "mistakes": [
              "Off-by-one errors",
              "Modifying while iterating"
            ],
            "edgeCases": [
              {
                "title": "Empty Array",
                "description": "Loop body never executes.",
                "whyItBreaks": "Assumptions inside loop fail."
              }
            ],
            "exampleCode": "for i in range(len(arr)): print(arr[i])"
          },
          {
            "id": "two_pointers_array",
            "title": "Two Pointers",
            "description": "Using two indices to traverse relative to each other.",
            "signals": [
              "Sorted pair sum",
              "In-place reversal",
              "Partitioning elements"
            ],
            "invariant": "left < right",
            "formula": "while l < r: ...",
            "mistakes": [
              "Infinite loops",
              "Crossing pointers"
            ],
            "edgeCases": [
              {
                "title": "Single Element",
                "description": "Left == Right.",
                "whyItBreaks": "Swap logic might need check."
              }
            ],
            "exampleCode": "l, r = 0, len(arr)-1"
          },
          {
            "id": "prefix_sum_sub",
            "title": "Prefix Sum",
            "description": "Pre-calculating cumulative sums.",
            "signals": [
              "Subarray sum queries",
              "Range checks"
            ],
            "invariant": "P[i] = Sum(0...i-1)",
            "formula": "P[i] = P[i-1] + arr[i]",
            "mistakes": [
              "Index alignment (size N+1)",
              "Overflow"
            ],
            "edgeCases": [
              {
                "title": "Zero length",
                "description": "Result is [0]",
                "whyItBreaks": "N/A"
              }
            ],
            "exampleCode": "P = [0] * (N+1)"
          }
        ],
        "recognitionSignals": [
          "Index access needed",
          "Fixed size collection",
          "Contiguous data"
        ],
        "formulaPattern": "arr[i]",
        "commonMistakes": [
          "Index out of bounds",
          "Off-by-one errors",
          "Inefficient insertion/deletion in middle"
        ],
        "edgeCases": [
          "Empty array",
          "Index < 0",
          "Index >= length",
          "Null array"
        ],
        "templates": {
          "python": "# 1. Linear Scan\nfor x in arr:\n    print(x)\n\n# 2. Index Scan\nfor i in range(len(arr)):\n    val = arr[i]\n\n# 3. Two Pointers (Reverse)\nl, r = 0, len(arr)-1\nwhile l < r:\n    arr[l], arr[r] = arr[r], arr[l]\n    l += 1; r -= 1",
          "javascript": "// 1. Linear Scan\nfor (const x of arr) {\n    console.log(x);\n}\n\n// 2. Index Scan\nfor (let i = 0; i < arr.length; i++) {\n    const val = arr[i];\n}\n\n// 3. Two Pointers\nlet l = 0, r = arr.length - 1;\nwhile (l < r) {\n    [arr[l], arr[r]] = [arr[r], arr[l]];\n    l++; r--;\n}"
        },
        "microDrills": [
          {
            "question": "What is the time complexity to insert an element at the BEGINNING of an array of size N?",
            "options": [
              "O(1)",
              "O(log N)",
              "O(N)",
              "O(N^2)"
            ],
            "correctAnswer": "O(N)",
            "explanation": "Because all N elements must be shifted one position to the right to make space at index 0."
          },
          {
            "question": "Which operation is O(1) in a standard Array?",
            "options": [
              "Searching for a value",
              "Accessing by Index",
              "Deleting from middle",
              "Finding minimum"
            ],
            "correctAnswer": "Accessing by Index",
            "explanation": "Arrays provide direct memory access using the base address and index offset."
          },
          {
            "question": "What happens if you access index `N` in an array of size `N`?",
            "options": [
              "Returns last element",
              "Returns random garbage",
              "Index Out of Bounds Error",
              "Resizes array"
            ],
            "correctAnswer": "Index Out of Bounds Error",
            "explanation": "Valid indices are 0 to N-1. Index N is past the end of the allocated memory."
          }
        ],
        "recognitionChallenges": []
      },
      {
        "id": "strings",
        "title": "String",
        "family": "Data Structures",
        "difficulty": "Novice",
        "description": "Immutable sequences of characters.",
        "definition": "A sequence of characters, often immutable in many languages.",
        "hero": {
          "analogy": "The Immutable Necklace",
          "analogyImage": "string_necklace",
          "realWorldExample": "A printed book page. You can't change a letter; you must reprint the page to make edits.",
          "whenToUse": [
            "Text processing",
            "Search keywords",
            "Serialization (JSON/XML)"
          ],
          "quickComplexity": [
            {
              "operation": "Access",
              "time": "O(1)",
              "space": "O(1)"
            },
            {
              "operation": "Concatenation",
              "time": "O(N+M)",
              "space": "O(N+M)"
            },
            {
              "operation": "Substring",
              "time": "O(N)",
              "space": "O(N)"
            }
          ]
        },
        "whatProblemItSolves": "Allows representing and manipulating human-readable text. It handles the mapping between character symbols and numerical memory codes (ASCII/Unicode).",
        "memoryRepresentation": "Strings are typically stored as continuous arrays of bytes or words. Many languages store an extra 'Length' field or a null-terminator (\\0) to mark the end.",
        "internalWorking": "In languages like Python/Java, strings are immutable. Any 'modification' creates a completely new string in memory. 'String Interning' is often used to share memory for identical literals.",
        "progression": {
          "fundamentals": {
            "title": "Level 1 \u2013 Fundamentals",
            "description": "Text representation and basic indexing.",
            "concepts": [
              {
                "title": "Immutability",
                "explanation": "Why strings cannot be modified in-place in many languages."
              },
              {
                "title": "Encoding",
                "explanation": "How characters like 'A' become numbers like 65 (ASCII)."
              }
            ],
            "problems": [
              344,
              242
            ]
          },
          "patterns": {
            "title": "Level 2 \u2013 Pattern Usage",
            "description": "Advanced string manipulation algorithms.",
            "concepts": [
              {
                "title": "Sliding Window",
                "explanation": "Finding the longest substring with unique characters."
              },
              {
                "title": "Two Pointers",
                "explanation": "Checking for palindromes by comparing characters from both ends."
              }
            ],
            "problems": [
              3,
              125
            ]
          },
          "advanced": {
            "title": "Level 3 \u2013 Advanced Mode",
            "description": "Memory optimizations and prefix trees.",
            "concepts": [
              {
                "title": "String Building",
                "explanation": "Using O(N) buffers instead of O(N^2) concatenation."
              },
              {
                "title": "Trie Integration",
                "explanation": "How strings are stored as paths in prefix trees."
              }
            ],
            "problems": [
              14,
              208
            ]
          }
        },
        "visualizerType": "string",
        "patternMapping": {
          "relatedPatterns": [
            {
              "id": "sliding_window",
              "label": "Sliding Window",
              "reason": "Standard for substring problems."
            },
            {
              "id": "two_pointers",
              "label": "Two Pointers",
              "reason": "Used for reversals and palindrome checks."
            }
          ],
          "dependencyGraph": {
            "nodes": [
              {
                "id": "strings",
                "label": "Strings",
                "type": "root"
              },
              {
                "id": "two_pointers",
                "label": "Two Pointers",
                "type": "pattern"
              },
              {
                "id": "sliding_window",
                "label": "Sliding Window",
                "type": "pattern"
              }
            ],
            "edges": [
              {
                "from": "strings",
                "to": "two_pointers",
                "label": "Palindrome/Reverse"
              },
              {
                "from": "strings",
                "to": "sliding_window",
                "label": "Substring Search"
              }
            ]
          }
        },
        "comparisons": [
          {
            "targetId": "arrays",
            "title": "String vs Char Array",
            "metrics": [
              {
                "label": "Mutability",
                "values": {
                  "String": "No",
                  "Char Array": "Yes"
                }
              },
              {
                "label": "Memory",
                "values": {
                  "String": "Interned",
                  "Char Array": "Explicit"
                }
              }
            ],
            "tradeoff": "Strings offer safe, easier API, but Char Arrays are significantly faster for complex in-place edits."
          }
        ],
        "interviewSim": {
          "commonMistakes": [
            {
              "title": "Concatenation Loop",
              "explanation": "Using `S += char` in a loop (O(N^2)).",
              "warning": "Use a list/buffer and `.join()` instead."
            }
          ],
          "constraints": [
            "L < 10^5 (Linear scan OK)",
            "Unicode support (Check character width)"
          ],
          "practiceProblems": [
            3,
            242
          ]
        },
        "deepDive": {
          "foundation": "While arrays store bytes, strings store semantics. In many high-level languages, strings are 'Interned' objects\u2014identical string literals share the same memory location to save space.",
          "engine": "Strings often use COW (Copy-On-Write) optimization. If two variables point to the same string, they share memory until one is modified. At that moment, the system clones the string to preserve immutability.",
          "storage": "Internally, strings are often Byte Arrays (UTF-8) or Word Arrays (UTF-8). They usually include a hidden 'Length' prefix or a null-terminator (\\0) to mark the end, unlike raw arrays which rely on the programmer's bounds-checking.",
          "visualization": {
            "type": "character_chain",
            "layers": [
              {
                "name": "Encoding",
                "description": "ASCII/Unicode hex values"
              },
              {
                "name": "Pointer Map",
                "description": "References to the String Intern Pool"
              }
            ]
          }
        },
        "relatedProblems": [
          3,
          125,
          242,
          49
        ],
        "subPatterns": [
          {
            "id": "string_builder",
            "title": "StringBuilder Pattern",
            "description": "Constructing strings efficiently using an array/buffer.",
            "signals": [
              "Repeated concatenation",
              "Building result char by char"
            ],
            "invariant": "Buffer accumulates parts",
            "formula": "''.join(list)",
            "mistakes": [
              "Using += in a loop (O(N^2))"
            ],
            "edgeCases": [
              {
                "title": "Empty Result",
                "description": "Joining empty list.",
                "whyItBreaks": "Returns empty string ''."
              }
            ],
            "exampleCode": "res = []; res.append('a'); ''.join(res)"
          },
          {
            "id": "two_pointers_string",
            "title": "Two Pointers (String)",
            "description": "Checking palindromes or reversing string.",
            "signals": [
              "Palindrome check",
              "Reverse string"
            ],
            "invariant": "l < r",
            "formula": "s[l] == s[r]",
            "mistakes": [
              "Case sensitivity ignored"
            ],
            "edgeCases": [
              {
                "title": "Single char",
                "description": "Is palindrome.",
                "whyItBreaks": "Loop condition."
              }
            ],
            "exampleCode": "while l<r: if s[l]!=s[r]: return False"
          },
          {
            "id": "sliding_window_string",
            "title": "Sliding Window",
            "description": "Finding substrings with specific properties.",
            "signals": [
              "Longest substring w/o repeats",
              "Anagram search"
            ],
            "invariant": "Window validity",
            "formula": "expand right, shrink left",
            "mistakes": [
              "Not updating max length correctly"
            ],
            "edgeCases": [
              {
                "title": "No valid window",
                "description": "Return 0 or empty.",
                "whyItBreaks": "Logic."
              }
            ],
            "exampleCode": "For char in s: ..."
          }
        ],
        "recognitionSignals": [
          "Text processing",
          "Character manipulation",
          "Palindrome/Anagram",
          "Subsequence/Substring"
        ],
        "formulaPattern": "s[i...j]",
        "commonMistakes": [
          "Assuming mutability in immutable languages",
          "String concatenation in loops (O(n^2))",
          "ASCII vs Unicode confusion"
        ],
        "edgeCases": [
          "Empty string",
          "Single character",
          "Whitespace only",
          "Special characters"
        ],
        "templates": {
          "python": "# 1. Efficient Build\nres = []\nfor c in s:\n    if condition(c):\n        res.append(c)\nfinal_str = ''.join(res)\n\n# 2. Iterate chars\nfor i, c in enumerate(s):\n    print(i, c)",
          "javascript": "// 1. Efficient Build\nconst res = [];\nfor (const c of s) {\n    if (condition(c)) res.push(c);\n}\nconst finalStr = res.join('');\n\n// 2. Iterate\nfor (let i=0; i<s.length; i++) {\n    console.log(s[i]);\n}"
        },
        "microDrills": [
          {
            "question": "In Python/Java, what is the time complexity of `s += c` inside a loop running N times?",
            "options": [
              "O(N)",
              "O(N^2)",
              "O(1)",
              "O(log N)"
            ],
            "correctAnswer": "O(N^2)",
            "explanation": "Strings are immutable. `s += c` creates a NEW string copying all previous characters every iteration. 1+2+3+...+N = O(N^2)."
          },
          {
            "question": "Which data structure is best for checking if two strings are anagrams?",
            "options": [
              "Linked List",
              "Stack",
              "Hash Map / Frequency Array",
              "Queue"
            ],
            "correctAnswer": "Hash Map / Frequency Array",
            "explanation": "You count character frequencies in both strings and compare them."
          }
        ],
        "recognitionChallenges": []
      },
      {
        "id": "stacks",
        "title": "Stack",
        "family": "Data Structures",
        "difficulty": "Novice",
        "description": "LIFO linear structure.",
        "definition": "Last-In-First-Out data structure.",
        "hero": {
          "analogy": "The Cafeteria Tray Stack",
          "analogyImage": "stack_trays",
          "realWorldExample": "Browser Back Button history. You visit A -> B -> C. Clicking back goes C -> B -> A.",
          "whenToUse": [
            "Expression evaluation",
            "Undo/Redo logic",
            "Backtracking algorithms"
          ],
          "quickComplexity": [
            {
              "operation": "Push",
              "time": "O(1)",
              "space": "O(1)"
            },
            {
              "operation": "Pop",
              "time": "O(1)",
              "space": "O(1)"
            },
            {
              "operation": "Peek",
              "time": "O(1)",
              "space": "O(1)"
            }
          ]
        },
        "whatProblemItSolves": "Solves problems where you need to reverse history or maintain state in nested structures (like recursion).",
        "memoryRepresentation": "Usually implemented as an array where the 'Top' index only moves in one direction relative to the start.",
        "internalWorking": "Restrict access to exactly one end. This enforcement of LIFO ensures O(1) for all core operations.",
        "progression": {
          "fundamentals": {
            "title": "Level 1 \u2013 Fundamentals",
            "description": "Basic push/pop operations.",
            "concepts": [
              {
                "title": "LIFO Principle",
                "explanation": "Last-In-First-Out: The most recently added item is the first out."
              },
              {
                "title": "Stack Pointer",
                "explanation": "Tracking the index of the top element."
              }
            ],
            "problems": [
              20,
              155
            ]
          },
          "patterns": {
            "title": "Level 2 \u2013 Pattern Usage",
            "description": "Monotonicity and nested matching.",
            "concepts": [
              {
                "title": "Monotonic Stack",
                "explanation": "Keeping elements in increasing or decreasing order."
              },
              {
                "title": "Depth First Search",
                "explanation": "Using a stack to explore as deep as possible before backtracking."
              }
            ],
            "problems": [
              739,
              84
            ]
          },
          "advanced": {
            "title": "Level 3 \u2013 Advanced Mode",
            "description": "Memory optimizations and complex simulations.",
            "concepts": [
              {
                "title": "Call Stack Simulation",
                "explanation": "Implementing recursion iteratively."
              },
              {
                "title": "In-place Stack",
                "explanation": "Using existing array segments as stack space."
              }
            ],
            "problems": [
              394,
              71
            ]
          }
        },
        "visualizerType": "stack",
        "patternMapping": {
          "relatedPatterns": [
            {
              "id": "monotonic_stack",
              "label": "Monotonic Stack",
              "reason": "Standard for next-greater-element problems."
            },
            {
              "id": "dfs",
              "label": "DFS",
              "reason": "Stacks drive the recursion/iterative search."
            }
          ],
          "dependencyGraph": {
            "nodes": [
              {
                "id": "stacks",
                "label": "Stacks",
                "type": "root"
              },
              {
                "id": "monotonic_stack",
                "label": "Monotonic Stack",
                "type": "pattern"
              },
              {
                "id": "dfs",
                "label": "DFS",
                "type": "pattern"
              }
            ],
            "edges": [
              {
                "from": "stacks",
                "to": "monotonic_stack",
                "label": "Next Greater Item"
              },
              {
                "from": "stacks",
                "to": "dfs",
                "label": "Recursive Simulation"
              }
            ]
          }
        },
        "comparisons": [
          {
            "targetId": "queues",
            "title": "Stack vs Queue",
            "metrics": [
              {
                "label": "Order",
                "values": {
                  "Stack": "LIFO",
                  "Queue": "FIFO"
                }
              },
              {
                "label": "Search",
                "values": {
                  "Stack": "O(N)",
                  "Queue": "O(N)"
                }
              }
            ],
            "tradeoff": "Stacks reverse order, Queues preserve it."
          }
        ],
        "interviewSim": {
          "commonMistakes": [
            {
              "title": "Empty Pop",
              "explanation": "Trying to pop from an empty stack.",
              "warning": "Always check `if stack:` before popping."
            }
          ],
          "constraints": [
            "N < 10^5 (Linear scan OK)",
            "Stack space (Recursion limit)"
          ],
          "practiceProblems": [
            20,
            739
          ]
        },
        "deepDive": {
          "foundation": "Stacks are an abstract data type that enforces the LIFO (Last-In-First-Out) protocol. They are the backbone of recursion and expression evaluation in computing. Every function call in your code is managed by the system 'Call Stack'.",
          "engine": "The stack engine works by maintaining a 'Top' pointer. Unlike arrays where we access any index, a stack engine restricts visibility to exactly one element. This restriction is actually a performance feature\u2014it removes the need for search logic.",
          "storage": "Stacks are usually implemented as contiguous arrays with a dynamic size or as linked lists. However, 'Hardware Stacks' are fixed-size regions of memory where the Stack Pointer (SP) register decrements as you push data, moving 'downwards' in address space.",
          "visualization": {
            "type": "vertical_silo",
            "layers": [
              {
                "name": "Stack Pointer",
                "description": "The current memory address of the Top element"
              },
              {
                "name": "Frame Boundary",
                "description": "Separation between different function contexts"
              }
            ]
          }
        },
        "relatedProblems": [
          20,
          155,
          739
        ],
        "subPatterns": [
          {
            "id": "monotonic_stack",
            "title": "Monotonic Stack",
            "description": "Keeping elements in increasing/decreasing order.",
            "signals": [
              "Next Greater Element",
              "Histogram Area"
            ],
            "invariant": "Elements are sorted",
            "formula": "while stack and stack[-1] < curr: pop()",
            "mistakes": [
              "Wrong direction (< vs >)",
              "Not storing indices"
            ],
            "edgeCases": [
              {
                "title": "Dupes",
                "description": "Duplicate values.",
                "whyItBreaks": "Strict vs non-strict inequality."
              }
            ],
            "exampleCode": "stack = []\nfor x in arr:\n  while stack and stack[-1] < x: stack.pop()"
          },
          {
            "id": "parentheses_matching",
            "title": "Parentheses Matching",
            "description": "Validating nested structures.",
            "signals": [
              "Valid Parentheses",
              "Expression evaluation"
            ],
            "invariant": "Openers matched by Closers",
            "formula": "if opener push, if closer pop check",
            "mistakes": [
              "Empty stack on pop"
            ],
            "edgeCases": [
              {
                "title": "Unbalanced",
                "description": "))((",
                "whyItBreaks": "Stack empty or leftover."
              }
            ],
            "exampleCode": "stack.append('('); if stack[-1] == '(': stack.pop()"
          }
        ],
        "recognitionSignals": [
          "LIFO requirements",
          "Undo/Redo",
          "Matching brackets",
          "Depth-First Search",
          "Next Greater/Smaller Element"
        ],
        "formulaPattern": "stack.pop()",
        "commonMistakes": [
          "Popping from empty stack",
          "Confusing LIFO with FIFO",
          "Using stack when random access is needed"
        ],
        "edgeCases": [
          "Empty stack pop",
          "Stack overflow (recursion depth)",
          "Single element"
        ],
        "templates": {
          "python": "# Standard Stack\nstack = []\nstack.append(1)  # Push\nval = stack.pop() # Pop\ntop = stack[-1]   # Peek",
          "javascript": "// Standard Stack using Array\nconst stack = [];\nstack.push(1);  // Push\nconst val = stack.pop(); // Pop\nconst top = stack[stack.length - 1]; // Peek"
        },
        "microDrills": [
          {
            "question": "If you push 1, 2, 3 into a stack, what is the order they are popped?",
            "options": [
              "1, 2, 3",
              "3, 2, 1",
              "Random",
              "3, 1, 2"
            ],
            "correctAnswer": "3, 2, 1",
            "explanation": "LIFO: Last In (3) is First Out."
          },
          {
            "question": "Which problem is typically solved with a Stack?",
            "options": [
              "Printing tasks queue",
              "Valid Parentheses",
              "Shortest Path in Graph",
              "Sorting numbers"
            ],
            "correctAnswer": "Valid Parentheses",
            "explanation": "Nested structures require remembering the most recent open bracket to match with a closer."
          }
        ],
        "recognitionChallenges": []
      },
      {
        "id": "queues",
        "title": "Queue",
        "family": "Data Structures",
        "difficulty": "Novice",
        "description": "FIFO linear structure.",
        "definition": "First-In-First-Out data structure.",
        "hero": {
          "analogy": "The Ticket Line",
          "analogyImage": "queue_ticket",
          "realWorldExample": "Printer job queue. The first document sent is the first one printed.",
          "whenToUse": [
            "Scheduling tasks",
            "Breadth-First Search",
            "Asynchronous messaging"
          ],
          "quickComplexity": [
            {
              "operation": "Enqueue",
              "time": "O(1)",
              "space": "O(1)"
            },
            {
              "operation": "Dequeue",
              "time": "O(1)",
              "space": "O(1)"
            },
            {
              "operation": "Peek",
              "time": "O(1)",
              "space": "O(1)"
            }
          ]
        },
        "whatProblemItSolves": "Ensures fairness and maintains arrival order for processing.",
        "memoryRepresentation": "Often implemented as a 'Ring Buffer' in an array or as a Linked List with head and tail pointers.",
        "internalWorking": "Uses two markers: Front and Rear. When rear hits the array end, it wraps around to index 0.",
        "progression": {
          "fundamentals": {
            "title": "Level 1 \u2013 Fundamentals",
            "description": "Basic enqueue/dequeue operations.",
            "concepts": [
              {
                "title": "FIFO Principle",
                "explanation": "First-In-First-Out: The first item added is the first processed."
              },
              {
                "title": "Circular Buffer",
                "explanation": "Efficiency using modulo arithmetic to wrap pointers."
              }
            ],
            "problems": [
              933,
              622
            ]
          },
          "patterns": {
            "title": "Level 2 \u2013 Pattern Usage",
            "description": "Level-order traversals and buffering.",
            "concepts": [
              {
                "title": "BFS",
                "explanation": "Exploring all neighbors before moving to the next level."
              },
              {
                "title": "Sliding Window Maximum",
                "explanation": "Using a deque (Double-ended Queue) for range maximums."
              }
            ],
            "problems": [
              102,
              239
            ]
          },
          "advanced": {
            "title": "Level 3 \u2013 Advanced Mode",
            "description": "Distributed queues and lock-free concurrency.",
            "concepts": [
              {
                "title": "Monotonic Queue",
                "explanation": "Maintaining sorted order within the window."
              },
              {
                "title": "Priority Queue",
                "explanation": "Processing elements by importance, not just timing."
              }
            ],
            "problems": [
              862,
              1438
            ]
          }
        },
        "visualizerType": "queue",
        "patternMapping": {
          "relatedPatterns": [
            {
              "id": "bfs",
              "label": "BFS",
              "reason": "Queues power level-by-level exploration."
            },
            {
              "id": "sliding_window",
              "label": "Sliding Window",
              "reason": "Deques optimize range queries."
            }
          ],
          "dependencyGraph": {
            "nodes": [
              {
                "id": "queues",
                "label": "Queues",
                "type": "root"
              },
              {
                "id": "bfs",
                "label": "BFS",
                "type": "pattern"
              },
              {
                "id": "sliding_window_max",
                "label": "Sliding Window Max",
                "type": "pattern"
              }
            ],
            "edges": [
              {
                "from": "queues",
                "to": "bfs",
                "label": "Level-order Explore"
              },
              {
                "from": "queues",
                "to": "sliding_window_max",
                "label": "Deque (Monotonic)"
              }
            ]
          }
        },
        "comparisons": [
          {
            "targetId": "stacks",
            "title": "Queue vs Stack",
            "metrics": [
              {
                "label": "Traversal",
                "values": {
                  "Queue": "Horizontal (Level)",
                  "Stack": "Vertical (Depth)"
                }
              }
            ],
            "tradeoff": "Queue is for breadth, Stack is for depth."
          }
        ],
        "interviewSim": {
          "commonMistakes": [
            {
              "title": "Empty Dequeue",
              "explanation": "Dequeueing from an empty queue.",
              "warning": "Always check `if queue:` first."
            }
          ],
          "constraints": [
            "Time per operation < 10^-6s",
            "Memory < 256MB"
          ],
          "practiceProblems": [
            102,
            933
          ]
        },
        "deepDive": {
          "foundation": "Queues implement a 'First-Come-First-Served' logic (FIFO). They are essential for decoupling systems where data produced at one speed must be consumed at another (Producer-Consumer pattern).",
          "engine": "A high-performance queue engine often uses a 'Circular Buffer' (Ring Buffer). Instead of shifting elements (O(N)), the 'Head' and 'Tail' pointers simply wrap around the array using modulo arithmetic: `tail = (tail + 1) % size`.",
          "storage": "Storage consists of two boundary pointers. In distributed systems, queues are often persisted to disk (like Kafka or RabbitMQ) to ensure message durability even if the consumer crashes.",
          "visualization": {
            "type": "circular_track",
            "layers": [
              {
                "name": "Head/Tail Sync",
                "description": "How the start and end pointers chase each other"
              },
              {
                "name": "Buffer Capacity",
                "description": "The physical memory allocated vs utilized"
              }
            ]
          }
        },
        "relatedProblems": [],
        "subPatterns": [
          {
            "id": "bfs_pattern",
            "title": "Breadth-First Search",
            "description": "Level-by-level traversal.",
            "signals": [
              "Shortest path (unweighted)",
              "Level order traversal"
            ],
            "invariant": "Process all nodes at dist k before k+1",
            "formula": "q.append(start); while q: ...",
            "mistakes": [
              "Not marking visited (cycles)"
            ],
            "edgeCases": [
              {
                "title": "Disconnected Graph",
                "description": "Unreachable nodes.",
                "whyItBreaks": "Queue empty early."
              }
            ],
            "exampleCode": "q = deque([root])"
          }
        ],
        "recognitionSignals": [
          "FIFO requirements",
          "Order processing",
          "Breadth-First Search",
          "Buffering data"
        ],
        "formulaPattern": "queue.dequeue()",
        "commonMistakes": [
          "Dequeuing empty queue",
          "Confusing FIFO with LIFO",
          "Using Array.shift() in JS (O(N) cost)"
        ],
        "edgeCases": [
          "Empty queue dequeue",
          "Queue full (bounded)",
          "Single element"
        ],
        "templates": {
          "python": "from collections import deque\nq = deque()\nq.append(x) # Enqueue\nval = q.popleft() # Dequeue",
          "javascript": "// Use Array properly or Linked List\nconst q = [];\nq.push(x); // Enqueue\nconst val = q.shift(); // Dequeue (O(N)! Warn)"
        },
        "microDrills": [
          {
            "question": "What is the order of processing for a Queue containing [A, B, C] (A at front)?",
            "options": [
              "A, B, C",
              "C, B, A",
              "B, A, C",
              "Random"
            ],
            "correctAnswer": "A, B, C",
            "explanation": "FIFO: First In (A) is First Out."
          },
          {
            "question": "What is the time complexity of `shift()` on a standard JavaScript Array?",
            "options": [
              "O(1)",
              "O(N)",
              "O(log N)",
              "O(N^2)"
            ],
            "correctAnswer": "O(N)",
            "explanation": "Removing the first element requires shifting all remaining elements to the left by one index."
          }
        ],
        "recognitionChallenges": []
      },
      {
        "id": "hash_maps",
        "title": "Hash Map",
        "family": "Data Structures",
        "difficulty": "Adept",
        "description": "Key-value pairs with O(1) average access.",
        "definition": "A data structure that maps keys to values using a hash function.",
        "hero": {
          "analogy": "The Magic Locker System",
          "analogyImage": "hash_lockers",
          "realWorldExample": "Library Index Card. You look up 'Moby Dick' and it tells you 'Row 3, Shelf B'.",
          "whenToUse": [
            "Instant lookups",
            "Frequency counting",
            "Database indexing"
          ],
          "quickComplexity": [
            {
              "operation": "Insert",
              "time": "O(1)*",
              "space": "O(N)"
            },
            {
              "operation": "Search",
              "time": "O(1)*",
              "space": "O(N)"
            },
            {
              "operation": "Delete",
              "time": "O(1)*",
              "space": "O(N)"
            }
          ]
        },
        "whatProblemItSolves": "Bypasses the need for linear search. It provides a direct numerical lookup for any hashable key.",
        "memoryRepresentation": "An array of 'Buckets'. A hash function converts the key into a bucket index.",
        "internalWorking": "Uses a Hash Function (e.g., MurmurHash) for distribution. Resolves 'Collisions' via Chaining or Open Addressing.",
        "progression": {
          "fundamentals": {
            "title": "Level 1 \u2013 Fundamentals",
            "description": "Mapping keys to values.",
            "concepts": [
              {
                "title": "Hash Function",
                "explanation": "Turning a complex key into a simple index."
              },
              {
                "title": "Collision Handling",
                "explanation": "What happens when two keys want the same bucket."
              }
            ],
            "problems": [
              217,
              1
            ]
          },
          "patterns": {
            "title": "Level 2 \u2013 Pattern Usage",
            "description": "Counting frequencies and caching.",
            "concepts": [
              {
                "title": "Frequency Map",
                "explanation": "Storing the count of each element to solve anagrams or majority problems."
              },
              {
                "title": "Memoization",
                "explanation": "Caching expensive function results by their inputs."
              }
            ],
            "problems": [
              49,
              169
            ]
          },
          "advanced": {
            "title": "Level 3 \u2013 Advanced Mode",
            "description": "Amortized analysis and load factors.",
            "concepts": [
              {
                "title": "Rehashing",
                "explanation": "Resizing the internal array and redistribution when it gets too full."
              },
              {
                "title": "Custom Hashing",
                "explanation": "Designing functions for complex objects like Matrices or Curves."
              }
            ],
            "problems": [
              146,
              560
            ]
          }
        },
        "visualizerType": "hash_map",
        "patternMapping": {
          "relatedPatterns": [
            {
              "id": "frequency_counter",
              "label": "Frequency Counter",
              "reason": "Essential for counting-based challenges."
            },
            {
              "id": "optimization",
              "label": "Optimization",
              "reason": "Reduces O(N^2) problems to O(N)."
            }
          ],
          "dependencyGraph": {
            "nodes": [
              {
                "id": "hash_maps",
                "label": "Hash Maps",
                "type": "root"
              },
              {
                "id": "frequency_counter",
                "label": "Frequency Counter",
                "type": "pattern"
              },
              {
                "id": "lru_cache",
                "label": "LRU Cache",
                "type": "pattern"
              }
            ],
            "edges": [
              {
                "from": "hash_maps",
                "to": "frequency_counter",
                "label": "Key-based Count"
              },
              {
                "from": "hash_maps",
                "to": "lru_cache",
                "label": "O(1) Access"
              }
            ]
          }
        },
        "comparisons": [
          {
            "targetId": "sets",
            "title": "Hash Map vs Set",
            "metrics": [
              {
                "label": "Data",
                "values": {
                  "Map": "Key-Value",
                  "Set": "Key Only"
                }
              }
            ],
            "tradeoff": "Use Map when you need metadata, Set when you only need existence checking."
          }
        ],
        "interviewSim": {
          "commonMistakes": [
            {
              "title": "Mutable Keys",
              "explanation": "Using a list as a key in Python.",
              "warning": "Keys must be immutable (Hashable)."
            }
          ],
          "constraints": [
            "Load Factor < 0.75",
            "Collision resistance"
          ],
          "practiceProblems": [
            1,
            49
          ]
        },
        "deepDive": {
          "foundation": "Hash Maps trade space for time. By applying a mathematical 'Hash Function' to a key, we get a direct address, turning a needle-in-a-haystack search into a direct lookup.",
          "engine": "The engine consists of two parts: the Hash Function (like MurmurHash or SHA) and the Collision Resolver. When two keys hash to the same bucket, the engine uses 'Chaining' (Linked Lists inside buckets) or 'Open Addressing' (finding the next empty slot).",
          "storage": "Storage is a sparse array of 'Buckets'. A 'Load Factor' (usually 0.75) determines when the map is too crowded. At that point, the map 'Rehashes'\u2014it creates a double-sized array and moves every single key to a new location.",
          "visualization": {
            "type": "scattering_map",
            "layers": [
              {
                "name": "Hash Transformation",
                "description": "String/Int -> Index Number"
              },
              {
                "name": "Collision Buckets",
                "description": "How keys are stored when they 'clash'"
              }
            ]
          }
        },
        "relatedProblems": [
          1,
          49,
          217
        ],
        "subPatterns": [
          {
            "id": "frequency_counter",
            "title": "Frequency Counter",
            "description": "Counting occurrences of elements.",
            "signals": [
              "Find duplicates",
              "Anagrams",
              "Majority element"
            ],
            "invariant": "Map[item] = count",
            "formula": "map[x] = map.get(x, 0) + 1",
            "mistakes": [
              "Not handling first occurrence"
            ],
            "edgeCases": [
              {
                "title": "All unique",
                "description": "Map size N.",
                "whyItBreaks": "Memory usage."
              }
            ],
            "exampleCode": "counts = {}\nfor x in arr: counts[x] = counts.get(x, 0) + 1"
          },
          {
            "id": "lookup_table",
            "title": "Lookup Table",
            "description": "Caching results or checking existence.",
            "signals": [
              "Two Sum",
              "seen set",
              "Memoization"
            ],
            "invariant": "Key in map implies visited",
            "formula": "if target - x in map: found",
            "mistakes": [
              "Using mutable keys (list) as key"
            ],
            "edgeCases": [
              {
                "title": "Collision storm",
                "description": "Bad hash function.",
                "whyItBreaks": "Performance degrades to O(N)."
              }
            ],
            "exampleCode": "seen = set()\nif x in seen: return True"
          }
        ],
        "recognitionSignals": [
          "Fast lookups needed",
          "Counting frequencies",
          "Finding duplicates",
          "Mapping relationships"
        ],
        "formulaPattern": "map.get(key)",
        "commonMistakes": [
          "Ignoring collisions (in theory)",
          "Using mutable keys (Python list as key error)",
          "Order confusion (Insertion order vs Random)"
        ],
        "edgeCases": [
          "Hash collisions (Same bucket)",
          "Load factor resizing (Lag)",
          "All keys hash to same value (DoS)"
        ],
        "templates": {
          "python": "m = {}\nm[key] = val\nif key in m:\n    print(m[key])",
          "javascript": "const m = new Map();\nm.set(key, val);\nif (m.has(key)) {\n    console.log(m.get(key));\n}"
        },
        "microDrills": [
          {
            "question": "What is the WORST case time complexity for a Hash Map lookup?",
            "options": [
              "O(1)",
              "O(log N)",
              "O(N)",
              "O(N^2)"
            ],
            "correctAnswer": "O(N)",
            "explanation": "If all keys collide and hash to the same bucket, it degrades to a linked list traversal."
          },
          {
            "question": "Can you use a List as a key in a Python dictionary?",
            "options": [
              "Yes",
              "No",
              "Only if list is empty",
              "Only if list is sorted"
            ],
            "correctAnswer": "No",
            "explanation": "Keys must be immutable (hashable). Lists are mutable."
          }
        ],
        "recognitionChallenges": []
      },
      {
        "id": "linked_lists",
        "title": "Linked List",
        "family": "Data Structures",
        "difficulty": "Novice",
        "description": "Nodes coupled by pointers.",
        "definition": "A linear collection of data elements whose order is not given by their physical placement in memory.",
        "hero": {
          "analogy": "The Treasure Hunt / Scavenger Hunt",
          "analogyImage": "linked_list_hunt",
          "realWorldExample": "A train where each car is hooked to the next. To get to the last car, you must walk through all others.",
          "whenToUse": [
            "Dynamic memory allocation",
            "Frequent insertions at head/tail",
            "Implementing stacks/queues"
          ],
          "quickComplexity": [
            {
              "operation": "Access",
              "time": "O(N)",
              "space": "O(1)"
            },
            {
              "operation": "Insertion",
              "time": "O(1)",
              "space": "O(1)"
            },
            {
              "operation": "Deletion",
              "time": "O(1)",
              "space": "O(1)"
            }
          ]
        },
        "whatProblemItSolves": "Solves the 'Contiguous Memory' limitation. It allows storing data across scattered memory locations, linked only by pointers.",
        "memoryRepresentation": "Each node is a structure containing data and a memory address (pointer) to the next node. Nodes can be far apart in RAM.",
        "internalWorking": "Traversing requires 'Pointer Chasing'\u2014reading one address to find the next. Operations like insertion simply involve changing point-to targets.",
        "progression": {
          "fundamentals": {
            "title": "Level 1 \u2013 Fundamentals",
            "description": "Basic node traversal and head manipulation.",
            "concepts": [
              {
                "title": "Node Structure",
                "explanation": "Understanding [Data | Next] as a dual-part memory unit."
              },
              {
                "title": "Sequential Access",
                "explanation": "Why you cannot jump to index i without visiting 0...i-1."
              }
            ],
            "problems": [
              206,
              21
            ]
          },
          "patterns": {
            "title": "Level 2 \u2013 Pattern Usage",
            "description": "Pointer-based logic and cycle detection.",
            "concepts": [
              {
                "title": "Fast & Slow Pointers",
                "explanation": "Using different speeds to find midpoints or detect cycles (Floyd's)."
              },
              {
                "title": "Sentinel Nodes",
                "explanation": "Using a 'Dummy' head to simplify edge cases at the start of the list."
              }
            ],
            "problems": [
              141,
              19
            ]
          },
          "advanced": {
            "title": "Level 3 \u2013 Advanced Mode",
            "description": "Complex reconstructions and in-place sorting.",
            "concepts": [
              {
                "title": "Recursive Reversal",
                "explanation": "Thinking of a reversed list as a functional transformation."
              },
              {
                "title": "Copy List with Random Pointer",
                "explanation": "Handling deep clones in graphs-disguised-as-lists."
              }
            ],
            "problems": [
              138,
              25
            ]
          }
        },
        "visualizerType": "linked_list",
        "patternMapping": {
          "relatedPatterns": [
            {
              "id": "fast_slow",
              "label": "Fast & Slow",
              "reason": "Standard for midpoint and cycle detection."
            },
            {
              "id": "sentinel",
              "label": "Sentinel Node",
              "reason": "Reduces conditional branching in deletions."
            }
          ],
          "dependencyGraph": {
            "nodes": [
              {
                "id": "linked_lists",
                "label": "Linked Lists",
                "type": "root"
              },
              {
                "id": "fast_slow",
                "label": "Fast & Slow Pointers",
                "type": "pattern"
              },
              {
                "id": "reverse_nodes",
                "label": "Reverse Nodes",
                "type": "pattern"
              }
            ],
            "edges": [
              {
                "from": "linked_lists",
                "to": "fast_slow",
                "label": "Cycle/Midpoint"
              },
              {
                "from": "linked_lists",
                "to": "reverse_nodes",
                "label": "Pointer Reassignment"
              }
            ]
          }
        },
        "comparisons": [
          {
            "targetId": "arrays",
            "title": "Linked List vs Array",
            "metrics": [
              {
                "label": "Search",
                "values": {
                  "List": "O(N)",
                  "Array": "O(N)"
                }
              },
              {
                "label": "Access",
                "values": {
                  "List": "O(N)",
                  "Array": "O(1)"
                }
              },
              {
                "label": "Space",
                "values": {
                  "List": "Data + Pointer",
                  "Array": "Data Only"
                }
              }
            ],
            "tradeoff": "Lists are better for dynamic growth, Arrays are better for random access speed."
          }
        ],
        "interviewSim": {
          "commonMistakes": [
            {
              "title": "Losing the Head",
              "explanation": "Modifying the head pointer directly and losing the list reference.",
              "warning": "Use a `curr = head` temporary variable."
            }
          ],
          "constraints": [
            "Pointer size (8 bytes)",
            "Null safety"
          ],
          "practiceProblems": [
            206,
            141
          ]
        },
        "deepDive": {
          "foundation": "Linked Lists solve the 'Contiguous Memory Problem'. Instead of demanding one giant block of RAM, they scatter data across different addresses, stitched together by pointers.",
          "engine": "The list engine is a 'Pointer Chaser'. It doesn't use math to find addresses; it dereferences memory. This makes it highly flexible for dynamic growth but 'Cache Unfriendly'\u2014the CPU often has to wait for RAM to fetch scattered nodes.",
          "storage": "Each node is a composite structure: `[Data | NextPointer]`. In a 64-bit system, the pointer alone takes 8 bytes. This means a linked list of characters uses significantly more memory than a string, but it allows O(1) insertion without moving thousands of other elements.",
          "visualization": {
            "type": "pointer_web",
            "layers": [
              {
                "name": "Node Anatomy",
                "description": "Data value vs Memory Address reference"
              },
              {
                "name": "Dereferencing",
                "description": "The jump from one RAM address to another"
              }
            ]
          }
        },
        "relatedProblems": [
          2,
          21,
          206,
          141
        ],
        "subPatterns": [
          {
            "id": "fast_slow",
            "title": "Fast & Slow Pointers",
            "description": "Two pointers moving at different speeds.",
            "signals": [
              "Cycle detection",
              "Middle of list"
            ],
            "invariant": "Fast is 2x steps ahead",
            "formula": "slow = slow.next; fast = fast.next.next",
            "mistakes": [
              "Null pointer checks on fast.next"
            ],
            "edgeCases": [
              {
                "title": "No Cycle",
                "description": "Fast reaches end.",
                "whyItBreaks": "End condition."
              }
            ],
            "exampleCode": "while fast and fast.next: ..."
          },
          {
            "id": "dummy_node",
            "title": "Dummy/Sentinel Node",
            "description": "Simplifying head operations.",
            "signals": [
              "Merge lists",
              "Delete node (might be head)"
            ],
            "invariant": "ans.next is real head",
            "formula": "dummy = Node(0); curr = dummy",
            "mistakes": [
              "Returning dummy instead of dummy.next"
            ],
            "edgeCases": [
              {
                "title": "Empty Output",
                "description": "dummy.next is None.",
                "whyItBreaks": "N/A"
              }
            ],
            "exampleCode": "dummy = ListNode(0); tail = dummy"
          },
          {
            "id": "list_reversal",
            "title": "List Reversal",
            "description": "Reversing pointers in place.",
            "signals": [
              "Reverse list",
              "Palindrome check"
            ],
            "invariant": "Next becomes Prev",
            "formula": "nxt = curr.next; curr.next = prev",
            "mistakes": [
              "Losing reference to rest of list"
            ],
            "edgeCases": [
              {
                "title": "Single/Empty",
                "description": "Already reversed.",
                "whyItBreaks": "N/A"
              }
            ],
            "exampleCode": "prev = None; while curr: ..."
          }
        ],
        "recognitionSignals": [
          "Dynamic size needed",
          "Frequent insertions/deletions at ends",
          "No random access required"
        ],
        "formulaPattern": "curr = curr.next",
        "commonMistakes": [
          "Lost reference (memory leak)",
          "Null pointer exception (fast.next.next)",
          "Cycle creation (infinite loop)"
        ],
        "edgeCases": [
          "Empty list",
          "Single node",
          "Cycle presence"
        ],
        "templates": {
          "python": "class Node:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n# Traverse\ncurr = head\nwhile curr:\n    curr = curr.next",
          "javascript": "class Node {\n    constructor(val = 0, next = null) {\n        this.val = val;\n        this.next = next;\n    }\n}\n// Traverse\nlet curr = head;\nwhile (curr) curr = curr.next;"
        },
        "microDrills": [
          {
            "question": "What is the time complexity to access the Kth element in a Singly Linked List?",
            "options": [
              "O(1)",
              "O(K) / O(N)",
              "O(log K)",
              "O(K^2)"
            ],
            "correctAnswer": "O(K) / O(N)",
            "explanation": "You must traverse from the head, following `next` pointers K times."
          },
          {
            "question": "Why use a Dummy Node?",
            "options": [
              "Faster access",
              "Simplify edge cases at Head",
              "Reduce memory usage",
              "Required by generic libraries"
            ],
            "correctAnswer": "Simplify edge cases at Head",
            "explanation": "It avoids conditional logic for insert/delete when operating on the first node."
          }
        ],
        "recognitionChallenges": []
      },
      {
        "id": "heaps",
        "title": "Heap / Priority Queue",
        "family": "Data Structures",
        "difficulty": "Adept",
        "description": "Tree-based structure for efficient max/min access.",
        "definition": "A specialized tree-based data structure which is essentially an almost complete tree that satisfies the heap property.",
        "hero": {
          "analogy": "The Corporate Ladder / Emergency Room",
          "analogyImage": "heap_ladder",
          "realWorldExample": "Emergency Room triage. Patients are handled by severity, not strictly by their time of arrival.",
          "whenToUse": [
            "Finding Kth largest element",
            "Task scheduling",
            "Merging sorted streams"
          ],
          "quickComplexity": [
            {
              "operation": "Peek Max/Min",
              "time": "O(1)",
              "space": "O(1)"
            },
            {
              "operation": "Insert",
              "time": "O(log N)",
              "space": "O(1)"
            },
            {
              "operation": "Pop",
              "time": "O(log N)",
              "space": "O(1)"
            }
          ]
        },
        "whatProblemItSolves": "Avoids the cost of sorting an entire array when you only need to repeatedly find the 'best' (max or min) element.",
        "memoryRepresentation": "Stored as a flat array where a parent at index `i` has children at `2i + 1` and `2i + 2`.",
        "internalWorking": "Semi-Sorted. Maintains a specific order where every parent is superior to its children. Uses 'Bubbling' to maintain this property after updates.",
        "progression": {
          "fundamentals": {
            "title": "Level 1 \u2013 Fundamentals",
            "description": "Heap property and array mapping.",
            "concepts": [
              {
                "title": "Complete Tree",
                "explanation": "Why heaps are filled level-by-level from left to right."
              },
              {
                "title": "Heapify",
                "explanation": "Converting an unsorted array into a heap in O(N) time."
              }
            ],
            "problems": [
              215,
              703
            ]
          },
          "patterns": {
            "title": "Level 2 \u2013 Pattern Usage",
            "description": "Priority-based processing.",
            "concepts": [
              {
                "title": "Top K",
                "explanation": "Using a heap of size K to find the largest or smallest K elements."
              },
              {
                "title": "Merge Sorted",
                "explanation": "Using a heap to efficiently pick the next element from multiple sorted lists."
              }
            ],
            "problems": [
              347,
              23
            ]
          },
          "advanced": {
            "title": "Level 3 \u2013 Advanced Mode",
            "description": "Dynamic medians and graph algorithms.",
            "concepts": [
              {
                "title": "Two Heaps",
                "explanation": "Using a MinHeap and MaxHeap together to track the median of a stream."
              },
              {
                "title": "Dijkstra Integration",
                "explanation": "How priority queues power shortest path searches in graphs."
              }
            ],
            "problems": [
              295,
              857
            ]
          }
        },
        "visualizerType": "heap",
        "patternMapping": {
          "relatedPatterns": [
            {
              "id": "greedy",
              "label": "Greedy",
              "reason": "Heaps are used to pick the 'best' option at each step."
            }
          ],
          "dependencyGraph": {
            "nodes": [
              {
                "id": "heaps",
                "label": "Heaps",
                "type": "root"
              },
              {
                "id": "top_k",
                "label": "Top K",
                "type": "pattern"
              },
              {
                "id": "greedy",
                "label": "Greedy",
                "type": "pattern"
              }
            ],
            "edges": [
              {
                "from": "heaps",
                "to": "top_k",
                "label": "Partial Sorting"
              },
              {
                "from": "heaps",
                "to": "greedy",
                "label": "Optimal Choice"
              }
            ]
          }
        },
        "comparisons": [
          {
            "targetId": "bst",
            "title": "Heap vs BST",
            "metrics": [
              {
                "label": "Search",
                "values": {
                  "Heap": "O(N)",
                  "BST": "O(log N)"
                }
              },
              {
                "label": "Find Min",
                "values": {
                  "Heap": "O(1)",
                  "BST": "O(log N)"
                }
              }
            ],
            "tradeoff": "Heaps are better for priority tracking, BSTs are better for general sorted search."
          }
        ],
        "interviewSim": {
          "commonMistakes": [
            {
              "title": "Heapq Default",
              "explanation": "Forgetting that Python's `heapq` is a MinHeap.",
              "warning": "Negate values to simulate a MaxHeap."
            }
          ],
          "constraints": [
            "N log N complexity",
            "In-place heapify"
          ],
          "practiceProblems": [
            215,
            347
          ]
        },
        "deepDive": {
          "foundation": "Heaps are the 'Optimization Shortcuts' of the data world. They don't sort everything; they only maintain a partial order that guarantees the 'Max' or 'Min' is always at the root.",
          "engine": "The engine uses a 'Bubble-Up' (Swim) and 'Bubble-Down' (Sink) mechanism. When you add an element, it travels up the tree until it finds its rank. When you remove the root, the last element takes its place and 'sinks' down to the correct level.",
          "storage": "Surprisingly, heaps are usually stored as Arrays, not Trees with pointers. Using the formula `LeftChild = 2i + 1` and `RightChild = 2i + 2`, we can traverse a tree structure perfectly inside a flat linear array.",
          "visualization": {
            "type": "layered_tree",
            "layers": [
              {
                "name": "Array Mapping",
                "description": "Index i -> Tree Node relation"
              },
              {
                "name": "The Sink Effect",
                "description": "Visualizing the recursive rank adjustment"
              }
            ]
          }
        },
        "relatedProblems": [
          215,
          295,
          23
        ],
        "subPatterns": [
          {
            "id": "top_k",
            "title": "Top K Elements",
            "description": "Finding the k largest/smallest items.",
            "signals": [
              "Find K most frequent",
              "K closest points"
            ],
            "invariant": "Heap size <= K",
            "formula": "push(x); if size>k pop()",
            "mistakes": [
              "Using wrong heap type (Min vs Max)"
            ],
            "edgeCases": [
              {
                "title": "K > N",
                "description": "Request more than available.",
                "whyItBreaks": "Logic."
              }
            ],
            "exampleCode": "heapq.heappush(h, x); if len(h)>k: heapq.heappop(h)"
          },
          {
            "id": "median_stream",
            "title": "Median of Stream",
            "description": "Using two heaps (Min & Max) to track middle.",
            "signals": [
              "Dynamic median",
              "Rolling stats"
            ],
            "invariant": "Balance sizes",
            "formula": "MaxHeap(Left) <= MinHeap(Right)",
            "mistakes": [
              "Not rebalancing heaps"
            ],
            "edgeCases": [
              {
                "title": "Odd vs Even count",
                "description": "Need precise logic.",
                "whyItBreaks": "Off-by-one."
              }
            ],
            "exampleCode": "if len(small) > len(large) + 1: ..."
          }
        ],
        "recognitionSignals": [
          "Kth largest/smallest",
          "Median of stream",
          "Task scheduling",
          "Merge K Sorted Lists"
        ],
        "formulaPattern": "heapq.heappush(h, val)",
        "commonMistakes": [
          "Confusing MinHeap (default in Python) with MaxHeap",
          "Rebuilding heap instead of updating (slow)"
        ],
        "edgeCases": [
          "Empty heap extract",
          "Single element"
        ],
        "templates": {
          "python": "import heapq\nh = []\nheapq.heappush(h, val)\nmin_val = heapq.heappop(h)\n# For MaxHeap: Push -val",
          "javascript": "// Use library or implement:\nconst pq = new MinPriorityQueue();\npq.enqueue(val);\npq.dequeue().element;"
        },
        "microDrills": [
          {
            "question": "What is the time complexity to convert an unsorted array into a Heap (Heapify)?",
            "options": [
              "O(N log N)",
              "O(N)",
              "O(1)",
              "O(log N)"
            ],
            "correctAnswer": "O(N)",
            "explanation": "While inserting one by one is O(N log N), building it bottom-up is O(N)."
          },
          {
            "question": "Python's `heapq` module implements which type of heap?",
            "options": [
              "Max Heap",
              "Min Heap",
              "Fibonacci Heap",
              "Binomial Heap"
            ],
            "correctAnswer": "Min Heap",
            "explanation": "To simulate a Max Heap, values are often negated."
          }
        ],
        "recognitionChallenges": []
      },
      {
        "id": "matrices",
        "title": "Matrix (2D Arrays)",
        "family": "Data Structures",
        "difficulty": "Adept",
        "description": "Grid-based data representation.",
        "definition": "A two-dimensional array representing table-like data.",
        "hero": {
          "analogy": "The Battleship Board / Spreadsheet",
          "analogyImage": "matrix_grid",
          "realWorldExample": "Excel Sheet. Cells identified by coordinates (A1, B2). Neighbors are spatially adjacent.",
          "whenToUse": [
            "Spatial data (Grids/Maps)",
            "Dynamic Programming tables",
            "Graph representation"
          ],
          "quickComplexity": [
            {
              "operation": "Access Cell",
              "time": "O(1)",
              "space": "O(1)"
            },
            {
              "operation": "Traversal",
              "time": "O(R*C)",
              "space": "O(1)"
            }
          ]
        },
        "whatProblemItSolves": "Allows representing and processing data that has a spatial or relational dimension (like a 2D grid).",
        "memoryRepresentation": "Stored as 'Row-Major' (linear block of cells) or as an 'Array of Arrays'.",
        "internalWorking": "Uses a coordinate system. Cell (r, c) is mapped to memory address `Base + (r * Width + c) * Size`.",
        "progression": {
          "fundamentals": {
            "title": "Level 1 \u2013 Fundamentals",
            "description": "Grid indexing and bounded traversal.",
            "concepts": [
              {
                "title": "Row-Major Storage",
                "explanation": "Why row-by-row traversal is faster due to CPU cache locality."
              },
              {
                "title": "Boundary Checks",
                "explanation": "Ensuring (r, c) stays within [0...Rows-1] and [0...Cols-1]."
              }
            ],
            "problems": [
              73,
              48
            ]
          },
          "patterns": {
            "title": "Level 2 \u2013 Pattern Usage",
            "description": "Spatial searches and state machines.",
            "concepts": [
              {
                "title": "Spiral Traversal",
                "explanation": "Navigating the perimeter in layers."
              },
              {
                "title": "Island Problems",
                "explanation": "Using DFS or BFS to traverse connected components in a grid."
              }
            ],
            "problems": [
              54,
              200
            ]
          },
          "advanced": {
            "title": "Level 3 \u2013 Advanced Mode",
            "description": "Graph mappings and DP optimizations.",
            "concepts": [
              {
                "title": "Adjacency Matrix",
                "explanation": "Using a grid to represent connections between nodes in a graph."
              },
              {
                "title": "In-place Transformation",
                "explanation": "Rotating or modifying the grid without O(R*C) extra space."
              }
            ],
            "problems": [
              329,
              36
            ]
          }
        },
        "visualizerType": "matrix",
        "deepDive": {
          "foundation": "Matrices provide a spatial dimension to data. They represent a Cartesian coordinate system (X, Y) where every element has exactly 4 (or 8) immediate neighbors.",
          "engine": "The matrix engine is a 'Row-Major' or 'Column-Major' mapper. In Row-Major (used by C/Python), a 2D matrix is actually stored as a single long 1D array. The engine calculates index as `i = row * rowLength + col`.",
          "storage": "Storage is a flat memory block. This 'Flattening' is critical for performance\u2014it allows the CPU to use the same 'Spatial Locality' optimizations as 1D arrays, provided you traverse them row-by-row rather than jumping between columns.",
          "visualization": {
            "type": "coordinate_grid",
            "layers": [
              {
                "name": "Adjacency Map",
                "description": "Up, Down, Left, Right connections"
              },
              {
                "name": "Flattened RAM",
                "description": "How 2D coords map to 1D physical memory"
              }
            ]
          }
        },
        "relatedProblems": [
          48,
          73,
          200
        ],
        "subPatterns": [
          {
            "id": "grid_dfs_bfs",
            "title": "Grid DFS/BFS",
            "description": "Traversing connected components in a grid.",
            "signals": [
              "Number of Islands",
              "Shortest Path in Maize"
            ],
            "invariant": "Stay within bounds",
            "formula": "directions = [(0,1), (1,0), ...]",
            "mistakes": [
              "Visiting same cell twice (infinite loop)"
            ],
            "edgeCases": [
              {
                "title": "Corner cells",
                "description": "Fewer neighbors.",
                "whyItBreaks": "Bounds check."
              }
            ],
            "exampleCode": "for dr, dy in directions: nr, nc = r+dr, c+dc"
          },
          {
            "id": "matrix_manipulation",
            "title": "In-place Manipulation",
            "description": "Rotating or modifying grid without extra space.",
            "signals": [
              "Rotate Image",
              "Set Matrix Zeroes"
            ],
            "invariant": "Map old coords to new",
            "formula": "matrix[j][n-1-i] = matrix[i][j]",
            "mistakes": [
              "Overwriting needed data"
            ],
            "edgeCases": [
              {
                "title": "Non-square",
                "description": "Rotation difficult.",
                "whyItBreaks": "N/A"
              }
            ],
            "exampleCode": "transpose(); reverse_rows()"
          }
        ],
        "recognitionSignals": [
          "Grid traversal",
          "Game boards",
          "Image processing",
          "Adjacency constraints"
        ],
        "formulaPattern": "matrix[row][col]",
        "commonMistakes": [
          "Confusing row (y) and col (x) indices",
          "Index out of bounds (negative or >= length)"
        ],
        "edgeCases": [
          "Empty matrix",
          "Jagged matrix (uneven rows)",
          "1x1 Matrix"
        ],
        "templates": {
          "python": "R, C = len(grid), len(grid[0])\nfor r in range(R):\n    for c in range(C):\n        # Visit grid[r][c]",
          "javascript": "const R=grid.length, C=grid[0].length;\nfor(let r=0; r<R; r++) {\n    for(let c=0; c<C; c++) {\n        // Visit grid[r][c]\n    }\n}"
        },
        "microDrills": [
          {
            "question": "How many neighbors does a cell have in a standard grid (excluding diagonals)?",
            "options": [
              "2",
              "4 (fewer on edges)",
              "8",
              "6"
            ],
            "correctAnswer": "4 (fewer on edges)",
            "explanation": "Up, Down, Left, Right."
          }
        ],
        "recognitionChallenges": []
      },
      {
        "id": "prefix_sums",
        "title": "Prefix Sum Arrays",
        "family": "Data Structures",
        "difficulty": "Adept",
        "description": "Precomputed cumulative sums for range queries.",
        "definition": "An array where the element at index i stores the sum of the original array from 0 to i.",
        "hero": {
          "analogy": "The Running Ledger",
          "analogyImage": "prefix_ledger",
          "realWorldExample": "Bank Account Balance history. Balance at Day 5 - Balance at Day 2 = Spending between Day 3 and 5.",
          "whenToUse": [
            "Multiple range sum queries",
            "Subarray sum problems",
            "Image processing (Integral images)"
          ],
          "quickComplexity": [
            {
              "operation": "Build",
              "time": "O(N)",
              "space": "O(N)"
            },
            {
              "operation": "Range Query",
              "time": "O(1)",
              "space": "O(1)"
            }
          ]
        },
        "whatProblemItSolves": "Transforms O(N) range queries into O(1) by precomputing cumulative totals.",
        "memoryRepresentation": "Usually an array of size N+1, where index 0 is a 0-filled 'sentinel' to handle ranges starting at index 0.",
        "internalWorking": "Traverse the array once, adding current element to the previous prefix sum: `P[i] = P[i-1] + A[i-1]`.",
        "progression": {
          "fundamentals": {
            "title": "Level 1 \u2013 Fundamentals",
            "description": "Building and querying prefix sums.",
            "concepts": [
              {
                "title": "Sentinel Zero",
                "explanation": "Why starting with a zero makes range logic cleaner."
              },
              {
                "title": "O(1) Delta",
                "explanation": "Understanding why `P[R+1] - P[L]` yields the sum of `nums[L...R]`."
              }
            ],
            "problems": [
              303,
              724
            ]
          },
          "patterns": {
            "title": "Level 2 \u2013 Pattern Usage",
            "description": "Hash maps and difference arrays.",
            "concepts": [
              {
                "title": "Prefix Sum + Hash Map",
                "explanation": "Finding subarrays that sum to K in O(N) by storing previous sums."
              },
              {
                "title": "2D Prefix Sum",
                "explanation": "Extending the concept to matrices for O(1) subgrid sums."
              }
            ],
            "problems": [
              560,
              304
            ]
          },
          "advanced": {
            "title": "Level 3 \u2013 Advanced Mode",
            "description": "Advanced Range Manipulations.",
            "concepts": [
              {
                "title": "Difference Array",
                "explanation": "The inverse: adding a value to a range [L, R] in O(1)."
              },
              {
                "title": "Prefix XOR",
                "explanation": "Applying the same delta logic to bitwise XOR operations."
              }
            ],
            "problems": [
              1109,
              1310
            ]
          }
        },
        "visualizerType": "prefix_sum",
        "patternMapping": {
          "relatedPatterns": [
            {
              "id": "precomputation",
              "label": "Precomputation",
              "reason": "Reduces query time from linear to constant."
            }
          ],
          "dependencyGraph": {
            "nodes": [],
            "edges": []
          }
        },
        "comparisons": [
          {
            "targetId": "segment_tree",
            "title": "Prefix Sum vs Segment Tree",
            "metrics": [
              {
                "label": "Updates",
                "values": {
                  "PrefixSum": "O(N)",
                  "SegTree": "O(log N)"
                }
              },
              {
                "label": "Queries",
                "values": {
                  "PrefixSum": "O(1)",
                  "SegTree": "O(log N)"
                }
              }
            ],
            "tradeoff": "Prefix Sum is superior for static arrays; Segment Tree is required for dynamic updates."
          }
        ],
        "interviewSim": {
          "commonMistakes": [
            {
              "title": "Off-by-one",
              "explanation": "Forgetting the N+1 array size requirement.",
              "warning": "PrefixSum[i] should represent sum of first `i` elements."
            }
          ],
          "practiceProblems": [
            303,
            560
          ]
        },
        "deepDive": {
          "foundation": "Prefix Sums are the 'Preprocessing Wizards'. They transform a data set so that complex range queries can be answered in absolute constant time, regardless of the range size.",
          "engine": "The engine is a 'Cumulative Accumulator'. By storing the running total at each index, it creates a lookup table where the sum between `i` and `j` is recovered using a simple subtraction: `P[j] - P[i-1]`. It effectively caches the results of all possible starting-from-zero ranges.",
          "storage": "Storage requires an auxiliary array of size `N+1`. This 'extra slot' at index 0 (initialized to zero) is the secret to avoiding edge-case logic when the range starts at the very beginning of the original array.",
          "visualization": {
            "type": "running_total_bar",
            "layers": [
              {
                "name": "Delta Logic",
                "description": "Visualizing why subtraction yields the range sum"
              },
              {
                "name": "Aux Array Offset",
                "description": "The N+1 shift explained"
              }
            ]
          }
        },
        "relatedProblems": [
          303,
          560,
          238
        ],
        "subPatterns": [
          {
            "id": "range_sum",
            "title": "Range Sum Query",
            "description": "Basic 1D range sum.",
            "signals": [
              "Multiple queries for sum",
              "Static array"
            ],
            "invariant": "P[i] includes arr[i]",
            "formula": "P[R] - P[L-1]",
            "mistakes": [
              "Using P[L] instead of P[L-1]"
            ],
            "edgeCases": [
              {
                "title": "L=0",
                "description": "Formula needs P[-1] = 0.",
                "whyItBreaks": "Index error."
              }
            ],
            "exampleCode": "return P[r+1] - P[l]"
          }
        ],
        "recognitionSignals": [
          "Range sum queries",
          "Constant time subarray sum",
          "Product of array except self"
        ],
        "formulaPattern": "P[i] = P[i-1] + A[i]",
        "commonMistakes": [
          "Off-by-one error in range formula",
          "Forgetting to handle index 0"
        ],
        "edgeCases": [
          "Empty array",
          "i=0 case (needs P[-1] handling)"
        ],
        "templates": {
          "python": "P = [0] * (len(nums) + 1)\nfor i, x in enumerate(nums):\n    P[i+1] = P[i] + x\n# Sum(i, j) = P[j+1] - P[i]",
          "javascript": "const P = new Array(nums.length + 1).fill(0);\nfor(let i=0; i<nums.length; i++) {\n    P[i+1] = P[i] + nums[i];\n}"
        },
        "microDrills": [
          {
            "question": "If P[i] sums A[0]...A[i-1], what is the sum of A[L...R]?",
            "options": [
              "P[R] - P[L]",
              "P[R+1] - P[L]",
              "P[R] - P[L-1]",
              "P[R+1] - P[L-1]"
            ],
            "correctAnswer": "P[R+1] - P[L]",
            "explanation": "P array usually has size N+1. P[k] stores sum of first k elements."
          }
        ],
        "recognitionChallenges": []
      },
      {
        "id": "bit_manipulation",
        "title": "Bit Manipulation",
        "family": "Data Structures",
        "difficulty": "Expert",
        "description": "Low-level binary operations.",
        "definition": "Direct manipulation of bits to perform operations efficiently.",
        "hero": {
          "analogy": "The Light Switch Panel",
          "analogyImage": "bit_panel",
          "realWorldExample": "Unix Permissions: Read=4(100), Write=2(010), Execute=1(001). All permissions = 7(111).",
          "whenToUse": [
            "Set theory problems",
            "State compression",
            "Mathematical optimizations"
          ],
          "quickComplexity": [
            {
              "operation": "Logical Gates",
              "time": "O(1)",
              "space": "O(1)"
            },
            {
              "operation": "Bit Counts",
              "time": "O(1)",
              "space": "O(1)"
            }
          ]
        },
        "whatProblemItSolves": "Utilizes the CPU's ability to process 32/64 bits in parallel, providing extreme speed and memory efficiency.",
        "memoryRepresentation": "Data is stored as raw binary sequences (integers). Information is encoded by the presence (1) or absence (0) of charge.",
        "internalWorking": "Uses hardware-level logic gates (AND, OR, XOR, NOT, SHIFT). These are the fastest possible operations in computing.",
        "progression": {
          "fundamentals": {
            "title": "Level 1 \u2013 Fundamentals",
            "description": "Bitwise foundations.",
            "concepts": [
              {
                "title": "Logical XOR",
                "explanation": "Understanding that `x ^ x = 0` and `x ^ 0 = x`."
              },
              {
                "title": "The Bitmask",
                "explanation": "Using an integer to check or set specific positions (e.g., `(n >> i) & 1`)."
              }
            ],
            "problems": [
              191,
              136
            ]
          },
          "patterns": {
            "title": "Level 2 \u2013 Pattern Usage",
            "description": "Power-of-two and bit counting.",
            "concepts": [
              {
                "title": "n & (n-1)",
                "explanation": "The trick to unset the rightmost set bit (used for counting bits or checking power of 2)."
              },
              {
                "title": "Bit Shifting",
                "explanation": "Left shift (`<<`) as multiplication by 2, Right shift (`>>`) as division."
              }
            ],
            "problems": [
              231,
              338
            ]
          },
          "advanced": {
            "title": "Level 3 \u2013 Advanced Mode",
            "description": "State compression and subsets.",
            "concepts": [
              {
                "title": "Subsets Generation",
                "explanation": "Using numbers from 0 to 2^N - 1 as bitmasks to represent all subsets."
              },
              {
                "title": "Kernighan\u2019s Algorithm",
                "explanation": "Counting set bits in O(Set-Bits) rather than O(Total-Bits)."
              }
            ],
            "problems": [
              78,
              201
            ]
          }
        },
        "visualizerType": "bit_manipulation",
        "patternMapping": {
          "relatedPatterns": [
            {
              "id": "subsets",
              "label": "Subsets",
              "reason": "Bitmasks are the standard way to represent combinations."
            }
          ],
          "dependencyGraph": {
            "nodes": [],
            "edges": []
          }
        },
        "comparisons": [
          {
            "targetId": "sets",
            "title": "Bitmask vs Set",
            "metrics": [
              {
                "label": "Memory",
                "values": {
                  "Bitmask": "4 bytes",
                  "HashSet": "Variable (KB)"
                }
              },
              {
                "label": "Range",
                "values": {
                  "Bitmask": "0-63",
                  "HashSet": "Infinite"
                }
              }
            ],
            "tradeoff": "Use Bitmasks for small, fixed ranges (like alphabets or permissions); use Sets for large or sparse data."
          }
        ],
        "interviewSim": {
          "commonMistakes": [
            {
              "title": "Sign Bits",
              "explanation": "Forgetting that right shift behavior varies for negative numbers.",
              "warning": "Use unsigned shifts (`>>>` in JS) or be careful with `>>` in Python/C++."
            }
          ],
          "constraints": [
            "32-bit vs 64-bit limits",
            "Two's complement"
          ],
          "practiceProblems": [
            136,
            191
          ]
        },
        "deepDive": {
          "foundation": "Bit Manipulation is the art of speaking the CPU's native language. Instead of high-level objects, we operate on the 0s and 1s that physically charge the transistors in your processor.",
          "engine": "The bit engine uses 'Logical Gates' (AND, OR, XOR, NOT). Because these gates are implemented directly in hardware circuitry, bitwise operations are often literally the fastest instructions a computer can execute, completing in a single clock cycle.",
          "storage": "Storage is the ultimately compressed form. A single 32-bit integer can store 32 boolean flags, whereas an array of 32 booleans would take at least 32 bytes (256 bits). It's the maximum efficiency density possible in modern computing.",
          "visualization": {
            "type": "binary_gate_panel",
            "layers": [
              {
                "name": "The Mask Effect",
                "description": "How AND/OR operations isolate or set bits"
              },
              {
                "name": "Two's Complement",
                "description": "Visualizing how negative numbers are encoded"
              }
            ]
          }
        },
        "relatedProblems": [
          136,
          191,
          338
        ],
        "subPatterns": [
          {
            "id": "xor_ops",
            "title": "XOR Tricks",
            "description": "Using A^A=0 and A^0=A.",
            "signals": [
              "Find single number",
              "Missing number"
            ],
            "invariant": "XOR is self-inverse",
            "formula": "res ^= nums[i]",
            "mistakes": [
              "Confusing ^ with power"
            ],
            "edgeCases": [
              {
                "title": "All duplicates",
                "description": "Result 0.",
                "whyItBreaks": "N/A"
              }
            ],
            "exampleCode": "mask ^= val"
          },
          {
            "id": "bit_masking",
            "title": "Bit Masking",
            "description": "Setting/Unsetting specific bits.",
            "signals": [
              "Subsets",
              "State compression"
            ],
            "invariant": "1<<k represents k-th item",
            "formula": "(n >> k) & 1",
            "mistakes": [
              "Precedence errors (use parens)"
            ],
            "edgeCases": [
              {
                "title": "Overflow",
                "description": "Left shift beyond 32/64.",
                "whyItBreaks": "Loss of data."
              }
            ],
            "exampleCode": "if (state & (1 << i))"
          }
        ],
        "recognitionSignals": [
          "Binary representation",
          "Space optimization",
          "XOR tricks",
          "Power of 2 check"
        ],
        "formulaPattern": "x & (x-1)",
        "commonMistakes": [
          "Operator precedence (always wrap bit ops in parens)",
          "Signed vs Unsigned shifts",
          "Negative numbers (Two's complement)"
        ],
        "edgeCases": [
          "Overflow",
          "Negative numbers (Two's complement)",
          "0 input"
        ],
        "templates": {
          "python": "# Check if kth bit is set\nis_set = (n >> k) & 1\n# Set kth bit\nn |= (1 << k)\n# Clear kth bit\nn &= ~(1 << k)",
          "javascript": "// Check if kth bit is set\nconst isSet = (n >> k) & 1;\n// Set\nn |= (1 << k);\n// Clear\nn &= ~(1 << k);"
        },
        "microDrills": [
          {
            "question": "What is the result of `n & (n-1)`?",
            "options": [
              "Turns off the rightmost 1-bit",
              "Turns on the rightmost 0-bit",
              "Flips all bits",
              "Checks if n is odd"
            ],
            "correctAnswer": "Turns off the rightmost 1-bit",
            "explanation": "Common trick to count set bits or check power of 2."
          }
        ],
        "recognitionChallenges": []
      },
      {
        "id": "sets",
        "title": "Set",
        "family": "Data Structures",
        "difficulty": "Novice",
        "description": "Unique elements only.",
        "definition": "A collection that contains no duplicate elements.",
        "hero": {
          "analogy": "The VIP Guest List",
          "analogyImage": "set_vip",
          "realWorldExample": "Email list filtering. If you try to add 'alice@gmail.com' twice, the system only keeps one copy.",
          "whenToUse": [
            "Removing duplicates",
            "Existence checking",
            "Finding intersections/unions"
          ],
          "quickComplexity": [
            {
              "operation": "Add",
              "time": "O(1)*",
              "space": "O(N)"
            },
            {
              "operation": "Check",
              "time": "O(1)*",
              "space": "O(N)"
            },
            {
              "operation": "Remove",
              "time": "O(1)*",
              "space": "O(N)"
            }
          ]
        },
        "whatProblemItSolves": "Solves the problem of membership testing without linear search. It provides a mathematical guarantee of uniqueness.",
        "memoryRepresentation": "Usually implemented as a Hash Map where the 'Value' is ignored, or using a Bitset for large ranges.",
        "internalWorking": "Uses a Hash Function to determine existence. Collisions are handled via chaining, much like a Hash Map.",
        "progression": {
          "fundamentals": {
            "title": "Level 1 \u2013 Fundamentals",
            "description": "Basic membership and uniqueness.",
            "concepts": [
              {
                "title": "Uniqueness Constraint",
                "explanation": "Why adding the same item twice results in a single entry."
              },
              {
                "title": "O(1) Membership",
                "explanation": "The efficiency of `item in set` vs `item in list`."
              }
            ],
            "problems": [
              217,
              349
            ]
          },
          "patterns": {
            "title": "Level 2 \u2013 Pattern Usage",
            "description": "Set algebra and intersections.",
            "concepts": [
              {
                "title": "Intersection/Union",
                "explanation": "Finding common elements between two sets efficiently."
              },
              {
                "title": "Seen Set Pattern",
                "explanation": "Using a set to track visited nodes or seen values in a single pass."
              }
            ],
            "problems": [
              350,
              128
            ]
          },
          "advanced": {
            "title": "Level 3 \u2013 Advanced Mode",
            "description": "Bitsets and specialized sets.",
            "concepts": [
              {
                "title": "Bitset Optimization",
                "explanation": "Using a bitmask as a set for fixed integer ranges (speed/space boost)."
              },
              {
                "title": "Ordered Set",
                "explanation": "Maintaining insertion order while preserving uniqueness (LinkedHashSet)."
              }
            ],
            "problems": [
              705,
              146
            ]
          }
        },
        "visualizerType": "set",
        "patternMapping": {
          "relatedPatterns": [
            {
              "id": "seen_tracking",
              "label": "Seen Tracking",
              "reason": "Standard for detecting duplicates or visited states."
            }
          ],
          "dependencyGraph": {
            "nodes": [],
            "edges": []
          }
        },
        "comparisons": [
          {
            "targetId": "arrays",
            "title": "Set vs Array",
            "metrics": [
              {
                "label": "Uniqueness",
                "values": {
                  "Set": "Enforced",
                  "Array": "Manual"
                }
              },
              {
                "label": "Search",
                "values": {
                  "Set": "O(1)",
                  "Array": "O(N)"
                }
              }
            ],
            "tradeoff": "Sets are faster for lookups but do not preserve order or allow duplicates."
          }
        ],
        "interviewSim": {
          "commonMistakes": [
            {
              "title": "Order Assumption",
              "explanation": "Assuming a set will return elements in the order they were added.",
              "warning": "Standard HashSets are unordered."
            }
          ],
          "practiceProblems": [
            217,
            128
          ]
        }
      },
      {
        "id": "deques",
        "title": "Deque (Double-Ended Queue)",
        "family": "Data Structures",
        "difficulty": "Novice",
        "description": "Efficient insertion/deletion at both ends.",
        "definition": "An abstract data type that generalizes a queue, for which elements can be added to or removed from either the front or back.",
        "hero": {
          "analogy": "The Two-Ended Slide",
          "analogyImage": "deque_slide",
          "realWorldExample": "Browser History + Forward/Back. You can go forward from one end and backward from the other.",
          "whenToUse": [
            "Sliding Window Maximum",
            "Implementing both Stack and Queue",
            "Efficient BFS"
          ],
          "quickComplexity": [
            {
              "operation": "Push Front/Back",
              "time": "O(1)",
              "space": "O(1)"
            },
            {
              "operation": "Pop Front/Back",
              "time": "O(1)",
              "space": "O(1)"
            }
          ]
        },
        "whatProblemItSolves": "Eliminates the O(N) shift cost when adding/removing from the front of an array.",
        "memoryRepresentation": "Implemented as a Doubly Linked List or a Circular Buffer within an array.",
        "internalWorking": "Maintains two pointers (Head and Tail). Modulo arithmetic is typically used to handle wrap-around in array implementations.",
        "progression": {
          "fundamentals": {
            "title": "Level 1 \u2013 Fundamentals",
            "description": "Basic push/pop from both ends.",
            "concepts": [
              {
                "title": "Dual Access",
                "explanation": "Why having access to both ends is more versatile than a standard stack or queue."
              },
              {
                "title": "Implementation Tradeoffs",
                "explanation": "LinkedList vs Circular Array speed differences."
              }
            ],
            "problems": [
              641,
              933
            ]
          },
          "patterns": {
            "title": "Level 2 \u2013 Pattern Usage",
            "description": "Monotonicity and ranges.",
            "concepts": [
              {
                "title": "Monotonic Deque",
                "explanation": "Keeping elements in increasing/decreasing order while sliding a window."
              },
              {
                "title": "BFS Optimizations",
                "explanation": "Using a deque to efficiently manage level-order exploration."
              }
            ],
            "problems": [
              239,
              1438
            ]
          },
          "advanced": {
            "title": "Level 3 \u2013 Advanced Mode",
            "description": "Shortest paths and work-stealing.",
            "concepts": [
              {
                "title": "0-1 BFS",
                "explanation": "Using a deque to solve shortest path in graphs with weights 0 and 1."
              },
              {
                "title": "Work-Stealing",
                "explanation": "How parallel executors use deques to balance tasks."
              }
            ],
            "problems": [
              862,
              1368
            ]
          }
        },
        "visualizerType": "deque",
        "patternMapping": {
          "relatedPatterns": [
            {
              "id": "sliding_window",
              "label": "Sliding Window",
              "reason": "Deques are the engine for monotonic range queries."
            }
          ],
          "dependencyGraph": {
            "nodes": [],
            "edges": []
          }
        },
        "comparisons": [
          {
            "targetId": "stacks",
            "title": "Deque vs Stack",
            "metrics": [
              {
                "label": "Ends",
                "values": {
                  "Deque": "Both",
                  "Stack": "Top Only"
                }
              }
            ],
            "tradeoff": "A Deque is a superset of a Stack."
          }
        ],
        "interviewSim": {
          "commonMistakes": [
            {
              "title": "Front shift",
              "explanation": "Using `list.pop(0)` in Python instead of `collections.deque`.",
              "warning": "`list.pop(0)` is O(N). Always use `deque.popleft()` for O(1)."
            }
          ],
          "practiceProblems": [
            239,
            641
          ]
        }
      },
      {
        "id": "binary_trees",
        "title": "Binary Tree",
        "family": "Data Structures",
        "difficulty": "Adept",
        "description": "Hierarchical node structure with at most two children.",
        "definition": "A tree data structure in which each node has at most two children, referred to as the left child and the right child.",
        "hero": {
          "analogy": "The Family Tree",
          "analogyImage": "tree_family",
          "realWorldExample": "File System Directories. A folder can contain subfolders (children).",
          "whenToUse": [
            "Representing hierarchical data",
            "Recursive searching",
            "Decision trees"
          ],
          "quickComplexity": [
            {
              "operation": "Traversal",
              "time": "O(N)",
              "space": "O(H)"
            },
            {
              "operation": "Search",
              "time": "O(N)",
              "space": "O(H)"
            }
          ]
        },
        "whatProblemItSolves": "Organizes data into paths and hierarchies, allowing for exponential data growth with logarithmic depth (in balanced cases).",
        "memoryRepresentation": "Nodes containing `value`, `left_pointer`, and `right_pointer`. References can be null if a child doesn't exist.",
        "internalWorking": "Traversed using depth (DFS) or breadth (BFS). Properties like 'Height' and 'Balance' determine the efficiency of operations.",
        "progression": {
          "fundamentals": {
            "title": "Level 1 \u2013 Fundamentals",
            "description": "Basic traversal and node properties.",
            "concepts": [
              {
                "title": "Recursive Traversal",
                "explanation": "In-order, Pre-order, and Post-order visiting patterns."
              },
              {
                "title": "Height vs Depth",
                "explanation": "Understanding the vertical metrics of a tree."
              }
            ],
            "problems": [
              104,
              226
            ]
          },
          "patterns": {
            "title": "Level 2 \u2013 Pattern Usage",
            "description": "Properties and path analysis.",
            "concepts": [
              {
                "title": "Level Order (BFS)",
                "explanation": "Visiting the tree layer-by-layer using a queue."
              },
              {
                "title": "Path Sums",
                "explanation": "Exploring paths from root to leaves to satisfy conditions."
              }
            ],
            "problems": [
              102,
              112
            ]
          },
          "advanced": {
            "title": "Level 3 \u2013 Advanced Mode",
            "description": "Structural transformations and complex LCA.",
            "concepts": [
              {
                "title": "Lowest Common Ancestor",
                "explanation": "Finding the split point between two nodes in the hierarchy."
              },
              {
                "title": "Tree Serialization",
                "explanation": "Converting a binary tree into a string/array format for transmission."
              }
            ],
            "problems": [
              236,
              297
            ]
          }
        },
        "visualizerType": "binary_tree",
        "patternMapping": {
          "relatedPatterns": [
            {
              "id": "dfs",
              "label": "DFS",
              "reason": "The natural way to explore tree branches."
            },
            {
              "id": "bfs",
              "label": "BFS",
              "reason": "Standard for level-by-level traversal."
            }
          ],
          "dependencyGraph": {
            "nodes": [
              {
                "id": "binary_trees",
                "label": "Binary Trees",
                "type": "root"
              },
              {
                "id": "dfs",
                "label": "DFS",
                "type": "pattern"
              },
              {
                "id": "bfs",
                "label": "BFS",
                "type": "pattern"
              }
            ],
            "edges": [
              {
                "from": "binary_trees",
                "to": "dfs",
                "label": "Path Exploration"
              },
              {
                "from": "binary_trees",
                "to": "bfs",
                "label": "Level Traversal"
              }
            ]
          }
        },
        "comparisons": [
          {
            "targetId": "linked_lists",
            "title": "Binary Tree vs Linked List",
            "metrics": [
              {
                "label": "Structure",
                "values": {
                  "Tree": "Non-linear",
                  "List": "Linear"
                }
              },
              {
                "label": "Search",
                "values": {
                  "Tree": "O(log N)*",
                  "List": "O(N)"
                }
              }
            ],
            "tradeoff": "Trees allow branching search, Lists are strictly sequential."
          }
        ],
        "interviewSim": {
          "commonMistakes": [
            {
              "title": "Base Case",
              "explanation": "Forgetting the `if not root: return` case in recursive functions.",
              "warning": "Will cause AttributeErrors/NullPointerExceptions."
            }
          ],
          "practiceProblems": [
            104,
            102
          ]
        }
      },
      {
        "id": "bst",
        "title": "Binary Search Tree (BST)",
        "family": "Data Structures",
        "difficulty": "Adept",
        "description": "Sorted binary tree for efficient search.",
        "definition": "A binary tree where for every node, values in the left subtree are smaller and values in the right subtree are larger.",
        "hero": {
          "analogy": "The Organized Library Shelves",
          "analogyImage": "bst_library",
          "realWorldExample": "Search Engines. By keeping data sorted, you can discard half the search space with every step (Binary Search).",
          "whenToUse": [
            "Dynamic sorting",
            "Fast lookups in unpredictable data sets",
            "Range queries"
          ],
          "quickComplexity": [
            {
              "operation": "Search",
              "time": "O(log N)*",
              "space": "O(H)"
            },
            {
              "operation": "Insert",
              "time": "O(log N)*",
              "space": "O(H)"
            }
          ]
        },
        "whatProblemItSolves": "Combines the fast insertion of a linked list with the fast search of a sorted array.",
        "memoryRepresentation": "Same as a Binary Tree, but maintained with a strict ordering invariant.",
        "internalWorking": "During insertion/search, we compare target with current node. If `target < node.val`, go left; else go right.",
        "progression": {
          "fundamentals": {
            "title": "Level 1 \u2013 Fundamentals",
            "description": "BST properties and validation.",
            "concepts": [
              {
                "title": "The BST Invariant",
                "explanation": "Left < Node < Right. Always."
              },
              {
                "title": "Validating BST",
                "explanation": "Why checking children values isn't enough (need range boundaries)."
              }
            ],
            "problems": [
              98,
              700
            ]
          },
          "patterns": {
            "title": "Level 2 \u2013 Pattern Usage",
            "description": "In-order properties and searching.",
            "concepts": [
              {
                "title": "In-order = Sorted",
                "explanation": "An in-order traversal of a BST always yields sorted values."
              },
              {
                "title": "Successor/Predecessor",
                "explanation": "Finding the next smallest/largest nodes without full traversal."
              }
            ],
            "problems": [
              230,
              173
            ]
          },
          "advanced": {
            "title": "Level 3 \u2013 Advanced Mode",
            "description": "Balancing and deletions.",
            "concepts": [
              {
                "title": "Balanced BST (AVL/Red-Black)",
                "explanation": "Automatically keeping height at O(log N) regardless of input order."
              },
              {
                "title": "BST Deletion",
                "explanation": "Handling the complex 'Node with two children' case."
              }
            ],
            "problems": [
              450,
              108
            ]
          }
        },
        "visualizerType": "bst",
        "patternMapping": {
          "relatedPatterns": [
            {
              "id": "binary_search",
              "label": "Binary Search",
              "reason": "The logic derived from the BST structure."
            }
          ],
          "dependencyGraph": {
            "nodes": [],
            "edges": []
          }
        },
        "comparisons": [
          {
            "targetId": "hash_maps",
            "title": "BST vs Hash Map",
            "metrics": [
              {
                "label": "Search",
                "values": {
                  "BST": "O(log N)",
                  "Hash": "O(1) avg"
                }
              },
              {
                "label": "Sorting",
                "values": {
                  "BST": "Inherent",
                  "Hash": "None"
                }
              }
            ],
            "tradeoff": "Hash Maps are faster, but BSTs stay sorted and support range queries."
          }
        ],
        "interviewSim": {
          "commonMistakes": [
            {
              "title": "Skewed Tree",
              "explanation": "Inserting sorted data into a BST results in a O(N) linked list.",
              "warning": "Mention 'Self-Balancing Trees' if asked about worst-case O(N)."
            }
          ],
          "practiceProblems": [
            98,
            230
          ]
        }
      },
      {
        "id": "graphs",
        "title": "Graph",
        "family": "Data Structures",
        "difficulty": "Adept",
        "description": "Nodes and edges representing complex relationships.",
        "definition": "A collection of vertices (nodes) and edges (connections) between them.",
        "hero": {
          "analogy": "The Social Network",
          "analogyImage": "graph_social",
          "realWorldExample": "Google Maps. Intersections are nodes, and roads connecting them are edges. Some roads are one-way (Directed).",
          "whenToUse": [
            "Modeling networks",
            "Pathfinding",
            "Recommendation engines"
          ],
          "quickComplexity": [
            {
              "operation": "Adjacency List Space",
              "time": "O(V+E)",
              "space": "O(V+E)"
            },
            {
              "operation": "Adjacency Matrix Space",
              "time": "O(V^2)",
              "space": "O(V^2)"
            }
          ]
        },
        "whatProblemItSolves": "Models non-hierarchical, many-to-many relationships that trees and lists cannot represent.",
        "memoryRepresentation": "Usually 'Adjacency List' (Map of lists) or 'Adjacency Matrix' (2D Grid).",
        "internalWorking": "Basic exploration uses DFS/BFS. Complex problems involve cycles, connectivity, and shortest paths.",
        "progression": {
          "fundamentals": {
            "title": "Level 1 \u2013 Fundamentals",
            "description": "Representation and basic traversal.",
            "concepts": [
              {
                "title": "Adj List vs Matrix",
                "explanation": "When to trade space for lookup speed."
              },
              {
                "title": "Directed vs Undirected",
                "explanation": "Whether friendships go one way or both."
              }
            ],
            "problems": [
              133,
              1971
            ]
          },
          "patterns": {
            "title": "Level 2 \u2013 Pattern Usage",
            "description": "Connectivity and cycles.",
            "concepts": [
              {
                "title": "Cycle Detection",
                "explanation": "Using visited/recStack to find loops in directed graphs."
              },
              {
                "title": "Connected Components",
                "explanation": "Finding isolated islands of nodes in a network."
              }
            ],
            "problems": [
              207,
              323
            ]
          },
          "advanced": {
            "title": "Level 3 \u2013 Advanced Mode",
            "description": "Graph optimizations.",
            "concepts": [
              {
                "title": "Bipartite Check",
                "explanation": "Determining if a graph can be split into two independent sets."
              },
              {
                "title": "Topological Sort",
                "explanation": "Finding a valid order of operations in dependencies (DAG)."
              }
            ],
            "problems": [
              785,
              210
            ]
          }
        },
        "visualizerType": "graph",
        "patternMapping": {
          "relatedPatterns": [
            {
              "id": "bfs",
              "label": "BFS",
              "reason": "Shortest path discovery."
            },
            {
              "id": "dfs",
              "label": "DFS",
              "reason": "Connectivity analysis."
            }
          ],
          "dependencyGraph": {
            "nodes": [
              {
                "id": "graphs",
                "label": "Graphs",
                "type": "root"
              },
              {
                "id": "bfs",
                "label": "BFS",
                "type": "pattern"
              },
              {
                "id": "dfs",
                "label": "DFS",
                "type": "pattern"
              },
              {
                "id": "union_find",
                "label": "Union Find",
                "type": "pattern"
              }
            ],
            "edges": [
              {
                "from": "graphs",
                "to": "bfs",
                "label": "Shortest Path"
              },
              {
                "from": "graphs",
                "to": "dfs",
                "label": "Connectivity"
              },
              {
                "from": "graphs",
                "to": "union_find",
                "label": "Disjoint Sets"
              }
            ]
          }
        },
        "comparisons": [
          {
            "targetId": "binary_trees",
            "title": "Graph vs Tree",
            "metrics": [
              {
                "label": "Connections",
                "values": {
                  "Graph": "Any",
                  "Tree": "Hierarchical"
                }
              },
              {
                "label": "Cycles",
                "values": {
                  "Graph": "Allowed",
                  "Tree": "Forbidden"
                }
              }
            ],
            "tradeoff": "Trees are specialized graphs with no cycles."
          }
        ],
        "interviewSim": {
          "commonMistakes": [
            {
              "title": "Infinite Loops",
              "explanation": "Forgetting the 'Visited' set in an undirected graph traversal.",
              "warning": "Will cause a Stack Overflow."
            }
          ],
          "practiceProblems": [
            133,
            207
          ]
        }
      },
      {
        "id": "trie",
        "title": "Trie (Prefix Tree)",
        "family": "Data Structures",
        "difficulty": "Expert",
        "description": "Efficient string retrieval via prefixes.",
        "definition": "A tree-like data structure used to store a dynamic set or associative array where the keys are usually strings.",
        "hero": {
          "analogy": "The Autocomplete Dictionary",
          "analogyImage": "trie_autocomplete",
          "realWorldExample": "Search box suggestions. As you type 'APP', the Trie quickly finds 'APPLE', 'APPLY', and 'APPROVE' by following the 'A'->'P'->'P' path.",
          "whenToUse": [
            "Prefix matching",
            "Dictionary lookups",
            "IP routing tables"
          ],
          "quickComplexity": [
            {
              "operation": "Insert/Search",
              "time": "O(L)",
              "space": "O(Alphabet * L * N)"
            }
          ]
        },
        "whatProblemItSolves": "Eliminates the need to compare strings character-by-character against every item in a list. Search time depends only on string length, not the number of strings.",
        "memoryRepresentation": "A root node where each child is a character. Nodes often contain a boolean `isEndOfWord` flag.",
        "internalWorking": "Each step down the tree represents one character. Paths share common prefixes, significantly reducing redundant storage for similar words.",
        "progression": {
          "fundamentals": {
            "title": "Level 1 \u2013 Fundamentals",
            "description": "Prefix branching and insertion.",
            "concepts": [
              {
                "title": "Character Paths",
                "explanation": "How each node represents a single step in a word."
              },
              {
                "title": "isEndOfWord Flag",
                "explanation": "Distinguishing between a prefix (APP) and a complete word (APPLE)."
              }
            ],
            "problems": [
              208,
              211
            ]
          },
          "patterns": {
            "title": "Level 2 \u2013 Pattern Usage",
            "description": "Searching and Wildcards.",
            "concepts": [
              {
                "title": "Prefix Search",
                "explanation": "Returning all words that start with a specific string."
              },
              {
                "title": "Wildcard Matching",
                "explanation": "Using DFS to search multiple branches when characters are unknown (e.g., 'A..E')."
              }
            ],
            "problems": [
              211,
              648
            ]
          },
          "advanced": {
            "title": "Level 3 \u2013 Advanced Mode",
            "description": "Bitwise Tries and Compressed Tries.",
            "concepts": [
              {
                "title": "Compressed Trie (Radix)",
                "explanation": "Merging nodes with only one child to save space."
              },
              {
                "title": "Max XOR Path",
                "explanation": "Using a Bitwise Trie to find the pair of numbers with maximum XOR."
              }
            ],
            "problems": [
              421,
              1032
            ]
          }
        },
        "visualizerType": "trie",
        "patternMapping": {
          "relatedPatterns": [
            {
              "id": "dfs",
              "label": "DFS",
              "reason": "Used for exhaustive search and autocomplete."
            }
          ],
          "dependencyGraph": {
            "nodes": [],
            "edges": []
          }
        },
        "comparisons": [
          {
            "targetId": "hash_maps",
            "title": "Trie vs Hash Map",
            "metrics": [
              {
                "label": "Prefix Search",
                "values": {
                  "Trie": "O(L)",
                  "Hash": "O(N*L)"
                }
              }
            ],
            "tradeoff": "Tries are better for prefix lookups; Hash Maps are better for exact matches."
          }
        ],
        "interviewSim": {
          "commonMistakes": [
            {
              "title": "Memory Overhead",
              "explanation": "Tries can consume a lot of memory because of empty child pointers.",
              "warning": "Consider using a Map for children instead of an array of size 26."
            }
          ],
          "practiceProblems": [
            208,
            211
          ]
        }
      },
      {
        "id": "union_find",
        "title": "Union-Find (Disjoint Set)",
        "family": "Data Structures",
        "difficulty": "Adept",
        "description": "Tracks partitions of elements into disjoint sets.",
        "definition": "A data structure that tracks elements partitioned into disjoint subsets and provides efficient operations to merge sets and find representatives.",
        "hero": {
          "analogy": "The Social Circles Merger",
          "analogyImage": "union_find_circles",
          "realWorldExample": "Electronic Circuit Connectivity. Checking if two points on a circuit board are electrically connected.",
          "whenToUse": [
            "Dynamic connectivity",
            "Cycle detection in undirected graphs",
            "Kruskal's algorithm"
          ],
          "quickComplexity": [
            {
              "operation": "Union/Find",
              "time": "O(\u03b1(N))",
              "space": "O(N)"
            }
          ]
        },
        "whatProblemItSolves": "Answers the 'Are these two connected?' question in near-constant time, even as new connections are added dynamically.",
        "memoryRepresentation": "An array (or map) `parent` where `parent[i]` is the parent of `i`. Elements with `parent[i] == i` are set representatives (roots).",
        "internalWorking": "Use 'Path Compression' to flatten the tree during `find` and 'Union by Rank/Size' to keep trees shallow.",
        "progression": {
          "fundamentals": {
            "title": "Level 1 \u2013 Fundamentals",
            "description": "Basic parent tracking.",
            "concepts": [
              {
                "title": "The Root",
                "explanation": "The ultimate representative of a set."
              },
              {
                "title": "The Find Operation",
                "explanation": "Climbing the parent tree to find the root."
              }
            ],
            "problems": [
              547,
              990
            ]
          },
          "patterns": {
            "title": "Level 2 \u2013 Pattern Usage",
            "description": "Efficiency optimizations.",
            "concepts": [
              {
                "title": "Path Compression",
                "explanation": "Flattening the hierarchy every time we search (The Secret Sauce)."
              },
              {
                "title": "Union by Rank",
                "explanation": "Always attaching the smaller tree to the larger one."
              }
            ],
            "problems": [
              684,
              1202
            ]
          },
          "advanced": {
            "title": "Level 3 \u2013 Advanced Mode",
            "description": "Complex connectivity and Kruskal's.",
            "concepts": [
              {
                "title": "Kruskal's Algorithm",
                "explanation": "Building a Minimum Spanning Tree using Union-Find to avoid cycles."
              },
              {
                "title": "Equation Satisfiability",
                "explanation": "Using sets to model relationships like `a == b` and `b != c`."
              }
            ],
            "problems": [
              1584,
              952
            ]
          }
        },
        "visualizerType": "union_find",
        "patternMapping": {
          "relatedPatterns": [
            {
              "id": "greedy",
              "label": "Greedy",
              "reason": "Used in Kruskal's for MST."
            }
          ],
          "dependencyGraph": {
            "nodes": [],
            "edges": []
          }
        },
        "comparisons": [
          {
            "targetId": "graphs",
            "title": "Union-Find vs DFS",
            "metrics": [
              {
                "label": "Dynamic Updates",
                "values": {
                  "UnionFind": "Excellent",
                  "DFS": "Poor"
                }
              }
            ],
            "tradeoff": "Union-Find is better for building connections over time; DFS is better for static path analysis."
          }
        ],
        "interviewSim": {
          "commonMistakes": [
            {
              "title": "No Path Compression",
              "explanation": "Forgetting path compression leads to O(N) performance.",
              "warning": "Always implement `parent[x] = find(parent[x])`."
            }
          ],
          "practiceProblems": [
            547,
            684
          ]
        }
      }
    ]
  },
  {
    "id": "core_patterns",
    "title": "Core Patterns",
    "description": "Standard solutions to recurring computational problems.",
    "icon": "Layers",
    "modules": [
      {
        "id": "two_pointers",
        "title": "Two Pointers",
        "family": "Core Patterns",
        "difficulty": "Adept",
        "description": "Traverse data from different directions or at different speeds to optimize search.",
        "definition": "A technique using two synchronized indices to traverse a data structure efficiently.",
        "mentalModel": {
          "analogy": "The Dual Scanners",
          "analogyImage": "two_pointers_analogy",
          "realWorldExample": "Two workers scanning a line from both ends to meet in the middle (e.g., matching sorted list items).",
          "coreInsight": "Narrowing the search space! Instead of checking every pair with nested loops O(N\u00b2), we use two pointers to eliminate large portions of the search space in each step O(N).",
          "problemStatement": {
            "definition": "Find two elements in a sorted array that sum up to a specific target value.",
            "returnValue": "The indices of the two elements.",
            "constraints": [
              "Input array is sorted",
              "Constant extra space O(1)",
              "Linear time complexity O(N)"
            ]
          },
          "efficiencyComparison": {
            "bruteForce": "O(N\u00b2)",
            "optimal": "O(N)",
            "gain": "95%"
          }
        },
        "whatItIs": "Using two pointers to iterate through a data structure, typically in sorted arrays or linked lists, to find elements satisfying a condition.",
        "coreInvariant": "Pointers maintain a relationship (e.g., L < R) that defines the valid search space, which shrinks monotonically.",
        "timeComplexity": [
          {
            "operation": "Single Pass Traversal",
            "time": "O(N)",
            "space": "O(1)"
          }
        ],
        "visualizerType": "two_pointer",
        "relatedProblems": [
          1,
          5,
          11,
          15
        ],
        "subPatterns": [
          {
            "id": "opposite_direction",
            "title": "Opposite Direction (Convergence)",
            "description": "Pointers start at both ends and move towards each other.",
            "signals": [
              "Sorted array",
              "Find pair with target sum",
              "Search space shrinking"
            ],
            "invariant": "left < right",
            "formula": "if (sum < target) left++ else right--",
            "mistakes": [
              "Using on unsorted input without sorting first",
              "Incorrect loop condition (left <= right can cause overlap)",
              "Moving both pointers unnecessarily"
            ],
            "edgeCases": [
              {
                "title": "No pair exists",
                "description": "No two numbers sum up to the target.",
                "whyItBreaks": "Loop naturally finishes without return.",
                "howToFix": "Return a default indicator (e.g., [-1, -1]) after the loop."
              }
            ],
            "drills": [
              {
                "type": "invariant_id",
                "question": "Why must the array be sorted for the Two Pointers approach to work in O(N)?",
                "options": [
                  "To use binary search",
                  "To allow predictable pointer movement (sum > target -> decrease sum)",
                  "Sorting is not required",
                  "To avoid duplicates"
                ],
                "correctAnswer": "To allow predictable pointer movement (sum > target -> decrease sum)",
                "explanation": "If the array is unsorted, we cannot know whether moving left or right will increase or decrease the sum.",
                "category": "invariant"
              }
            ],
            "templates": {
              "python": {
                "bruteForce": "def two_sum_brute(nums, target):\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if nums[i] + nums[j] == target:\n                return [i, j]\n    return [-1, -1]",
                "optimal": "def two_sum_optimal(nums, target):\n    # Assumes nums is sorted\n    l, r = 0, len(nums) - 1\n    while l < r:\n        s = nums[l] + nums[r]\n        if s == target: return [l, r]\n        if s < target: l += 1\n        else: r -= 1\n    return [-1, -1]"
              },
              "javascript": {
                "bruteForce": "function twoSumBrute(nums, target) {\n    for (let i = 0; i < nums.length; i++) {\n        for (let j = i + 1; j < nums.length; j++) {\n            if (nums[i] + nums[j] === target) return [i, j];\n        }\n    }\n    return [-1, -1];\n}",
                "optimal": "function twoSumOptimal(nums, target) {\n    // Assumes nums is sorted\n    let l = 0, r = nums.length - 1;\n    while (l < r) {\n        const s = nums[l] + nums[r];\n        if (s === target) return [l, r];\n        s < target ? l++ : r--;\n    }\n    return [-1, -1];\n}"
              },
              "java": {
                "bruteForce": "public int[] twoSumBrute(int[] nums, int target) {\n    for (int i = 0; i < nums.length; i++) {\n        for (int j = i + 1; j < nums.length; j++) {\n            if (nums[i] + nums[j] == target) return new int[]{i, j};\n        }\n    }\n    return new int[]{-1, -1};\n}",
                "optimal": "public int[] twoSumOptimal(int[] nums, int target) {\n    int l = 0, r = nums.length - 1;\n    while (l < r) {\n        int s = nums[l] + nums[r];\n        if (s == target) return new int[]{l, r};\n        if (s < target) l++; else r--;\n    }\n    return new int[]{-1, -1};\n}"
              },
              "cpp": {
                "bruteForce": "vector<int> twoSumBrute(vector<int>& nums, int target) {\n    for (int i = 0; i < nums.size(); i++) {\n        for (int j = i + 1; j < nums.size(); j++) {\n            if (nums[i] + nums[j] == target) return {i, j};\n        }\n    }\n    return {-1, -1};\n}",
                "optimal": "vector<int> twoSumOptimal(vector<int>& nums, int target) {\n    int l = 0, r = nums.size() - 1;\n    while (l < r) {\n        int s = nums[l] + nums[r];\n        if (s == target) return {l, r};\n        if (s < target) l++; else r--;\n    }\n    return {-1, -1};\n}"
              }
            }
          },
          {
            "id": "same_direction",
            "title": "Same Direction (Compaction)",
            "description": "Both pointers move in the same direction, usually at different speeds or conditions.",
            "signals": [
              "In-place removal",
              "Deduplication",
              "Fast scanner with slow writer"
            ],
            "invariant": "slow pointer <= fast pointer",
            "formula": "if (keep) { arr[slow] = arr[fast]; slow++; }",
            "mistakes": [
              "Incorrectly incrementing slow pointer before assignment",
              "Not processing the last element",
              "Boundary check skipping the first element"
            ],
            "edgeCases": [
              {
                "title": "Empty / Single Element",
                "description": "Input has 0 or 1 element.",
                "whyItBreaks": "Pointers might index out of bounds if not checked.",
                "howToFix": "Return length immediately if len < 2."
              }
            ],
            "drills": [
              {
                "type": "movement_prediction",
                "question": "In 'Remove Duplicates', when does the slow pointer move?",
                "options": [
                  "Always",
                  "When fast pointer sees a unique element",
                  "When fast pointer sees a duplicate",
                  "Only at the end"
                ],
                "correctAnswer": "When fast pointer sees a unique element",
                "explanation": "We only advance 'slow' (our barrier for unique elements) when we find a NEW unique element at 'fast'.",
                "category": "movement"
              }
            ],
            "templates": {
              "python": {
                "bruteForce": "def remove_duplicates_brute(nums):\n    unique = []\n    for x in nums:\n        if not unique or x != unique[-1]:\n            unique.append(x)\n    for i in range(len(unique)):\n        nums[i] = unique[i]\n    return len(unique)",
                "optimal": "def remove_duplicates_optimal(nums):\n    if not nums: return 0\n    slow = 0\n    for fast in range(1, len(nums)):\n        if nums[fast] != nums[slow]:\n            slow += 1\n            nums[slow] = nums[fast]\n    return slow + 1"
              },
              "javascript": {
                "bruteForce": "function removeDuplicatesBrute(nums) {\n    let unique = [];\n    for (let x of nums) {\n        if (unique.length === 0 || x !== unique[unique.length - 1]) unique.push(x);\n    }\n    for (let i = 0; i < unique.length; i++) nums[i] = unique[i];\n    return unique.length;\n}",
                "optimal": "function removeDuplicatesOptimal(nums) {\n    if (nums.length === 0) return 0;\n    let slow = 0;\n    for (let fast = 1; fast < nums.length; fast++) {\n        if (nums[fast] !== nums[slow]) {\n            nums[++slow] = nums[fast];\n        }\n    }\n    return slow + 1;\n}"
              },
              "java": {
                "bruteForce": "public int removeDuplicatesBrute(int[] nums) {\n    List<Integer> unique = new ArrayList<>();\n    for (int x : nums) {\n        if (unique.isEmpty() || x != unique.get(unique.size() - 1)) unique.add(x);\n    }\n    for (int i = 0; i < unique.size(); i++) nums[i] = unique.get(i);\n    return unique.size();\n}",
                "optimal": "public int removeDuplicatesOptimal(int[] nums) {\n    if (nums.length == 0) return 0;\n    int slow = 0;\n    for (int fast = 1; fast < nums.length; fast++) {\n        if (nums[fast] != nums[slow]) {\n            nums[++slow] = nums[fast];\n        }\n    }\n    return slow + 1;\n}"
              },
              "cpp": {
                "bruteForce": "int removeDuplicatesBrute(vector<int>& nums) {\n    vector<int> unique;\n    for (int x : nums) {\n        if (unique.empty() || x != unique.back()) unique.push_back(x);\n    }\n    for (int i = 0; i < unique.size(); i++) nums[i] = unique[i];\n    return unique.size();\n}",
                "optimal": "int removeDuplicatesOptimal(vector<int>& nums) {\n    if (nums.empty()) return 0;\n    int slow = 0;\n    for (int fast = 1; fast < nums.size(); fast++) {\n        if (nums[fast] != nums[slow]) {\n            nums[++slow] = nums[fast];\n        }\n    }\n    return slow + 1;\n}"
              }
            }
          },
          {
            "id": "fast_slow",
            "title": "Fast & Slow (Cycle Detection)",
            "description": "One pointer moves twice as fast as the other to detect loops.",
            "signals": [
              "Linked List cycles",
              "Finding middle of structure",
              "Happy number sequence"
            ],
            "invariant": "distance(slow) = X, distance(fast) = 2X",
            "formula": "slow = slow.next; fast = fast.next.next;",
            "mistakes": [
              "Not checking fast.next before moving fast.next.next",
              "Starting both at the same position and immediately breaking the loop",
              "Incorrect termination for odd/even structures"
            ],
            "edgeCases": [
              {
                "title": "Single Node",
                "description": "List has only one node.",
                "whyItBreaks": "fast.next.next might throw error if not careful.",
                "howToFix": "Check if head is null or head.next is null."
              }
            ],
            "drills": [
              {
                "type": "complexity",
                "question": "What is the space complexity of Floyd's Cycle Finding Algorithm?",
                "options": [
                  "O(N)",
                  "O(log N)",
                  "O(1)",
                  "O(N^2)"
                ],
                "correctAnswer": "O(1)",
                "explanation": "It only uses two pointers regardless of the list size.",
                "category": "complexity"
              }
            ],
            "templates": {
              "python": {
                "bruteForce": "def has_cycle_brute(head):\n    visited = set()\n    curr = head\n    while curr:\n        if curr in visited: return True\n        visited.add(curr)\n        curr = curr.next\n    return False",
                "optimal": "def has_cycle_optimal(head):\n    slow = fast = head\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n        if slow == fast: return True\n    return False"
              },
              "javascript": {
                "bruteForce": "function hasCycleBrute(head) {\n    let visited = new Set();\n    let curr = head;\n    while (curr) {\n        if (visited.has(curr)) return true;\n        visited.add(curr);\n        curr = curr.next;\n    }\n    return false;\n}",
                "optimal": "function hasCycleOptimal(head) {\n    let slow = head, fast = head;\n    while (fast && fast.next) {\n        slow = slow.next;\n        fast = fast.next.next;\n        if (slow === fast) return true;\n    }\n    return false;\n}"
              },
              "java": {
                "bruteForce": "public boolean hasCycleBrute(ListNode head) {\n    Set<ListNode> visited = new HashSet<>();\n    ListNode curr = head;\n    while (curr != null) {\n        if (visited.contains(curr)) return true;\n        visited.add(curr);\n        curr = curr.next;\n    }\n    return false;\n}",
                "optimal": "public boolean hasCycleOptimal(ListNode head) {\n    ListNode slow = head, fast = head;\n    while (fast != null && fast.next != null) {\n        slow = slow.next;\n        fast = fast.next.next;\n        if (slow == fast) return true;\n    }\n    return false;\n}"
              },
              "cpp": {
                "bruteForce": "bool hasCycleBrute(ListNode *head) {\n    unordered_set<ListNode*> visited;\n    ListNode *curr = head;\n    while (curr) {\n        if (visited.count(curr)) return true;\n        visited.insert(curr);\n        curr = curr->next;\n    }\n    return false;\n}",
                "optimal": "bool hasCycleOptimal(ListNode *head) {\n    ListNode *slow = head, *fast = head;\n    while (fast && fast->next) {\n        slow = slow->next;\n        fast = fast->next.next;\n        if (slow == fast) return true;\n    }\n    return false;\n}"
              }
            }
          },
          {
            "id": "partition_pattern",
            "title": "Partition (Three-Way)",
            "description": "Divide elements into three categories (Dutch National Flag).",
            "signals": [
              "0, 1, 2 sorting",
              "Pivot partitioning",
              "In-place categorization"
            ],
            "invariant": "0s < L, 1s [L...M], 2s > R",
            "formula": "swap(nums[m], nums[l]) if nums[m] == 0",
            "mistakes": [
              "Incrementing Mid after swapping with Right (Mid must re-check the swapped element)",
              "Incorrect boundary overlaps",
              "Off-by-one in the r initialization"
            ],
            "edgeCases": [
              {
                "title": "All same elements",
                "description": "Array contains only 0s, 1s, or 2s.",
                "whyItBreaks": "Boundaries might cross if not handled.",
                "howToFix": "Standard logic works, but l/r/m logic must be robust."
              }
            ],
            "drills": [
              {
                "type": "movement_prediction",
                "question": "In 3-way partition (Dutch National Flag), when we swap Mid (1) with Right (2), what pointers move?",
                "options": [
                  "Mid and Right",
                  "Only Right",
                  "Only Mid",
                  "Left and Mid"
                ],
                "correctAnswer": "Only Right",
                "explanation": "We decrement Right because we placed a known 2 there. We do NOT increment Mid because the element swapped from Right is unknown.",
                "category": "movement"
              }
            ],
            "templates": {
              "python": {
                "bruteForce": "def sort_colors_brute(nums):\n    # Sort or count sort\n    c0 = c1 = c2 = 0\n    for n in nums:\n        if n == 0: c0 += 1\n        elif n == 1: c1 += 1\n        else: c2 += 1\n    for i in range(len(nums)):\n        if i < c0: nums[i] = 0\n        elif i < c0 + c1: nums[i] = 1\n        else: nums[i] = 2",
                "optimal": "def sort_colors_optimal(nums):\n    l, m, r = 0, 0, len(nums) - 1\n    while m <= r:\n        if nums[m] == 0:\n            nums[l], nums[m] = nums[m], nums[l]\n            l += 1; m += 1\n        elif nums[m] == 1: m += 1\n        else:\n            nums[m], nums[r] = nums[r], nums[m]\n            r -= 1"
              },
              "javascript": {
                "bruteForce": "function sortColorsBrute(nums) {\n    let c0 = 0, c1 = 0, c2 = 0;\n    for (let n of nums) {\n        if (n === 0) c0++; else if (n === 1) c1++; else c2++;\n    }\n    for (let i = 0; i < nums.length; i++) {\n        if (i < c0) nums[i] = 0;\n        else if (i < c0 + c1) nums[i] = 1;\n        else nums[i] = 2;\n    }\n}",
                "optimal": "function sortColorsOptimal(nums) {\n    let l = 0, m = 0, r = nums.length - 1;\n    while (m <= r) {\n        if (nums[m] === 0) [nums[l], nums[m]] = [nums[m++], nums[l++]];\n        else if (nums[m] === 1) m++;\n        else [nums[m], nums[r]] = [nums[r--], nums[m]];\n    }\n}"
              },
              "java": {
                "bruteForce": "public void sortColorsBrute(int[] nums) {\n    int c0 = 0, c1 = 0, c2 = 0;\n    for (int n : nums) {\n        if (n == 0) c0++; else if (n == 1) c1++; else c2++;\n    }\n    for (int i = 0; i < nums.length; i++) {\n        if (i < c0) nums[i] = 0;\n        else if (i < c0 + c1) nums[i] = 1;\n        else nums[i] = 2;\n    }\n}",
                "optimal": "public void sortColorsOptimal(int[] nums) {\n    int l = 0, m = 0, r = nums.length - 1;\n    while (m <= r) {\n        if (nums[m] == 0) {\n            int t = nums[l]; nums[l++] = nums[m]; nums[m++] = t;\n        } else if (nums[m] == 1) m++;\n        else {\n            int t = nums[m]; nums[m] = nums[r]; nums[r--] = t;\n        }\n    }\n}"
              },
              "cpp": {
                "bruteForce": "void sortColorsBrute(vector<int>& nums) {\n    int c0 = 0, c1 = 0, c2 = 0;\n    for (int n : nums) {\n        if (n == 0) c0++; else if (n == 1) c1++; else c2++;\n    }\n    for (int i = 0; i < nums.size(); i++) {\n        if (i < c0) nums[i] = 0;\n        else if (i < c0 + c1) nums[i] = 1;\n        else nums[i] = 2;\n    }\n}",
                "optimal": "void sortColorsOptimal(vector<int>& nums) {\n    int l = 0, m = 0, r = nums.size() - 1;\n    while (m <= r) {\n        if (nums[m] == 0) swap(nums[l++], nums[m++]);\n        else if (nums[m] == 1) m++;\n        else swap(nums[m], nums[r--]);\n    }\n}"
              }
            }
          },
          {
            "id": "k_sum_gen",
            "title": "K-Sum Generalization",
            "description": "Anchor pointer with two-pointer search inside a loop for 3Sum, 4Sum, etc.",
            "signals": [
              "3Sum = 0",
              "Target sum of 3+ elements",
              "Deduplicating multiple pointers"
            ],
            "invariant": "Fix i, then solve TwoSum for [i+1, n-1].",
            "formula": "for i: TwoPointer(i+1, n-1)",
            "mistakes": [
              "Not sorting the array first (essential for two-pointer phase)",
              "Failing to skip duplicates for the anchor element i",
              "Attempting N\u00b3 brute force for N\u00b2 problem"
            ],
            "edgeCases": [
              {
                "title": "Fewer than 3 elements",
                "description": "Input array has length < 3",
                "whyItBreaks": "Loops won't execute, but must return empty list.",
                "howToFix": "Constraint check at start."
              },
              {
                "title": "No solution",
                "description": "No triplet sums to target.",
                "whyItBreaks": "Result remains empty.",
                "howToFix": "Correctly return empty list."
              }
            ],
            "drills": [
              {
                "type": "complexity",
                "question": "What is the time complexity of the optimal 3Sum solution?",
                "options": [
                  "O(N)",
                  "O(N log N)",
                  "O(N^2)",
                  "O(N^3)"
                ],
                "correctAnswer": "O(N^2)",
                "explanation": "Sorting takes O(N log N). The nested loop structure (anchor + 2-pointer sweep) takes O(N^2).",
                "category": "complexity"
              }
            ],
            "templates": {
              "python": {
                "bruteForce": "def three_sum_brute(nums):\n    res = set()\n    nums.sort()  # Output requires sorted to deduce duplicates easily or use set\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if nums[i] + nums[j] + nums[k] == 0:\n                    res.add((nums[i], nums[j], nums[k]))\n    return [list(x) for x in res]",
                "optimal": "def three_sum_optimal(nums):\n    nums.sort(); res = []\n    for i in range(len(nums)-2):\n        if i > 0 and nums[i] == nums[i-1]: continue\n        l, r = i + 1, len(nums) - 1\n        while l < r:\n            s = nums[i] + nums[l] + nums[r]\n            if s < 0: l += 1\n            elif s > 0: r -= 1\n            else:\n                res.append([nums[i], nums[l], nums[r]])\n                while l < r and nums[l] == nums[l+1]: l += 1\n                while l < r and nums[r] == nums[r-1]: r -= 1\n                l += 1; r -= 1\n    return res"
              },
              "javascript": {
                "bruteForce": "function threeSumBrute(nums) {\n    nums.sort((a,b)=>a-b);\n    let res = [], n = nums.length;\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            for (let k = j + 1; k < n; k++) {\n                if (nums[i] + nums[j] + nums[k] === 0) {\n                    // naive duplicate check is hard, usually rely on Set of strings\n                    const trip = JSON.stringify([nums[i], nums[j], nums[k]]);\n                    if (!res.includes(trip)) res.push(trip);\n                }\n            }\n        }\n    }\n    return res.map(JSON.parse);\n}",
                "optimal": "function threeSumOptimal(nums) {\n    nums.sort((a,b) => a-b); const res = [];\n    for (let i = 0; i < nums.length - 2; i++) {\n        if (i > 0 && nums[i] === nums[i-1]) continue;\n        let l = i + 1, r = nums.length - 1;\n        while (l < r) {\n            const s = nums[i] + nums[l] + nums[r];\n            if (s === 0) {\n                res.push([nums[i], nums[l], nums[r]]);\n                while (l < r && nums[l] === nums[l+1]) l++;\n                while (l < r && nums[r] === nums[r-1]) r--;\n                l++; r--;\n            } else if (s < 0) l++; else r--;\n        }\n    }\n    return res;\n}"
              },
              "java": {
                "bruteForce": "public List<List<Integer>> threeSumBrute(int[] nums) {\n    Arrays.sort(nums);\n    Set<List<Integer>> res = new HashSet<>();\n    int n = nums.length;\n    for (int i = 0; i < n; i++)\n        for (int j = i+1; j < n; j++)\n            for (int k = j+1; k < n; k++)\n                if (nums[i] + nums[j] + nums[k] == 0)\n                    res.add(Arrays.asList(nums[i], nums[j], nums[k]));\n    return new ArrayList<>(res);\n}",
                "optimal": "public List<List<Integer>> threeSumOptimal(int[] nums) {\n    Arrays.sort(nums); List<List<Integer>> res = new ArrayList<>();\n    for (int i = 0; i < nums.length - 2; i++) {\n        if (i > 0 && nums[i] == nums[i-1]) continue;\n        int l = i + 1, r = nums.length - 1;\n        while (l < r) {\n            int s = nums[i] + nums[l] + nums[r];\n            if (s == 0) {\n                res.add(Arrays.asList(nums[i], nums[l], nums[r]));\n                while (l < r && nums[l] == nums[l+1]) l++;\n                while (l < r && nums[r] == nums[r-1]) r--;\n                l++; r--;\n            } else if (s < 0) l++; else r--;\n        }\n    }\n    return res;\n}"
              },
              "cpp": {
                "bruteForce": "vector<vector<int>> threeSumBrute(vector<int>& nums) {\n    sort(nums.begin(), nums.end());\n    set<vector<int>> s;\n    int n = nums.size();\n    for(int i=0; i<n; i++)\n        for(int j=i+1; j<n; j++)\n            for(int k=j+1; k<n; k++)\n                if(nums[i]+nums[j]+nums[k] == 0) s.insert({nums[i], nums[j], nums[k]});\n    return vector<vector<int>>(s.begin(), s.end());\n}",
                "optimal": "vector<vector<int>> threeSumOptimal(vector<int>& nums) {\n    sort(nums.begin(), nums.end()); vector<vector<int>> res;\n    for (int i = 0; i < (int)nums.size() - 2; i++) {\n        if (i > 0 && nums[i] == nums[i-1]) continue;\n        int l = i + 1, r = nums.size() - 1;\n        while (l < r) {\n            int s = nums[i] + nums[l] + nums[r];\n            if (s == 0) {\n                res.push_back({nums[i], nums[l], nums[r]});\n                while (l < r && nums[l] == nums[l+1]) l++;\n                while (l < r && nums[r] == nums[r-1]) r--;\n                l++; r--;\n            } else if (s < 0) l++; else r--;\n        }\n    }\n    return res;\n}"
              }
            }
          },
          {
            "id": "in_place_swap",
            "title": "In-Place Swapping",
            "description": "Swap elements between pointers to reorder the array.",
            "signals": [
              "Reverse string/array",
              "Move zeros to end",
              "Zero-space cost requirement"
            ],
            "invariant": "Elements outside the pointers are processed.",
            "formula": "swap(arr[l], arr[r]); l++; r--;",
            "templates": {
              "python": {
                "bruteForce": "def reverse_string_brute(s):\n    return s[::-1] # New list creation",
                "optimal": "def reverse_string_optimal(s):\n    l, r = 0, len(s) - 1\n    while l < r:\n        s[l], s[r] = s[r], s[l]\n        l += 1; r -= 1"
              },
              "javascript": {
                "bruteForce": "function reverseStringBrute(s) {\n    return s.slice().reverse(); // Creates copy\n}",
                "optimal": "function reverseStringOptimal(s) {\n    let l = 0, r = s.length - 1;\n    while (l < r) {\n        [s[l], s[r]] = [s[r], s[l]];\n        l++; r--;\n    }\n}"
              },
              "java": {
                "bruteForce": "public void reverseStringBrute(char[] s) {\n    // Java strings immutable, must use StringBuilder or new array for 'copy' logic\n    char[] copy = new char[s.length];\n    for(int i=0; i<s.length; i++) copy[i] = s[s.length-1-i];\n    System.arraycopy(copy, 0, s, 0, s.length);\n}",
                "optimal": "public void reverseStringOptimal(char[] s) {\n    int l = 0, r = s.length - 1;\n    while (l < r) {\n        char t = s[l]; s[l++] = s[r]; s[r--] = t;\n    }\n}"
              },
              "cpp": {
                "bruteForce": "void reverseStringBrute(vector<char>& s) {\n    reverse(s.begin(), s.end()); // STL optimized, typically equivalent to optimal logic users write manually\n}",
                "optimal": "void reverseStringOptimal(vector<char>& s) {\n    int l = 0, r = s.size() - 1;\n    while (l < r) swap(s[l++], s[r--]);\n}"
              }
            },
            "edgeCases": [
              {
                "title": "Empty String",
                "description": "Input has 0 length.",
                "whyItBreaks": "Accessing s[0] causes error.",
                "howToFix": "Constraint checks or loop condition (0 < -1) handles it naturally."
              }
            ],
            "drills": [
              {
                "type": "movement_prediction",
                "question": "In 'Reverse String', when do we stop swapping?",
                "options": [
                  "When Left == Right",
                  "When Left < Right",
                  "When Left > Right",
                  "When Left >= Right"
                ],
                "correctAnswer": "When Left >= Right",
                "explanation": "If Left == Right, the middle element doesn't need swapping. If Left > Right, we've crossed.",
                "category": "movement"
              }
            ]
          },
          {
            "id": "merge_sorted",
            "title": "Merge Two Sorted",
            "description": "Scan two arrays and build a third (or merger in-place from end).",
            "signals": [
              "Sorted input strings/arrays merging",
              "Merging linked lists",
              "Combining datasets"
            ],
            "invariant": "Smallest element of remaining is always at current pointers.",
            "formula": "if (a[i] < b[j]) add a[i++] else add b[j++]",
            "templates": {
              "python": {
                "bruteForce": "def merge_brute(nums1, m, nums2, n):\n    # Copy nums2 to end of nums1 then sort\n    for i in range(n):\n        nums1[m+i] = nums2[i]\n    nums1.sort()",
                "optimal": "def merge_optimal(nums1, m, nums2, n):\n    i, j, k = m - 1, n - 1, m + n - 1\n    while i >= 0 and j >= 0:\n        if nums1[i] > nums2[j]:\n            nums1[k] = nums1[i]; i -= 1\n        else:\n            nums1[k] = nums2[j]; j -= 1\n        k -= 1\n    while j >= 0:\n        nums1[k] = nums2[j]; j -= 1; k -= 1"
              },
              "javascript": {
                "bruteForce": "function mergeBrute(nums1, m, nums2, n) {\n    for (let i = 0; i < n; i++) nums1[m + i] = nums2[i];\n    nums1.sort((a,b)=>a-b);\n}",
                "optimal": "function mergeOptimal(nums1, m, nums2, n) {\n    let i = m - 1, j = n - 1, k = m + n - 1;\n    while (i >= 0 && j >= 0) {\n        nums1[k--] = nums1[i] > nums2[j] ? nums1[i--] : nums2[j--];\n    }\n    while (j >= 0) nums1[k--] = nums2[j--];\n}"
              },
              "java": {
                "bruteForce": "public void mergeBrute(int[] nums1, int m, int[] nums2, int n) {\n    for (int i = 0; i < n; i++) nums1[m + i] = nums2[i];\n    Arrays.sort(nums1);\n}",
                "optimal": "public void mergeOptimal(int[] nums1, int m, int[] nums2, int n) {\n    int i = m-1, j = n-1, k = m+n-1;\n    while (i >= 0 && j >= 0) {\n        nums1[k--] = (nums1[i] > nums2[j]) ? nums1[i--] : nums2[j--];\n    }\n    while (j >= 0) nums1[k--] = nums2[j--];\n}"
              },
              "cpp": {
                "bruteForce": "void mergeBrute(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n    for (int i = 0; i < n; i++) nums1[m + i] = nums2[i];\n    sort(nums1.begin(), nums1.end());\n}",
                "optimal": "void mergeOptimal(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n    int i = m - 1, j = n - 1, k = m + n - 1;\n    while (i >= 0 && j >= 0) {\n        nums1[k--] = (nums1[i] > nums2[j]) ? nums1[i--] : nums2[j--];\n    }\n    while (j >= 0) nums1[k--] = nums2[j--];\n}"
              }
            },
            "edgeCases": [
              {
                "title": "One array empty",
                "description": "m=0 or n=0.",
                "whyItBreaks": "Loops might not execute.",
                "howToFix": "The cleanup loop `while (j >= 0)` handles the n > 0 case when m=0 naturally."
              }
            ],
            "drills": [
              {
                "type": "invariant_id",
                "question": "Why do we merge from the END of the arrays when merging nums2 into nums1 in-place?",
                "options": [
                  "To avoid overwriting elements in nums1 that haven't been moved yet",
                  "It's faster",
                  "Because arrays are stored in reverse",
                  "To follow the Two Pointers pattern"
                ],
                "correctAnswer": "To avoid overwriting elements in nums1 that haven't been moved yet",
                "explanation": "If we started from the front, we might overwrite a value in nums1[0] that is needed later.",
                "category": "invariant"
              }
            ]
          },
          {
            "id": "palindrome_comp",
            "title": "Palindrome Comparison",
            "description": "Check if start and end characters are equal while moving inward.",
            "signals": [
              "Is Palindrome?",
              "Symmetry check",
              "String validation"
            ],
            "invariant": "s[l] == s[r] for all active l, r.",
            "formula": "if (s[l] != s[r]) return false",
            "templates": {
              "python": {
                "bruteForce": "def is_palindrome_brute(s):\n    filtered = [c.lower() for c in s if c.isalnum()]\n    return filtered == filtered[::-1]",
                "optimal": "def is_palindrome_optimal(s):\n    l, r = 0, len(s) - 1\n    while l < r:\n        if not s[l].isalnum(): l += 1\n        elif not s[r].isalnum(): r -= 1\n        elif s[l].lower() != s[r].lower(): return False\n        else: l += 1; r -= 1\n    return True"
              },
              "javascript": {
                "bruteForce": "function isPalindromeBrute(s) {\n    const clean = s.toLowerCase().replace(/[^a-z0-9]/g, '');\n    return clean === clean.split('').reverse().join('');\n}",
                "optimal": "function isPalindromeOptimal(s) {\n    let l = 0, r = s.length - 1;\n    while (l < r) {\n        if (!/[a-z0-9]/i.test(s[l])) l++;\n        else if (!/[a-z0-9]/i.test(s[r])) r--;\n        else if (s[l++].toLowerCase() !== s[r--].toLowerCase()) return false;\n    }\n    return true;\n}"
              },
              "java": {
                "bruteForce": "public boolean isPalindromeBrute(String s) {\n    StringBuilder sb = new StringBuilder();\n    for (char c : s.toCharArray()) {\n        if (Character.isLetterOrDigit(c)) sb.append(Character.toLowerCase(c));\n    }\n    return sb.toString().equals(sb.reverse().toString());\n}",
                "optimal": "public boolean isPalindromeOptimal(String s) {\n    int l = 0, r = s.length() - 1;\n    while (l < r) {\n        char currL = s.charAt(l), currR = s.charAt(r);\n        if (!Character.isLetterOrDigit(currL)) l++;\n        else if (!Character.isLetterOrDigit(currR)) r--;\n        else {\n            if (Character.toLowerCase(currL) != Character.toLowerCase(currR)) return false;\n            l++; r--;\n        }\n    }\n    return true;\n}"
              },
              "cpp": {
                "bruteForce": "bool isPalindromeBrute(string s) {\n    string clean = \"\";\n    for (char c : s) if (isalnum(c)) clean += tolower(c);\n    string rev = clean;\n    reverse(rev.begin(), rev.end());\n    return clean == rev;\n}",
                "optimal": "bool isPalindromeOptimal(string s) {\n    int l = 0, r = s.size() - 1;\n    while (l < r) {\n        if (!isalnum(s[l])) l++;\n        else if (!isalnum(s[r])) r--;\n        else if (tolower(s[l++]) != tolower(s[r--])) return false;\n    }\n    return true;\n}"
              }
            },
            "edgeCases": [
              {
                "title": "Special Characters Only",
                "description": "String like '..,!'",
                "whyItBreaks": "Loop must skip all characters correctly.",
                "howToFix": "Correctly implement isalnum checks before comparing."
              }
            ],
            "drills": [
              {
                "type": "movement_prediction",
                "question": "If s[left] is not alphanumeric, what happens?",
                "options": [
                  "Return False",
                  "Move Left pointer forward",
                  "Move Right pointer backward",
                  "Swap Left and Right"
                ],
                "correctAnswer": "Move Left pointer forward",
                "explanation": "We ignore non-alphanumeric characters by skipping them.",
                "category": "movement"
              }
            ]
          }
        ],
        "recognitionSignals": [
          "Sum pair in sorted data",
          "Cycle detection in Linked Lists",
          "In-place array manipulation",
          "Searching in a two-ended range"
        ],
        "formulaPattern": "left++, right-- (convergence) or slow++, fast++ (speed difference)",
        "commonMistakes": [
          "Not sorting the array for target sum problems",
          "Incorrect termination conditions (off-by-one)",
          "Not skipping duplicates in K-Sum patterns"
        ]
      },
      {
        "id": "sliding_window",
        "title": "Sliding Window",
        "family": "Core Patterns",
        "difficulty": "Adept",
        "description": "Efficiently handle contiguous subarray problems by maintaining a dynamic window.",
        "definition": "A technique that converts nested loops into a single loop by maintaining a window that slides over the data.",
        "mentalModel": {
          "analogy": "The Digital Frame",
          "analogyImage": "camera_frame_sliding",
          "realWorldExample": "Taking a panoramic photo or finding the best crop in a video timeline.",
          "coreInsight": "Reusing the overlap! When we slide the window by 1, we don't need to recalculate the sum of the intersection. We just subtract the element leaving and add the element entering.",
          "problemStatement": {
            "definition": "Find the maximum sum of any contiguous subarray of size K in a given array.",
            "returnValue": "The maximum sum value.",
            "constraints": [
              "Subarray must be contiguous",
              "Fixed window size K",
              "Linear time complexity O(N)"
            ]
          },
          "efficiencyComparison": {
            "bruteForce": "O(N \u00d7 K)",
            "optimal": "O(N)",
            "gain": "85%"
          }
        },
        "whatItIs": "Optimizing subarray queries by maintaining a dynamic window state.",
        "coreInvariant": "The window represents a contiguous subarray. For fixed size, it is always length K. For variable size, it is the largest/smallest subarray satisfying the condition.",
        "timeComplexity": [
          {
            "operation": "Fixed Window Scan",
            "time": "O(N)",
            "space": "O(1)"
          },
          {
            "operation": "Variable Window Search",
            "time": "O(N)",
            "space": "O(1)"
          }
        ],
        "visualizerType": "sliding_window",
        "relatedProblems": [
          3,
          76
        ],
        "subPatterns": [
          {
            "id": "fixed_window",
            "title": "Fixed Size Window",
            "description": "Window size K is constant throughout the traversal.",
            "signals": [
              "Subarray of fixed length K",
              "Max/Min/Avg sum of K elements"
            ],
            "invariant": "right - left + 1 == K",
            "formula": "NewSum = OldSum - arr[left-1] + arr[right]",
            "mistakes": [
              "Recomputing sum from scratch inside loop",
              "Incorrectly calculating width as right - left",
              "Off-by-one in window initialization"
            ],
            "edgeCases": [
              {
                "title": "K > Array Length",
                "description": "The window size K is larger than the total elements in the array.",
                "whyItBreaks": "Standard loops might access out of bounds or never execute.",
                "howToFix": "Add early exit: if (k > nums.length) return 0;"
              },
              {
                "title": "K = 0 or K = 1",
                "description": "Minimum possible window sizes.",
                "whyItBreaks": "Logic might subtract from empty window or fail to enter loop.",
                "howToFix": "Ensure constraints handle K >= 1; special case K=1 as a simple pass."
              }
            ],
            "drills": [
              {
                "type": "movement_prediction",
                "question": "Array: [2, 5, 1, 8, 2], K=3. Current sum=8 (indices 0-2). After sliding right by one, what is the new sum?",
                "options": [
                  "12",
                  "14",
                  "15",
                  "11"
                ],
                "correctAnswer": "14",
                "explanation": "New sum = OldSum - nums[left] + nums[right+1] = 8 - 2 + 8 = 14.",
                "category": "movement"
              },
              {
                "type": "invariant_id",
                "question": "Which invariant is strictly maintained in a Fixed Window?",
                "options": [
                  "Sum <= Target",
                  "Right - Left + 1 == K",
                  "Distinct Counts <= K",
                  "Left < Right"
                ],
                "correctAnswer": "Right - Left + 1 == K",
                "explanation": "Fixed window size ensures the distance between pointers is always K.",
                "category": "invariant"
              },
              {
                "type": "complexity",
                "question": "What is the time complexity of the Optimal Fixed Window approach?",
                "options": [
                  "O(N*K)",
                  "O(N^2)",
                  "O(N)",
                  "O(K)"
                ],
                "correctAnswer": "O(N)",
                "explanation": "Each element is processed exactly once as it enters and leaves the window.",
                "category": "complexity"
              }
            ],
            "templates": {
              "python": {
                "bruteForce": "def max_sum_brute(nums, k):\n    max_s = 0\n    for i in range(len(nums) - k + 1):\n        curr = 0\n        for j in range(i, i + k):\n            curr += nums[j]\n        max_s = max(max_s, curr)\n    return max_s",
                "optimal": "def max_sum_optimal(nums, k):\n    if k > len(nums): return 0\n    curr = sum(nums[:k])\n    max_s = curr\n    for i in range(len(nums) - k):\n        curr = curr - nums[i] + nums[i + k]\n        max_s = max(max_s, curr)\n    return max_s"
              },
              "javascript": {
                "bruteForce": "function maxSumBrute(nums, k) {\n    let maxS = 0;\n    for (let i = 0; i <= nums.length - k; i++) {\n        let curr = 0;\n        for (let j = i; j < i + k; j++) curr += nums[j];\n        maxS = Math.max(maxS, curr);\n    }\n    return maxS;\n}",
                "optimal": "function maxSumOptimal(nums, k) {\n    if (k > nums.length) return 0;\n    let curr = 0;\n    for (let i = 0; i < k; i++) curr += nums[i];\n    let maxS = curr;\n    for (let i = k; i < nums.length; i++) {\n        curr += nums[i] - nums[i - k];\n        maxS = Math.max(maxS, curr);\n    }\n    return maxS;\n}"
              },
              "java": {
                "bruteForce": "public int maxSumBrute(int[] nums, int k) {\n    int maxS = 0;\n    for (int i = 0; i <= nums.length - k; i++) {\n        int curr = 0;\n        for (int j = i; j < i + k; j++) curr += nums[j];\n        maxS = Math.max(maxS, curr);\n    }\n    return maxS;\n}",
                "optimal": "public int maxSumOptimal(int[] nums, int k) {\n    int curr = 0;\n    for (int i = 0; i < k; i++) curr += nums[i];\n    int maxS = curr;\n    for (int i = k; i < nums.length; i++) {\n        curr += nums[i] - nums[i - k];\n        maxS = Math.max(maxS, curr);\n    }\n    return maxS;\n}"
              },
              "cpp": {
                "bruteForce": "int maxSumBrute(vector<int>& nums, int k) {\n    int maxS = 0;\n    for (int i = 0; i <= nums.size() - k; i++) {\n        int curr = 0;\n        for (int j = i; j < i + k; j++) curr += nums[j];\n        maxS = max(maxS, curr);\n    }\n    return maxS;\n}",
                "optimal": "int maxSumOptimal(vector<int>& nums, int k) {\n    int curr = 0;\n    for (int i = 0; i < k; i++) curr += nums[i];\n    int maxS = curr;\n    for (int i = k; i < nums.size(); i++) {\n        curr += nums[i] - nums[i - k];\n        maxS = max(maxS, curr);\n    }\n    return maxS;\n}"
              }
            }
          },
          {
            "id": "variable_window",
            "title": "Variable Size (Shrinkable)",
            "description": "Window expands until condition is met, then shrinks to optimize.",
            "signals": [
              "Longest/Shortest subarray",
              "Condition: Sum >= S",
              "Distinct characters <= K"
            ],
            "invariant": "Window shrinks from left while condition is satisfied.",
            "formula": "while (valid) { update_result; remove_left; }",
            "mistakes": [
              "Using 'if' instead of 'while' for shrinking",
              "Forgetting to update current state when removing left",
              "Incorrectly returning before processing all windows"
            ],
            "edgeCases": [
              {
                "title": "Condition Never Met",
                "description": "The target sum or condition is impossible to achieve given the input.",
                "whyItBreaks": "The inner while loop never executes, and minLen remains Infinity.",
                "howToFix": "Check if result was updated: return minLen === Infinity ? 0 : minLen;"
              }
            ],
            "drills": [
              {
                "type": "movement_prediction",
                "question": "Variable Window (Min Subarray Sum >= S): Array=[2,3,1,2,4,3], S=7. When right reaches index 4 (value 4), what happens to the left pointer?",
                "options": [
                  "Left stays at 0",
                  "Left stays at 2",
                  "Left moves from 0 up to 2",
                  "Left moves from 1 up to 3"
                ],
                "correctAnswer": "Left moves from 0 up to 2",
                "explanation": "At index 4, sum becomes 2+3+1+2+4=12. While sum >= 7: subtract inner. 12-2=10, 10-3=7, 7-1=6. So left moves to index 3.",
                "category": "movement"
              }
            ],
            "templates": {
              "python": {
                "bruteForce": "def min_len_brute(nums, s):\n    n = len(nums)\n    res = float('inf')\n    for i in range(n):\n        curr = 0\n        for j in range(i, n):\n            curr += nums[j]\n            if curr >= s:\n                res = min(res, j - i + 1)\n                break\n    return 0 if res == float('inf') else res",
                "optimal": "def min_len_optimal(nums, s):\n    l, total, res = 0, 0, float('inf')\n    for r in range(len(nums)):\n        total += nums[r]\n        while total >= s:\n            res = min(res, r - l + 1)\n            total -= nums[l]\n            l += 1\n    return 0 if res == float('inf') else res"
              },
              "javascript": {
                "bruteForce": "function minLenBrute(nums, s) {\n    let res = Infinity;\n    for (let i = 0; i < nums.length; i++) {\n        let curr = 0;\n        for (let j = i; j < nums.length; j++) {\n            curr += nums[j];\n            if (curr >= s) {\n                res = Math.min(res, j - i + 1);\n                break;\n            }\n        }\n    }\n    return res === Infinity ? 0 : res;\n}",
                "optimal": "function minLenOptimal(nums, s) {\n    let l = 0, total = 0, res = Infinity;\n    for (let r = 0; r < nums.length; r++) {\n        total += nums[r];\n        while (total >= s) {\n            res = Math.min(res, r - l + 1);\n            total -= nums[l++];\n        }\n    }\n    return res === Infinity ? 0 : res;\n}"
              },
              "java": {
                "bruteForce": "public int minLenBrute(int[] nums, int s) {\n    int res = Integer.MAX_VALUE;\n    for (int i = 0; i < nums.length; i++) {\n        int curr = 0;\n        for (int j = i; j < nums.length; j++) {\n            curr += nums[j];\n            if (curr >= s) { res = Math.min(res, j - i + 1); break; }\n        }\n    }\n    return res == Integer.MAX_VALUE ? 0 : res;\n}",
                "optimal": "public int minLenOptimal(int[] nums, int s) {\n    int l = 0, total = 0, res = Integer.MAX_VALUE;\n    for (int r = 0; r < nums.length; r++) {\n        total += nums[r];\n        while (total >= s) {\n            res = Math.min(res, r - l + 1);\n            total -= nums[l++];\n        }\n    }\n    return res == Integer.MAX_VALUE ? 0 : res;\n}"
              },
              "cpp": {
                "bruteForce": "int minLenBrute(vector<int>& nums, int s) {\n    int res = INT_MAX;\n    for (int i = 0; i < nums.size(); i++) {\n        int curr = 0;\n        for (int j = i; j < nums.size(); j++) {\n            curr += nums[j];\n            if (curr >= s) { res = min(res, j - i + 1); break; }\n        }\n    }\n    return res == INT_MAX ? 0 : res;\n}",
                "optimal": "int minLenOptimal(vector<int>& nums, int s) {\n    int l = 0, total = 0, res = INT_MAX;\n    for (int r = 0; r < nums.size(); r++) {\n        total += nums[r];\n        while (total >= s) {\n            res = min(res, r - l + 1);\n            total -= nums[l++];\n        }\n    }\n    return res == INT_MAX ? 0 : res;\n}"
              }
            }
          },
          {
            "id": "at_most_k",
            "title": "At Most K Pattern",
            "description": "Find number of subarrays with at most K valid elements.",
            "signals": [
              "Exactly K = AtMost(K) - AtMost(K-1)",
              "Number of subarrays",
              "Distinct elements count"
            ],
            "invariant": "Window maintains AT MOST K constraint.",
            "formula": "count += (right - left + 1)",
            "mistakes": [
              "Incorrectly counting subarrays (formula is length of valid window)",
              "Not handling K=0 case",
              "Missing the subtraction step for 'Exactly K' problems"
            ],
            "edgeCases": [
              {
                "title": "K = 0",
                "description": "Finding subarrays with at most 0 distinct elements.",
                "whyItBreaks": "Standard logic might fail to enter while loop or delete non-existent keys.",
                "howToFix": "Early exit if (k == 0) return 0;"
              }
            ],
            "drills": [
              {
                "type": "count_contribution",
                "question": "If common window is [left, right], how many subarrays ending AT right are added?",
                "options": [
                  "1",
                  "right-left",
                  "right-left+1",
                  "right"
                ],
                "correctAnswer": "right-left+1",
                "explanation": "Every index from left up to right can be a valid start for a subarray ending at right.",
                "category": "invariant"
              }
            ],
            "templates": {
              "python": {
                "bruteForce": "def at_most_brute(nums, k):\n    count = 0\n    for i in range(len(nums)):\n        s = set()\n        for j in range(i, len(nums)):\n            s.add(nums[j])\n            if len(s) <= k: count += 1\n            else: break\n    return count",
                "optimal": "def at_most_optimal(nums, k):\n    l, res, counts = 0, 0, {}\n    for r in range(len(nums)):\n        counts[nums[r]] = counts.get(nums[r], 0) + 1\n        while len(counts) > k:\n            counts[nums[l]] -= 1\n            if counts[nums[l]] == 0: del counts[nums[l]]\n            l += 1\n        res += (r - l + 1)\n    return res"
              },
              "javascript": {
                "bruteForce": "function atMostBrute(nums, k) {\n    let count = 0;\n    for (let i = 0; i < nums.length; i++) {\n        let s = new Set();\n        for (let j = i; j < nums.length; j++) {\n            s.add(nums[j]);\n            if (s.size <= k) count++;\n            else break;\n        }\n    }\n    return count;\n}",
                "optimal": "function atMostOptimal(nums, k) {\n    let l = 0, res = 0, map = new Map();\n    for (let r = 0; r < nums.length; r++) {\n        map.set(nums[r], (map.get(nums[r]) || 0) + 1);\n        while (map.size > k) {\n            map.set(nums[l], map.get(nums[l]) - 1);\n            if (map.get(nums[l]) === 0) map.delete(nums[l]);\n            l++;\n        }\n        res += (r - l + 1);\n    }\n    return res;\n}"
              },
              "java": {
                "bruteForce": "public int atMostBrute(int[] nums, int k) {\n    int count = 0;\n    for (int i = 0; i < nums.length; i++) {\n        Set<Integer> s = new HashSet<>();\n        for (int j = i; j < nums.length; j++) {\n            s.add(nums[j]);\n            if (s.size() <= k) count++;\n            else break;\n        }\n    }\n    return count;\n}",
                "optimal": "public int atMostOptimal(int[] nums, int k) {\n    int l = 0, res = 0;\n    Map<Integer, Integer> map = new HashMap<>();\n    for (int r = 0; r < nums.length; r++) {\n        map.put(nums[r], map.getOrDefault(nums[r], 0) + 1);\n        while (map.size() > k) {\n            map.put(nums[l], map.get(nums[l]) - 1);\n            if (map.get(nums[l]) == 0) map.remove(nums[l]);\n            l++;\n        }\n        res += (r - l + 1);\n    }\n    return res;\n}"
              },
              "cpp": {
                "bruteForce": "int atMostBrute(vector<int>& nums, int k) {\n    int count = 0;\n    for (int i = 0; i < nums.size(); i++) {\n        unordered_set<int> s;\n        for (int j = i; j < nums.size(); j++) {\n            s.insert(nums[j]);\n            if (s.size() <= k) count++;\n            else break;\n        }\n    }\n    return count;\n}",
                "optimal": "int atMostOptimal(vector<int>& nums, int k) {\n    int l = 0, res = 0;\n    unordered_map<int, int> mp;\n    for (int r = 0; r < nums.size(); r++) {\n        mp[nums[r]]++;\n        while (mp.size() > k) {\n            if (--mp[nums[l]] == 0) mp.erase(nums[l]);\n            l++;\n        }\n        res += (r - l + 1);\n    }\n    return res;\n}"
              }
            }
          },
          {
            "id": "exact_k",
            "title": "Exact K Strategy",
            "description": "Calculate logic for exactly K by subtracting AtMost(K-1) from AtMost(K).",
            "signals": [
              "Exactly K distinct elements",
              "Exactly K total sum"
            ],
            "invariant": "Exactly(K) = AtMost(K) - AtMost(K-1)",
            "formula": "res = solve(K) - solve(K-1)",
            "mistakes": [
              "Trying to solve 'Exactly K' directly with one loop (leads to complex logic)",
              "Not checking if K=0",
              "Off-by-one in the K-1 call"
            ],
            "edgeCases": [
              {
                "title": "K = 1",
                "description": "Finding subarrays with exactly 1 distinct element.",
                "whyItBreaks": "AtMost(0) would return 0, making result equal to AtMost(1).",
                "howToFix": "Standard Exactly formula handles K=1 correctly as long as AtMost(0) is implemented robustly."
              }
            ],
            "drills": [
              {
                "type": "invariant_id",
                "question": "What is the primary relationship used to solve Exact K problems?",
                "options": [
                  "AtMost(K) + AtMost(K-1)",
                  "AtMost(K) - AtMost(K-1)",
                  "AtMost(K) * 2",
                  "AtMost(K) / 2"
                ],
                "correctAnswer": "AtMost(K) - AtMost(K-1)",
                "explanation": "This identity removes all subarrays with fewer than K elements, leaving only those with exactly K.",
                "category": "invariant"
              }
            ],
            "templates": {
              "python": {
                "bruteForce": "def exactly_k_brute(nums, k):\n    count = 0\n    for i in range(len(nums)):\n        s = set()\n        for j in range(i, len(nums)):\n            s.add(nums[j])\n            if len(s) == k: count += 1\n            elif len(s) > k: break\n    return count",
                "optimal": "def exactly_k_optimal(nums, k):\n    return at_most_k(nums, k) - at_most_k(nums, k - 1)"
              },
              "javascript": {
                "bruteForce": "function exactlyKBrute(nums, k) {\n    let count = 0;\n    for (let i = 0; i < nums.length; i++) {\n        let s = new Set();\n        for (let j = i; j < nums.length; j++) {\n            s.add(nums[j]);\n            if (s.size === k) count++;\n            else if (s.size > k) break;\n        }\n    }\n    return count;\n}",
                "optimal": "function exactlyKOptimal(nums, k) {\n    return atMostK(nums, k) - atMostK(nums, k - 1);\n}"
              },
              "java": {
                "bruteForce": "public int exactlyKBrute(int[] nums, int k) {\n    int count = 0;\n    for (int i = 0; i < nums.length; i++) {\n        Set<Integer> s = new HashSet<>();\n        for (int j = i; j < nums.length; j++) {\n            s.add(nums[j]);\n            if (s.size() == k) count++;\n            else if (s.size() > k) break;\n        }\n    }\n    return count;\n}",
                "optimal": "public int exactlyKOptimal(int[] nums, int k) {\n    return atMostK(nums, k) - atMostK(nums, k - 1);\n}"
              },
              "cpp": {
                "bruteForce": "int exactlyKBrute(vector<int>& nums, int k) {\n    int count = 0;\n    for (int i = 0; i < nums.size(); i++) {\n        unordered_set<int> s;\n        for (int j = i; j < nums.size(); j++) {\n            s.insert(nums[j]);\n            if (s.size() == k) count++;\n            else if (s.size() > k) break;\n        }\n    }\n    return count;\n}",
                "optimal": "int exactlyKOptimal(vector<int>& nums, int k) {\n    return atMostK(nums, k) - atMostK(nums, k - 1);\n}"
              }
            }
          },
          {
            "id": "longest_valid",
            "title": "Longest Valid Window",
            "description": "Find the maximum length r-l+1 where condition holds.",
            "signals": [
              "Max length",
              "Longest substring",
              "Condition constraint"
            ],
            "invariant": "Update result AFTER ensuring window is valid.",
            "formula": "max_len = max(max_len, r - l + 1)",
            "mistakes": [
              "Updating max_len inside the while loop instead of after it",
              "Initial max_len set to 0 vs -1",
              "Off-by-one in length calculation"
            ],
            "edgeCases": [
              {
                "title": "K = 0",
                "description": "Finding longest window with 0 distinct elements.",
                "whyItBreaks": "Loop might not execute or result stays at 0.",
                "howToFix": "Early exit or ensure logic handles empty results."
              }
            ],
            "drills": [
              {
                "type": "movement_prediction",
                "question": "In 'Longest Valid Window', when is our 'maxLength' updated?",
                "options": [
                  "Whenever right moves",
                  "Inside the while loop as we shrink",
                  "After the while loop ensures the window is valid",
                  "Only at the end of the program"
                ],
                "correctAnswer": "After the while loop ensures the window is valid",
                "explanation": "We only record the length once the current window [left, right] satisfies the constraint.",
                "category": "movement"
              }
            ],
            "templates": {
              "python": {
                "bruteForce": "def longest_brute(s, k):\n    max_l = 0\n    for i in range(len(s)):\n        counts = {}\n        for j in range(i, len(s)):\n            counts[s[j]] = counts.get(s[j], 0) + 1\n            if len(counts) <= k:\n                max_l = max(max_l, j - i + 1)\n            else: break\n    return max_l",
                "optimal": "def longest_optimal(s, k):\n    l, max_l, counts = 0, 0, {}\n    for r in range(len(s)):\n        counts[s[r]] = counts.get(s[r], 0) + 1\n        while len(counts) > k:\n            counts[s[l]] -= 1\n            if counts[s[l]] == 0: del counts[s[l]]\n            l += 1\n        max_l = max(max_l, r - l + 1)\n    return max_l"
              },
              "javascript": {
                "bruteForce": "function longestBrute(s, k) {\n    let maxL = 0;\n    for (let i = 0; i < s.length; i++) {\n        let map = new Map();\n        for (let j = i; j < s.length; j++) {\n            map.set(s[j], (map.get(s[j]) || 0) + 1);\n            if (map.size <= k) maxL = Math.max(maxL, j - i + 1);\n            else break;\n        }\n    }\n    return maxL;\n}",
                "optimal": "function longestOptimal(s, k) {\n    let l = 0, maxL = 0, map = new Map();\n    for (let r = 0; r < s.length; r++) {\n        map.set(s[r], (map.get(s[r]) || 0) + 1);\n        while (map.size > k) {\n            map.set(s[l], map.get(s[l]) - 1);\n            if (map.get(s[l]) === 0) map.delete(s[l]);\n            l++;\n        }\n        maxL = Math.max(maxL, r - l + 1);\n    }\n    return maxL;\n}"
              },
              "java": {
                "bruteForce": "public int longestBrute(String s, int k) {\n    int maxL = 0;\n    for (int i = 0; i < s.length(); i++) {\n        Map<Character, Integer> map = new HashMap<>();\n        for (int j = i; j < s.length(); j++) {\n            char c = s.charAt(j);\n            map.put(c, map.getOrDefault(c, 0) + 1);\n            if (map.size() <= k) maxL = Math.max(maxL, j - i + 1);\n            else break;\n        }\n    }\n    return maxL;\n}",
                "optimal": "public int longestOptimal(String s, int k) {\n    int l = 0, maxL = 0;\n    Map<Character, Integer> map = new HashMap<>();\n    for (int r = 0; r < s.length(); r++) {\n        char c = s.charAt(r);\n        map.put(c, map.getOrDefault(c, 0) + 1);\n        while (map.size() > k) {\n            char leftChar = s.charAt(l);\n            map.put(leftChar, map.get(leftChar) - 1);\n            if (map.get(leftChar) == 0) map.remove(leftChar);\n            l++;\n        }\n        maxL = Math.max(maxL, r - l + 1);\n    }\n    return maxL;\n}"
              },
              "cpp": {
                "bruteForce": "int longestBrute(string s, int k) {\n    int maxL = 0;\n    for (int i = 0; i < s.size(); i++) {\n        unordered_map<char, int> map;\n        for (int j = i; j < s.size(); j++) {\n            map[s[j]]++;\n            if (map.size() <= k) maxL = max(maxL, j - i + 1);\n            else break;\n        }\n    }\n    return maxL;\n}",
                "optimal": "int longestOptimal(string s, int k) {\n    int l = 0, maxL = 0;\n    unordered_map<char, int> map;\n    for (int r = 0; r < s.size(); r++) {\n        map[s[r]]++;\n        while (map.size() > k) {\n            if (--map[s[l]] == 0) map.erase(s[l]);\n            l++;\n        }\n        maxL = max(maxL, r - l + 1);\n    }\n    return maxL;\n}"
              }
            }
          },
          {
            "id": "minimum_valid",
            "title": "Minimum Valid Window",
            "description": "Find the smallest r-l+1 that satisfies the condition.",
            "signals": [
              "Min length",
              "Shortest subarray",
              "Minimum window substring"
            ],
            "invariant": "Shrink until just BEFORE window becomes invalid.",
            "formula": "min_len = min(min_len, r - l + 1)",
            "mistakes": [
              "Not initializing min_len to a large enough value",
              "Failing to return 0/empty string if no solution exists",
              "Wrong shrink condition"
            ],
            "edgeCases": [
              {
                "title": "No solution",
                "description": "The target string 't' contains characters not in 's'.",
                "whyItBreaks": "Result length remains Infinity.",
                "howToFix": "Return empty string if resLen == Infinity."
              }
            ],
            "drills": [
              {
                "type": "complexity",
                "question": "What is the space complexity of Hard Minimum Window Substring using character frequencies?",
                "options": [
                  "O(1) - alphabet size is fixed",
                  "O(N)",
                  "O(T)",
                  "O(N+T)"
                ],
                "correctAnswer": "O(1) - alphabet size is fixed",
                "explanation": "Since there are a finite number of characters (e.g., 256 for ASCII), the frequency map size is bounded.",
                "category": "complexity"
              }
            ],
            "templates": {
              "python": {
                "bruteForce": "def min_window_brute(s, t):\n    from collections import Counter\n    target = Counter(t)\n    res = ''\n    min_l = float('inf')\n    for i in range(len(s)):\n        for j in range(i, len(s)):\n            window = Counter(s[i:j+1])\n            if all(window[c] >= target[c] for c in target):\n                if (j - i + 1) < min_l:\n                    min_l = j - i + 1\n                    res = s[i:j+1]\n    return res",
                "optimal": "def min_window_optimal(s, t):\n    from collections import Counter\n    need, have = Counter(t), Counter()\n    l, res, res_len = 0, [-1, -1], float('inf')\n    count, goal = 0, len(need)\n    for r in range(len(s)):\n        c = s[r]\n        have[c] += 1\n        if c in need and have[c] == need[c]: count += 1\n        while count == goal:\n            if (r - l + 1) < res_len:\n                res_len = (r - l + 1)\n                res = [l, r]\n            have[s[l]] -= 1\n            if s[l] in need and have[s[l]] < need[s[l]]: count -= 1\n            l += 1\n    l, r = res\n    return s[l:r+1] if res_len != float('inf') else ''"
              },
              "javascript": {
                "bruteForce": "function minWindowBrute(s, t) {\n    let minL = Infinity, res = '';\n    const isMatch = (win, target) => {\n        for (let char in target) if ((win[char] || 0) < target[char]) return false;\n        return true;\n    };\n    let target = {};\n    for (let c of t) target[c] = (target[c] || 0) + 1;\n    for (let i = 0; i < s.length; i++) {\n        for (let j = i; j < s.length; j++) {\n            let sub = s.substring(i, j+1);\n            let win = {};\n            for (let c of sub) win[c] = (win[c] || 0) + 1;\n            if (isMatch(win, target)) {\n                if (j - i + 1 < minL) {\n                    minL = j - i + 1;\n                    res = sub;\n                }\n            }\n        }\n    }\n    return res;\n}",
                "optimal": "function minWindowOptimal(s, t) {\n    let need = {}, have = {}, l = 0, resLen = Infinity, res = [-1, -1];\n    for (let c of t) need[c] = (need[c] || 0) + 1;\n    let count = 0, goal = Object.keys(need).length;\n    for (let r = 0; r < s.length; r++) {\n        let c = s[r];\n        have[c] = (have[c] || 0) + 1;\n        if (need[c] && have[c] === need[c]) count++;\n        while (count === goal) {\n            if (r - l + 1 < resLen) {\n                resLen = r - l + 1;\n                res = [l, r];\n            }\n            let leftChar = s[l];\n            have[leftChar]--;\n            if (need[leftChar] && have[leftChar] < need[leftChar]) count--;\n            l++;\n        }\n    }\n    return resLen === Infinity ? '' : s.substring(res[0], res[1] + 1);\n}"
              },
              "java": {
                "bruteForce": "public String minWindowBrute(String s, String t) {\n    // Naive O(N^3) implementation for educational comparison\n    String res = \"\";\n    int minL = Integer.MAX_VALUE;\n    for (int i = 0; i < s.length(); i++) {\n        for (int j = i; j < s.length(); j++) {\n            String sub = s.substring(i, j + 1);\n            if (containsAll(sub, t)) {\n                if (sub.length() < minL) {\n                    minL = sub.length();\n                    res = sub;\n                }\n            }\n        }\n    }\n    return res;\n}",
                "optimal": "public String minWindowOptimal(String s, String t) {\n    Map<Character, Integer> need = new HashMap<>();\n    for (char c : t.toCharArray()) need.put(c, need.getOrDefault(c, 0) + 1);\n    Map<Character, Integer> have = new HashMap<>();\n    int l = 0, count = 0, goal = need.size(), resLen = Integer.MAX_VALUE;\n    int[] res = {-1, -1};\n    for (int r = 0; r < s.length(); r++) {\n        char c = s.charAt(r);\n        have.put(c, have.getOrDefault(c, 0) + 1);\n        if (need.containsKey(c) && have.get(c).equals(need.get(c))) count++;\n        while (count == goal) {\n            if (r - l + 1 < resLen) {\n                resLen = r - l + 1;\n                res[0] = l; res[1] = r;\n            }\n            char leftChar = s.charAt(l);\n            have.put(leftChar, have.get(leftChar) - 1);\n            if (need.containsKey(leftChar) && have.get(leftChar) < need.get(leftChar)) count--;\n            l++;\n        }\n    }\n    return resLen == Integer.MAX_VALUE ? \"\" : s.substring(res[0], res[1] + 1);\n}"
              },
              "cpp": {
                "bruteForce": "string minWindowBrute(string s, string t) {\n    string res = \"\";\n    int minL = INT_MAX;\n    for (int i = 0; i < s.size(); i++) {\n        for (int j = i; j < s.size(); j++) {\n            string sub = s.substr(i, j - i + 1);\n            if (isValid(sub, t)) {\n                if (sub.size() < minL) {\n                    minL = sub.size();\n                    res = sub;\n                }\n            }\n        }\n    }\n    return res;\n}",
                "optimal": "string minWindowOptimal(string s, string t) {\n    unordered_map<char, int> need, have;\n    for (char c : t) need[c]++;\n    int l = 0, count = 0, goal = need.size(), resLen = INT_MAX, resIdx = -1;\n    for (int r = 0; r < s.size(); r++) {\n        char c = s[r];\n        have[c]++;\n        if (need.count(c) && have[c] == need[c]) count++;\n        while (count == goal) {\n            if (r - l + 1 < resLen) {\n                resLen = r - l + 1;\n                resIdx = l;\n            }\n            char leftChar = s[l];\n            if (need.count(leftChar) && have[leftChar] == need[leftChar]) count--;\n            have[leftChar]--;\n            l++;\n        }\n    }\n    return resLen == INT_MAX ? \"\" : s.substr(resIdx, resLen);\n}"
              }
            }
          }
        ],
        "recognitionSignals": [
          "Contiguous subarray/substring tasks",
          "Finding Optimal Range (Max/Min)",
          "Constraint on subarray sum or elements"
        ],
        "formulaPattern": "expand(right); while(invalid) { shrink(left); } updateResult();",
        "commonMistakes": [
          "Not identifying the correct shrink condition",
          "Off-by-one errors in length calculations (r-l+1 vs r-l)",
          "Inefficiently recalculating window state instead of O(1) update"
        ]
      },
      {
        "id": "binary_search",
        "title": "Binary Search",
        "family": "Core Patterns",
        "difficulty": "Adept",
        "description": "Divide search space in half at each step to find elements in O(log N).",
        "definition": "The most efficient way to find an item in a sorted collection by repeatedly halving the search space.",
        "mentalModel": {
          "analogy": "The Phone Book Search",
          "analogyImage": "binary_search_analogy",
          "realWorldExample": "Opening a physical book to the middle and moving left or right to find a specific page.",
          "coreInsight": "Sorted data allows us to eliminate 50% of the remaining search space every time we make one comparison.",
          "problemStatement": {
            "definition": "Given a sorted array and a target value, return the index if found, else -1.",
            "returnValue": "Index (Integer) or -1",
            "constraints": [
              "Input MUST be sorted",
              "Access must be O(1) (Random Access)",
              "Time complexity O(log N)"
            ]
          },
          "efficiencyComparison": {
            "bruteForce": "O(N) - Linear Search",
            "optimal": "O(log N)",
            "gain": "99% for large datasets"
          }
        },
        "whatItIs": "An elimination strategy that narrows a range [low, high] until the target is found or the range is empty.",
        "coreInvariant": "The target, if it exists, is always within the current [low, high] bounds.",
        "timeComplexity": [
          {
            "operation": "Search",
            "time": "O(log N)",
            "space": "O(1) Iterative / O(log N) Recursive"
          }
        ],
        "visualizerType": "binary_search",
        "relatedProblems": [
          4,
          33,
          74
        ],
        "subPatterns": [
          {
            "id": "iterative_standard",
            "title": "Iterative Standard",
            "description": "The memory-efficient implementation using a while loop.",
            "signals": [
              "Find specific element",
              "Sorted array provided",
              "Zero extra space required"
            ],
            "invariant": "low <= high",
            "formula": "mid = low + (high - low) // 2",
            "mistakes": [
              "Using (low+high)/2 (overflow risk)",
              "Infinite loop due to wrong bound adjustment (low=mid instead of low=mid+1)",
              "Wrong condition (low < high misses the last element)"
            ],
            "edgeCases": [
              {
                "title": "Empty Array",
                "description": "Input array has length 0.",
                "whyItBreaks": "Accessing index 0 or r = -1 logic.",
                "howToFix": "Handle length 0 check or ensure loop condition handles l > r immediately."
              },
              {
                "title": "Target Not Found",
                "description": "Target is not in the array.",
                "whyItBreaks": "Loop finishes without returning.",
                "howToFix": "Return -1 after the loop."
              }
            ],
            "drills": [
              {
                "type": "invariant_id",
                "question": "What is the correct while loop condition for standard binary search?",
                "options": [
                  "low < high",
                  "low <= high",
                  "low + 1 < high",
                  "low != high"
                ],
                "correctAnswer": "low <= high",
                "explanation": "We must allow low == high to check the final element of a length-1 search space.",
                "category": "invariant"
              }
            ],
            "templates": {
              "python": {
                "bruteForce": "def binary_search_brute(nums, target):\n    # O(N) Linear Search\n    for i in range(len(nums)):\n        if nums[i] == target: return i\n    return -1",
                "optimal": "def binary_search_optimal(nums, target):\n    l, r = 0, len(nums) - 1\n    while l <= r:\n        mid = l + (r - l) // 2\n        if nums[mid] == target: return mid\n        if nums[mid] < target: l = mid + 1\n        else: r = mid - 1\n    return -1"
              },
              "javascript": {
                "bruteForce": "function binarySearchBrute(nums, target) {\n    for (let i = 0; i < nums.length; i++) {\n        if (nums[i] === target) return i;\n    }\n    return -1;\n}",
                "optimal": "function binarySearchOptimal(nums, target) {\n    let l = 0, r = nums.length - 1;\n    while (l <= r) {\n        let mid = l + Math.floor((r - l) / 2);\n        if (nums[mid] === target) return mid;\n        nums[mid] < target ? l = mid + 1 : r = mid - 1;\n    }\n    return -1;\n}"
              },
              "java": {
                "bruteForce": "public int binarySearchBrute(int[] nums, int target) {\n    for (int i = 0; i < nums.length; i++) {\n        if (nums[i] == target) return i;\n    }\n    return -1;\n}",
                "optimal": "public int binarySearchOptimal(int[] nums, int target) {\n    int l = 0, r = nums.length - 1;\n    while (l <= r) {\n        int mid = l + (r - l) / 2;\n        if (nums[mid] == target) return mid;\n        if (nums[mid] < target) l = mid + 1;\n        else r = mid - 1;\n    }\n    return -1;\n}"
              },
              "cpp": {
                "bruteForce": "int binarySearchBrute(vector<int>& nums, int target) {\n    for (int i = 0; i < nums.size(); i++) {\n        if (nums[i] == target) return i;\n    }\n    return -1;\n}",
                "optimal": "int binarySearchOptimal(vector<int>& nums, int target) {\n    int l = 0, r = nums.size() - 1;\n    while (l <= r) {\n        int mid = l + (r - l) / 2;\n        if (nums[mid] == target) return mid;\n        if (nums[mid] < target) l = mid + 1;\n        else r = mid - 1;\n    }\n    return -1;\n}"
              }
            }
          },
          {
            "id": "recursive_bs",
            "title": "Recursive Implementation",
            "description": "A divide-and-conquer approach using function calls.",
            "signals": [
              "Tree traversals",
              "Divide and conquer structures",
              "Functional programming style"
            ],
            "invariant": "Base case: low > high",
            "formula": "return solve(low, mid-1) or solve(mid+1, high)",
            "edgeCases": [
              {
                "title": "Recursion Depth Limit",
                "description": "Very large N can theoretically cause stack overflow.",
                "whyItBreaks": "Recursion uses stack frames.",
                "howToFix": "Use iterative approach for extremely large inputs or tail call optimization if supported."
              }
            ],
            "drills": [
              {
                "type": "complexity",
                "question": "What is the space complexity of recursive binary search?",
                "options": [
                  "O(1)",
                  "O(log N)",
                  "O(N)",
                  "O(N log N)"
                ],
                "correctAnswer": "O(log N)",
                "explanation": "Each recursive call adds a frame to the stack. Depth is log N.",
                "category": "complexity"
              }
            ],
            "templates": {
              "python": {
                "bruteForce": "def search_brute(nums, target):\n    # Recursion logic for linear search\n    def rec(i):\n        if i >= len(nums): return -1\n        if nums[i] == target: return i\n        return rec(i + 1)\n    return rec(0)",
                "optimal": "def search_optimal(nums, target, l, r):\n    if l > r: return -1\n    mid = l + (r - l) // 2\n    if nums[mid] == target: return mid\n    if nums[mid] < target: return search_optimal(nums, target, mid + 1, r)\n    return search_optimal(nums, target, l, mid - 1)"
              },
              "javascript": {
                "bruteForce": "function searchBrute(nums, target) {\n    const rec = (i) => {\n        if (i >= nums.length) return -1;\n        if (nums[i] === target) return i;\n        return rec(i + 1);\n    };\n    return rec(0);\n}",
                "optimal": "function searchOptimal(nums, target, l, r) {\n    if (l > r) return -1;\n    let mid = l + Math.floor((r - l) / 2);\n    if (nums[mid] === target) return mid;\n    return nums[mid] < target ? searchOptimal(nums, target, mid + 1, r) : searchOptimal(nums, target, l, mid - 1);\n}"
              },
              "java": {
                "bruteForce": "public int searchBrute(int[] nums, int target) {\n    return searchLin(nums, target, 0);\n}\nprivate int searchLin(int[] nums, int target, int i) {\n    if (i >= nums.length) return -1;\n    if (nums[i] == target) return i;\n    return searchLin(nums, target, i + 1);\n}",
                "optimal": "public int searchOptimal(int[] nums, int target, int l, int r) {\n    if (l > r) return -1;\n    int mid = l + (r - l) / 2;\n    if (nums[mid] == target) return mid;\n    if (nums[mid] < target) return searchOptimal(nums, target, mid + 1, r);\n    return searchOptimal(nums, target, l, mid - 1);\n}"
              },
              "cpp": {
                "bruteForce": "int searchBrute(vector<int>& nums, int target, int i = 0) {\n    if (i >= nums.size()) return -1;\n    if (nums[i] == target) return i;\n    return searchBrute(nums, target, i + 1);\n}",
                "optimal": "int searchOptimal(vector<int>& nums, int target, int l, int r) {\n    if (l > r) return -1;\n    int mid = l + (r - l) / 2;\n    if (nums[mid] == target) return mid;\n    if (nums[mid] < target) return searchOptimal(nums, target, mid + 1, r);\n    return searchOptimal(nums, target, l, mid - 1);\n}"
              }
            }
          },
          {
            "id": "find_leftmost",
            "title": "Foundational: Find Leftmost",
            "description": "Find the first occurrence of a duplicate element.",
            "signals": [
              "Duplicates in array",
              "Lower bound search",
              "Insertion index"
            ],
            "invariant": "Shrink right bound even when target is found.",
            "formula": "if (nums[mid] >= target) high = mid else low = mid + 1",
            "edgeCases": [
              {
                "title": "All Elements Same",
                "description": "Array contains only the target value [2, 2, 2].",
                "whyItBreaks": "Standard search stops at the middle.",
                "howToFix": "Continue searching LEFT (high = mid - 1) after finding target."
              }
            ],
            "drills": [
              {
                "type": "movement_prediction",
                "question": "In 'Find First/Leftmost', if nums[mid] == target, what do we do?",
                "options": [
                  "Return mid",
                  "Move right (low = mid + 1)",
                  "Move left (high = mid - 1)",
                  "Stop"
                ],
                "correctAnswer": "Move left (high = mid - 1)",
                "explanation": "We want the leftmost occurrence, so we record this position but continue checking the left half.",
                "category": "movement"
              }
            ],
            "templates": {
              "python": {
                "bruteForce": "def find_first_brute(nums, target):\n    for i in range(len(nums)):\n        if nums[i] == target: return i\n    return -1",
                "optimal": "def find_first_optimal(nums, target):\n    l, r, res = 0, len(nums) - 1, -1\n    while l <= r:\n        mid = l + (r - l) // 2\n        if nums[mid] == target:\n            res = mid; r = mid - 1\n        elif nums[mid] < target: l = mid + 1\n        else: r = mid - 1\n    return res"
              },
              "javascript": {
                "bruteForce": "function findFirstBrute(nums, target) {\n    return nums.indexOf(target);\n}",
                "optimal": "function findFirstOptimal(nums, target) {\n    let l = 0, r = nums.length - 1, res = -1;\n    while (l <= r) {\n        let mid = l + Math.floor((r - l) / 2);\n        if (nums[mid] === target) { res = mid; r = mid - 1; }\n        else if (nums[mid] < target) l = mid + 1;\n        else r = mid - 1;\n    }\n    return res;\n}"
              },
              "java": {
                "bruteForce": "public int findFirstBrute(int[] nums, int target) {\n    for (int i = 0; i < nums.length; i++) \n        if (nums[i] == target) return i;\n    return -1;\n}",
                "optimal": "public int findFirstOptimal(int[] nums, int target) {\n    int l = 0, r = nums.length - 1, res = -1;\n    while (l <= r) {\n        int mid = l + (r - l) / 2;\n        if (nums[mid] == target) { res = mid; r = mid - 1; }\n        else if (nums[mid] < target) l = mid + 1;\n        else r = mid - 1;\n    }\n    return res;\n}"
              },
              "cpp": {
                "bruteForce": "int findFirstBrute(vector<int>& nums, int target) {\n    for (int i = 0; i < nums.size(); i++) \n        if (nums[i] == target) return i;\n    return -1;\n}",
                "optimal": "int findFirstOptimal(vector<int>& nums, int target) {\n    int l = 0, r = nums.size() - 1, res = -1;\n    while (l <= r) {\n        int mid = l + (r - l) / 2;\n        if (nums[mid] == target) { res = mid; r = mid - 1; }\n        else if (nums[mid] < target) l = mid + 1;\n        else r = mid - 1;\n    }\n    return res;\n}"
              }
            }
          },
          {
            "id": "find_rightmost",
            "title": "Foundational: Find Rightmost",
            "description": "Find the last occurrence of a duplicate element.",
            "signals": [
              "Duplicates in array",
              "Upper bound search",
              "Finding range ends"
            ],
            "invariant": "Shrink left bound even when target is found.",
            "formula": "if (nums[mid] <= target) low = mid + 1 else high = mid - 1",
            "edgeCases": [
              {
                "title": "All Elements Same",
                "description": "Array contains only the target value [2, 2, 2].",
                "whyItBreaks": "Standard search stops at the middle.",
                "howToFix": "Continue searching RIGHT (low = mid + 1) after finding target."
              }
            ],
            "drills": [
              {
                "type": "movement_prediction",
                "question": "In 'Find Last/Rightmost', if nums[mid] == target, what do we do?",
                "options": [
                  "Return mid",
                  "Move right (low = mid + 1)",
                  "Move left (high = mid - 1)",
                  "Stop"
                ],
                "correctAnswer": "Move right (low = mid + 1)",
                "explanation": "We want the rightmost occurrence, so we record this position but continue checking the right half.",
                "category": "movement"
              }
            ],
            "templates": {
              "python": {
                "bruteForce": "def find_last_brute(nums, target):\n    res = -1\n    for i in range(len(nums)):\n        if nums[i] == target: res = i\n    return res",
                "optimal": "def find_last_optimal(nums, target):\n    l, r, res = 0, len(nums) - 1, -1\n    while l <= r:\n        mid = l + (r - l) // 2\n        if nums[mid] == target:\n            res = mid; l = mid + 1\n        elif nums[mid] < target: l = mid + 1\n        else: r = mid - 1\n    return res"
              },
              "javascript": {
                "bruteForce": "function findLastBrute(nums, target) {\n    return nums.lastIndexOf(target);\n}",
                "optimal": "function findLastOptimal(nums, target) {\n    let l = 0, r = nums.length - 1, res = -1;\n    while (l <= r) {\n        let mid = l + Math.floor((r - l) / 2);\n        if (nums[mid] === target) { res = mid; l = mid + 1; }\n        else if (nums[mid] < target) l = mid + 1;\n        else r = mid - 1;\n    }\n    return res;\n}"
              },
              "java": {
                "bruteForce": "public int findLastBrute(int[] nums, int target) {\n    for (int i = nums.length - 1; i >= 0; i--) \n        if (nums[i] == target) return i;\n    return -1;\n}",
                "optimal": "public int findLastOptimal(int[] nums, int target) {\n    int l = 0, r = nums.length - 1, res = -1;\n    while (l <= r) {\n        int mid = l + (r - l) / 2;\n        if (nums[mid] == target) { res = mid; l = mid + 1; }\n        else if (nums[mid] < target) l = mid + 1;\n        else r = mid - 1;\n    }\n    return res;\n}"
              },
              "cpp": {
                "bruteForce": "int findLastBrute(vector<int>& nums, int target) {\n    for (int i = nums.size() - 1; i >= 0; i--) \n        if (nums[i] == target) return i;\n    return -1;\n}",
                "optimal": "int findLastOptimal(vector<int>& nums, int target) {\n    int l = 0, r = nums.size() - 1, res = -1;\n    while (l <= r) {\n        int mid = l + (r-l) / 2;\n        if (nums[mid] == target) { res = mid; l = mid + 1; }\n        else if (nums[mid] < target) l = mid + 1;\n        else r = mid - 1;\n    }\n    return res;\n}"
              }
            }
          }
        ],
        "recognitionSignals": [
          "Input data is sorted",
          "Finding a specific value or range boundary",
          "Logarithmic time O(log N) required",
          "Search space is monotonic"
        ],
        "formulaPattern": "while (L <= R) { mid = L + (R-L)/2; ... }",
        "commonMistakes": [
          "Arithmetic overflow in mid calculation",
          "Infinite loops by not moving boundaries mid + 1 or mid - 1",
          "Confusing 'lower bound' logic with standard search"
        ],
        "edgeCases": [
          {
            "title": "Empty Array",
            "description": "Input array has no elements.",
            "whyItBreaks": "Accessing nums[0] or initialization fails.",
            "howToFix": "Early exit if (nums.length == 0)."
          },
          {
            "title": "Single Element",
            "description": "Array has exactly one element.",
            "whyItBreaks": "Low and High start and end at the same index.",
            "howToFix": "Ensure while condition is (low <= high)."
          }
        ],
        "microDrills": [
          {
            "question": "What is the time complexity of binary search on a sorted array of size N?",
            "options": [
              "O(1)",
              "O(log N)",
              "O(N)",
              "O(N log N)"
            ],
            "correctAnswer": "O(log N)"
          }
        ]
      },
      {
        "id": "monotonic_stack",
        "title": "Monotonic Stack",
        "family": "Core Patterns",
        "difficulty": "Adept",
        "description": "Maintain elements in a sorted order within a stack to solve 'Next Greater/Smaller' problems in O(N).",
        "definition": "A stack that maintains its elements in a specific order (increasing or decreasing) by popping elements that violate the order when a new element arrives.",
        "mentalModel": {
          "analogy": "The Line of Sight",
          "analogyImage": "monotonic_stack_analogy",
          "realWorldExample": "Standing in a line and looking forward: you can only see people taller than everyone between you and them.",
          "coreInsight": "Popping elements! When a new element comes, it 'removes' all elements that it 'dominates' (e.g., in Next Greater, a larger value makes previous smaller values irrelevant).",
          "problemStatement": {
            "definition": "For each element in an array, find the first element to its right that is greater than it.",
            "returnValue": "An array of the same size with the next greater values or -1.",
            "constraints": [
              "Linear time complexity O(N)",
              "Each element pushed and popped at most once",
              "Space complexity O(N)"
            ]
          },
          "efficiencyComparison": {
            "bruteForce": "O(N\u00b2) - Nested loops checking right",
            "optimal": "O(N)",
            "gain": "90% for sparse results"
          }
        },
        "whatItIs": "A data structure pattern that keeps elements sorted (monotonically) to find nearest neighbors with specific properties.",
        "coreInvariant": "Stack is always sorted. For Monotonic Increasing: Stack[i] < Stack[i+1].",
        "timeComplexity": [
          {
            "operation": "Single Pass Build",
            "time": "O(N)",
            "space": "O(N)"
          }
        ],
        "visualizerType": "monotonic_stack",
        "subPatterns": [
          {
            "id": "next_greater",
            "title": "Next Greater Element",
            "description": "Maintain a Monotonic Decreasing stack to find the first larger value on the right.",
            "signals": [
              "Find next larger",
              "Daily temperatures",
              "Nearest peak"
            ],
            "invariant": "Elements in stack are in decreasing order.",
            "formula": "while (stack and current > stack[-1]) { process(stack.pop()) }",
            "mistakes": [
              "Using increasing stack for Next Greater logic",
              "Stacking values instead of indices (indices are more versatile)",
              "Not initializing the result array with -1"
            ],
            "edgeCases": [
              {
                "title": "Strictly Decreasing Input",
                "description": "Array is sorted descending [5, 4, 3, 2, 1].",
                "whyItBreaks": "No element has a next greater.",
                "howToFix": "Ensure result array is initialized with -1."
              }
            ],
            "drills": [
              {
                "type": "invariant_id",
                "question": "To find the Next GREATER Element, what kind of Monotonic Stack do we need?",
                "options": [
                  "Monotonic Increasing (1, 2, 3)",
                  "Monotonic Decreasing (3, 2, 1)",
                  "Unsorted Stack",
                  "Queue"
                ],
                "correctAnswer": "Monotonic Decreasing (3, 2, 1)",
                "explanation": "We keep smaller elements in the stack waiting for a greater one. A decreasing stack means the top is the smallest 'waiting' candidate.",
                "category": "invariant"
              }
            ],
            "templates": {
              "python": {
                "bruteForce": "def next_greater_brute(nums):\n    res = [-1] * len(nums)\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if nums[j] > nums[i]:\n                res[i] = nums[j]\n                break\n    return res",
                "optimal": "def next_greater_optimal(nums):\n    res = [-1] * len(nums)\n    stack = []\n    for i in range(len(nums)):\n        while stack and nums[i] > nums[stack[-1]]:\n            idx = stack.pop()\n            res[idx] = nums[i]\n        stack.append(i)\n    return res"
              },
              "javascript": {
                "bruteForce": "function nextGreaterBrute(nums) {\n    let res = new Array(nums.length).fill(-1);\n    for (let i = 0; i < nums.length; i++) {\n        for (let j = i + 1; j < nums.length; j++) {\n            if (nums[j] > nums[i]) {\n                res[i] = nums[j];\n                break;\n            }\n        }\n    }\n    return res;\n}",
                "optimal": "function nextGreaterOptimal(nums) {\n    let res = new Array(nums.length).fill(-1);\n    let stack = [];\n    for (let i = 0; i < nums.length; i++) {\n        while (stack.length > 0 && nums[i] > nums[stack[stack.length - 1]]) {\n            let idx = stack.pop();\n            res[idx] = nums[i];\n        }\n        stack.push(i);\n    }\n    return res;\n}"
              },
              "java": {
                "bruteForce": "public int[] nextGreaterBrute(int[] nums) {\n    int[] res = new int[nums.length];\n    Arrays.fill(res, -1);\n    for (int i = 0; i < nums.length; i++) {\n        for (int j = i + 1; j < nums.length; j++) {\n            if (nums[j] > nums[i]) {\n                res[i] = nums[j];\n                break;\n            }\n        }\n    }\n    return res;\n}",
                "optimal": "public int[] nextGreaterOptimal(int[] nums) {\n    int[] res = new int[nums.length];\n    Arrays.fill(res, -1);\n    Stack<Integer> stack = new Stack<>();\n    for (int i = 0; i < nums.length; i++) {\n        while (!stack.isEmpty() && nums[i] > nums[stack.peek()]) {\n            res[stack.pop()] = nums[i];\n        }\n        stack.push(i);\n    }\n    return res;\n}"
              },
              "cpp": {
                "bruteForce": "vector<int> nextGreaterBrute(vector<int>& nums) {\n    vector<int> res(nums.size(), -1);\n    for (int i = 0; i < nums.size(); i++) {\n        for (int j = i + 1; j < nums.size(); j++) {\n            if (nums[j] > nums[i]) {\n                res[i] = nums[j];\n                break;\n            }\n        }\n    }\n    return res;\n}",
                "optimal": "vector<int> nextGreaterOptimal(vector<int>& nums) {\n    vector<int> res(nums.size(), -1);\n    stack<int> s;\n    for (int i = 0; i < nums.size(); i++) {\n        while (!s.empty() && nums[i] > nums[s.top()]) {\n            res[s.top()] = nums[i];\n            s.pop();\n        }\n        s.push(i);\n    }\n    return res;\n}"
              }
            }
          },
          {
            "id": "next_smaller",
            "title": "Next Smaller Element",
            "description": "Maintain a Monotonic Increasing stack to find the first smaller value on the right.",
            "signals": [
              "Find nearest valley",
              "Smallest element to the right",
              "Histogram boundaries"
            ],
            "invariant": "Elements in stack are in increasing order.",
            "formula": "while (stack and current < stack[-1]) { process(stack.pop()) }",
            "edgeCases": [
              {
                "title": "Strictly Increasing Input",
                "description": "Array is sorted ascending [1, 2, 3, 4, 5].",
                "whyItBreaks": "No element has a next smaller.",
                "howToFix": "Ensure result array is initialized with -1."
              }
            ],
            "drills": [
              {
                "type": "movement_prediction",
                "question": "If current element is SMALLER than stack top in Next Smaller problem, what do we do?",
                "options": [
                  "Push current",
                  "Pop top until stack empty or top < current",
                  "Pop top until stack empty or top > current",
                  "Do nothing"
                ],
                "correctAnswer": "Push current",
                "explanation": "Wait! If we want Next SMALLER, we need a MONOTONIC INCREASING stack. If current < top, we violated the increasing order, so we must POP the top because we found its next smaller (the current element).",
                "category": "movement"
              }
            ],
            "templates": {
              "python": {
                "bruteForce": "def next_smaller_brute(nums):\n    res = [-1] * len(nums)\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if nums[j] < nums[i]:\n                res[i] = nums[j]\n                break\n    return res",
                "optimal": "def next_smaller_optimal(nums):\n    res = [-1] * len(nums)\n    stack = []\n    for i in range(len(nums)):\n        while stack and nums[i] < nums[stack[-1]]:\n            idx = stack.pop()\n            res[idx] = nums[i]\n        stack.append(i)\n    return res"
              },
              "javascript": {
                "bruteForce": "function nextSmallerBrute(nums) {\n    let res = new Array(nums.length).fill(-1);\n    for (let i = 0; i < nums.length; i++) {\n        for (let j = i + 1; j < nums.length; j++) {\n            if (nums[j] < nums[i]) {\n                res[i] = nums[j];\n                break;\n            }\n        }\n    }\n    return res;\n}",
                "optimal": "function nextSmallerOptimal(nums) {\n    let res = new Array(nums.length).fill(-1);\n    let stack = [];\n    for (let i = 0; i < nums.length; i++) {\n        while (stack.length > 0 && nums[i] < nums[stack[stack.length - 1]]) {\n            res[stack.pop()] = nums[i];\n        }\n        stack.push(i);\n    }\n    return res;\n}"
              },
              "java": {
                "bruteForce": "public int[] nextSmallerBrute(int[] nums) {\n    int[] res = new int[nums.length];\n    Arrays.fill(res, -1);\n    for (int i = 0; i < nums.length; i++) {\n        for (int j = i + 1; j < nums.length; j++) {\n            if (nums[j] < nums[i]) {\n                res[i] = nums[j];\n                break;\n            }\n        }\n    }\n    return res;\n}",
                "optimal": "public int[] nextSmallerOptimal(int[] nums) {\n    int[] res = new int[nums.length];\n    Arrays.fill(res, -1);\n    Stack<Integer> s = new Stack<>();\n    for (int i = 0; i < nums.length; i++) {\n        while (!s.isEmpty() && nums[i] < nums[s.peek()]) res[s.pop()] = nums[i];\n        s.push(i);\n    }\n    return res;\n}"
              },
              "cpp": {
                "bruteForce": "vector<int> nextSmallerBrute(vector<int>& nums) {\n    vector<int> res(nums.size(), -1);\n    for (int i = 0; i < nums.size(); i++) {\n        for (int j = i + 1; j < nums.size(); j++) {\n            if (nums[j] < nums[i]) {\n                res[i] = nums[j];\n                break;\n            }\n        }\n    }\n    return res;\n}",
                "optimal": "vector<int> nextSmallerOptimal(vector<int>& nums) {\n    vector<int> res(nums.size(), -1);\n    stack<int> s;\n    for (int i = 0; i < nums.size(); i++) {\n        while (!s.empty() && nums[i] < nums[s.top()]) {\n            res[s.top()] = nums[i];\n            s.pop();\n        }\n        s.push(i);\n    }\n    return res;\n}"
              }
            }
          }
        ],
        "recognitionSignals": [
          "Needs price/value tracking to the right",
          "Finding nearest smaller or greater elements",
          "Standard O(N) requirement for range queries",
          "In-place processing of elements that violate an order"
        ],
        "formulaPattern": "Stack used to store indices; while (violations) { pop & process; } push current;",
        "commonMistakes": [
          "Confusing Increasing vs Decreasing stack order",
          "Storing values in stack instead of indices (harder to calculate distance)",
          "Not considering duplicates (need > or >=?)"
        ],
        "edgeCases": [
          {
            "title": "Strictly Decreasing/Increasing Input",
            "description": "Input is already in the order the stack wants to maintain.",
            "whyItBreaks": "No elements ever get popped until the end.",
            "howToFix": "Ensure result array is pre-filled with default value (e.g. -1)."
          },
          {
            "title": "Duplicates",
            "description": "Same values appear consecutively.",
            "whyItBreaks": "Determines if the next greater is STRICTLY greater.",
            "howToFix": "Use >= vs > depending on requirement."
          }
        ],
        "microDrills": [
          {
            "question": "In a Monotonic Increasing stack, what happens when we see an element LOWER than the top?",
            "options": [
              "Push it anyway",
              "Pop top until top < current",
              "Ignore the element",
              "Empty the stack"
            ],
            "correctAnswer": "Pop top until top < current"
          }
        ]
      },
      {
        "id": "cyclic_sort",
        "title": "Cyclic Sort",
        "family": "Core Patterns",
        "difficulty": "Adept",
        "description": "Sort numbers in range 1 to N in O(N) time with O(1) space.",
        "definition": "A pattern to sort arrays containing numbers in a given range by placing each number at its correct index.",
        "mentalModel": {
          "analogy": "The Assigned Seats",
          "analogyImage": "cyclic_sort_analogy",
          "realWorldExample": "Organizing a classroom where everyone has a numbered desk; if a student is at the wrong desk, you swap them with whoever is at their desk.",
          "coreInsight": "If we know the range is 1-N, we know exactly where each number SHOULD be (index = num - 1). We can sort by swapping in O(N)."
        },
        "visualizerType": "cyclic_sort",
        "coreInvariant": "After sorting, nums[i] == i + 1 (for 1-indexed range).",
        "subPatterns": [
          {
            "id": "find_missing",
            "title": "Find Missing Number",
            "description": "Identify the number missing from a range of 1..N.",
            "signals": [
              "Range 1..N",
              "One number missing",
              "O(N) time requirement"
            ],
            "invariant": "The index where nums[i] != i is the missing number.",
            "templates": {
              "python": "def find_missing(nums):\n    i = 0\n    while i < len(nums):\n        j = nums[i]\n        if nums[i] < len(nums) and nums[i] != nums[j]:\n            nums[i], nums[j] = nums[j], nums[i]\n        else: i += 1\n    for k in range(len(nums)):\n        if nums[k] != k: return k\n    return len(nums)",
              "javascript": "function findMissing(nums) {\n    let i = 0;\n    while (i < nums.length) {\n        let j = nums[i];\n        if (nums[i] < nums.length && nums[i] !== nums[j]) [nums[i], nums[j]] = [nums[j], nums[i]];\n        else i++;\n    }\n    for (let k = 0; k < nums.length; k++) if (nums[k] !== k) return k;\n    return nums.length;\n}"
            }
          },
          {
            "id": "find_duplicates",
            "title": "Find All Duplicates",
            "description": "Find all numbers that appear more than once.",
            "signals": [
              "Duplicate elements",
              "Space O(1) constraint"
            ],
            "invariant": "Duplicates will be found at indices they don't belong to."
          }
        ]
      },
      {
        "id": "merge_intervals",
        "title": "Merge Intervals",
        "family": "Core Patterns",
        "difficulty": "Adept",
        "description": "Handle overlapping time intervals or ranges in O(N log N).",
        "definition": "A pattern to resolve overlaps between intervals by sorting and merging.",
        "mentalModel": {
          "analogy": "The Calendar Merger",
          "analogyImage": "merge_intervals_analogy",
          "realWorldExample": "Merging back-to-back meetings into a single block of time.",
          "coreInsight": "Sorting by start time allows us to process intervals linearly. If the next interval starts before the current one ends, they overlap."
        },
        "visualizerType": "merge_intervals",
        "relatedProblems": [
          56
        ],
        "coreInvariant": "All intervals in the result are disjoint and sorted.",
        "subPatterns": [
          {
            "id": "standard_merge",
            "title": "Standard Merge",
            "description": "Merge all overlapping intervals into one.",
            "signals": [
              "Overlapping intervals",
              "Time ranges",
              "Combine periods"
            ],
            "invariant": "if (next.start <= current.end) current.end = max(current.end, next.end)",
            "templates": {
              "python": "def merge(intervals):\n    intervals.sort(key=lambda x: x[0])\n    res = [intervals[0]]\n    for start, end in intervals[1:]:\n        if start <= res[-1][1]: res[-1][1] = max(res[-1][1], end)\n        else: res.append([start, end])\n    return res"
            }
          },
          {
            "id": "insert_interval",
            "title": "Insert Interval",
            "description": "Insert a new interval into a sorted list and merge.",
            "signals": [
              "New interval",
              "Maintain sorted order"
            ]
          }
        ]
      },
      {
        "id": "greedy",
        "title": "Greedy Fundamentals",
        "family": "Core Patterns",
        "difficulty": "Adept",
        "description": "Make the local optimal choice at each step to find a global optimum.",
        "definition": "An algorithmic paradigm that builds up a solution piece by piece, always choosing the next piece that offers the most obvious and immediate benefit.",
        "mentalModel": {
          "analogy": "The Coin Collector",
          "analogyImage": "greedy_analogy",
          "realWorldExample": "Making change for an amount using the fewest coins possible (always take the largest coin less than the remaining amount).",
          "coreInsight": "Local optimization lead to global optimization for specific problem structures (Greedy Choice Property)."
        },
        "visualizerType": "greedy",
        "relatedProblems": [
          55
        ],
        "subPatterns": [
          {
            "id": "interval_scheduling",
            "title": "Interval Scheduling",
            "description": "Select maximum number of non-overlapping intervals.",
            "signals": [
              "Maximum number of tasks",
              "No overlaps allowed"
            ],
            "invariant": "Always pick the interval that ends earliest."
          },
          {
            "id": "huffman_coding",
            "title": "Huffman Coding",
            "description": "Lossless data compression using greedy tree construction.",
            "signals": [
              "Frequency based",
              "Optimal variable-length coding"
            ]
          }
        ]
      },
      {
        "id": "recursion",
        "title": "Recursion",
        "family": "Core Patterns",
        "difficulty": "Adept",
        "description": "Solve complex problems by breaking them into smaller instances of themselves.",
        "definition": "A method where the solution depends on solutions to smaller instances of the same problem.",
        "mentalModel": {
          "analogy": "The Russian Dolls",
          "analogyImage": "recursion_analogy",
          "realWorldExample": "Searching through a folder that contains subfolders; you search the folder by searching each of its subfolders in the same way.",
          "coreInsight": "Build a base case (to stop) and a recursive step (to move toward the base case)."
        },
        "visualizerType": "recursion",
        "relatedProblems": [
          94,
          98
        ],
        "subPatterns": [
          {
            "id": "tree_traversal",
            "title": "Tree Traversal",
            "description": "Visit all nodes in a tree using DFS logic.",
            "signals": [
              "Tree structure",
              "Exhaustive search"
            ]
          },
          {
            "id": "divide_and_conquer",
            "title": "Divide & Conquer",
            "description": "Break problem into independent subproblems (e.g. Merge Sort).",
            "signals": [
              "Independent halves",
              "Recursive merge logic"
            ]
          }
        ]
      },
      {
        "id": "backtracking",
        "title": "Backtracking",
        "family": "Core Patterns",
        "difficulty": "Adept",
        "description": "Incremental search for all (or some) solutions to a computational problem.",
        "definition": "A general algorithm for finding all solutions by abandoning candidates ('backtracking') as soon as it determines they cannot possibly be completed to a valid solution.",
        "mentalModel": {
          "analogy": "The Labyrinth Explorer",
          "analogyImage": "backtracking_analogy",
          "realWorldExample": "Solving a Sudoku puzzle; when you hit a dead end, you go back to the last empty square and try a different number.",
          "coreInsight": "Try one way. If it works, great! If not, UNDO the move and try another way. The 'undo' step is the key."
        },
        "visualizerType": "backtracking",
        "relatedProblems": [
          46,
          78,
          79
        ],
        "subPatterns": [
          {
            "id": "permutations",
            "title": "Permutations/Combinations",
            "description": "Generate all possible arrangements of a set.",
            "signals": [
              "All possible",
              "N! complexity",
              "Constraint choices"
            ],
            "templates": {
              "python": "def backtrack(curr):\n    if len(curr) == n: res.append(curr[:]); return\n    for i in range(n):\n        if used[i]: continue\n        used[i] = True\n        curr.append(nums[i])\n        backtrack(curr)\n        curr.pop()\n        used[i] = False"
            }
          },
          {
            "id": "subset_sum",
            "title": "Path Finding / Grid Search",
            "description": "Find path from start to end in a grid/graph.",
            "signals": [
              "Target path",
              "Grid with obstacles"
            ]
          }
        ]
      },
      {
        "id": "bfs",
        "title": "BFS (Layer Order)",
        "family": "Core Patterns",
        "difficulty": "Adept",
        "description": "Traverse graphs and trees layer by layer using a Queue.",
        "definition": "An algorithm for searching tree or graph data structures for shortest paths. It starts at the root and explores all neighbor nodes at the present depth prior to moving on to the nodes at the next depth level.",
        "mentalModel": {
          "analogy": "The Ripple in a Pond",
          "analogyImage": "bfs_analogy",
          "realWorldExample": "LinkedIn suggestions: Finding people 1 connection away, then 2, then 3.",
          "coreInsight": "Use a Queue to keep track of nodes to visit. The first node added is the first one processed, ensuring we explore level by level (Shortest Path in unweighted graphs)."
        },
        "visualizerType": "bfs",
        "relatedProblems": [
          102,
          133
        ],
        "subPatterns": [
          {
            "id": "level_order",
            "title": "Level Order Traversal",
            "description": "Process nodes one level at a time.",
            "signals": [
              "Tree levels",
              "Shortest path (unweighted)"
            ],
            "invariant": "Queue size at start of loop = number of nodes in current level."
          }
        ]
      },
      {
        "id": "dfs",
        "title": "DFS (Depth First)",
        "family": "Core Patterns",
        "difficulty": "Adept",
        "description": "Explore as far as possible along each branch before backtracking.",
        "definition": "An algorithm for traversing or searching tree or graph data structures by starting at the root and exploring as far as possible along each branch before backtracking.",
        "mentalModel": {
          "analogy": "The Deep Diver",
          "analogyImage": "dfs_analogy",
          "realWorldExample": "Solving a maze by following one path until you hit a wall, then turning back to the last fork.",
          "coreInsight": "Use a Stack (or Recursion) to go deep first. Great for connectivity and exhaustive search."
        },
        "visualizerType": "dfs",
        "subPatterns": [
          {
            "id": "path_finding",
            "title": "Path Existence",
            "description": "Check if a path exists between two nodes.",
            "signals": [
              "Is reachable?",
              "Connectivity"
            ],
            "invariant": "A visited set is mandatory to prevent infinite loops."
          }
        ]
      },
      {
        "id": "topological_sort",
        "title": "Topological Sort",
        "family": "Core Patterns",
        "difficulty": "Adept",
        "description": "Linear ordering of directed graph vertices for dependency management.",
        "definition": "A linear ordering s.t. for every edge u->v, u comes before v. Used for task scheduling with dependencies.",
        "mentalModel": {
          "analogy": "The University Pre-requisites",
          "analogyImage": "topological_sort_analogy",
          "realWorldExample": "Finding the order of courses to take where some courses require others as pre-requisites.",
          "coreInsight": "Keep track of 'in-degrees' (how many things must happen before me). If in-degree is 0, I can start. (Kahn's Algorithm)."
        },
        "visualizerType": "topological_sort",
        "subPatterns": [
          {
            "id": "kahns",
            "title": "Kahn's Algorithm (BFS)",
            "description": "Queue-based topological sort using in-degrees.",
            "signals": [
              "Directed Acyclic Graph (DAG)",
              "Order of operations"
            ],
            "invariant": "Nodes with 0 in-degree are ready to be added to the result."
          }
        ]
      },
      {
        "id": "union_find",
        "title": "Union Find (DSU)",
        "family": "Core Patterns",
        "difficulty": "Adept",
        "description": "Efficiently track and merge disjoint sets in O(\u03b1(N)).",
        "definition": "A data structure that tracks elements partitioned into disjoint subsets and provides near-constant time operations to merge sets and find representatives.",
        "mentalModel": {
          "analogy": "The Social Groups",
          "analogyImage": "union_find_analogy",
          "realWorldExample": "Merging friend circles; if Alice is friends with Bob, and Bob with Charlie, then Alice, Bob, and Charlie are in the same group.",
          "coreInsight": "Each element points to a 'parent'. If two elements share the same 'ultimate parent' (root), they are in the same set."
        },
        "visualizerType": "union_find",
        "subPatterns": [
          {
            "id": "path_compression",
            "title": "Path Compression",
            "description": "Flatten the tree structure whenever find() is called.",
            "signals": [
              "Efficiency optimization",
              "Avoid skewed trees"
            ],
            "invariant": "parent[i] = find(parent[i]) (recursive flattening)"
          }
        ]
      }
    ]
  },
  {
    "id": "advanced_patterns",
    "title": "Advanced Patterns",
    "description": "Complex strategies for high-performance algorithm design.",
    "icon": "Zap",
    "modules": [
      {
        "id": "dp_1d",
        "title": "Dynamic Programming (1D)",
        "family": "Advanced Patterns",
        "difficulty": "Expert",
        "description": "Optimization via subproblems (1D).",
        "definition": "Solving complex problems by breaking them down into simpler 1D subproblems and storing their results to avoid redundant calculations.",
        "mentalModel": {
          "analogy": "The Fibonacci Staircase",
          "analogyImage": "dp_1d_analogy",
          "realWorldExample": "Climbing stairs: To know how many ways to reach step N, you just need to know how many ways to reach step N-1 and N-2.",
          "coreInsight": "State + Recurrence. Identify the State (dp[i]) and how it relates to previous states (dp[i-1], etc.)."
        },
        "visualizerType": "dp_1d",
        "relatedProblems": [
          53,
          70,
          121,
          139,
          152
        ],
        "subPatterns": [
          {
            "id": "house_robber",
            "title": "Decision Making",
            "description": "Choice between two states (e.g. Rob or Skip).",
            "signals": [
              "Maximum profit",
              "Cannot pick adjacent"
            ],
            "invariant": "dp[i] = max(dp[i-1], nums[i] + dp[i-2])"
          },
          {
            "id": "knapsack_1d",
            "title": "1D Knapsack / Coin Change",
            "description": "Using 1D array to optimize space from 2D DP.",
            "signals": [
              "Fixed capacity",
              "Reusable items"
            ],
            "invariant": "Inner loop typically runs backwards to avoid using same element twice."
          }
        ]
      },
      {
        "id": "dp_2d",
        "title": "Dynamic Programming (2D)",
        "family": "Advanced Patterns",
        "difficulty": "Expert",
        "description": "Optimization via subproblems (2D Grid).",
        "definition": "Solving complex problems using a 2D grid/table for subproblems, often involving two strings or a grid search.",
        "mentalModel": {
          "analogy": "The Path across the Meadow",
          "analogyImage": "dp_2d_analogy",
          "realWorldExample": "Finding the shortest route from the top-left to the bottom-right of a city grid.",
          "coreInsight": "State depends on two variables, i and j. Mapping relationships between two sequences (LCS, Edit Distance)."
        },
        "visualizerType": "dp_2d",
        "subPatterns": [
          {
            "id": "lcs",
            "title": "Longest Common Subsequence",
            "description": "Compare two strings for common sequences.",
            "signals": [
              "Two strings",
              "Similarity metric"
            ],
            "invariant": "if (s1[i] == s2[j]) dp[i][j] = 1 + dp[i-1][j-1]"
          }
        ]
      },
      {
        "id": "dp_strings",
        "title": "DP on Strings",
        "family": "Advanced Patterns",
        "difficulty": "Expert",
        "description": "Pattern matching and string transformations.",
        "definition": "Specialized DP for strings, handling wildcards, regex, and palindromes.",
        "mentalModel": {
          "analogy": "The Spell Checker",
          "analogyImage": "dp_strings_analogy",
          "realWorldExample": "Google Search showing 'Did you mean...?' by calculating Edit Distance between your query and correct words.",
          "coreInsight": "Comparing prefixes of two strings. The result for string lengths (i, j) depends on results for (i-1, j), (i, j-1), or (i-1, j-1)."
        },
        "visualizerType": "dp_strings",
        "subPatterns": [
          {
            "id": "wildcard_matching",
            "title": "Wildcard / Regex Matching",
            "description": "Match strings with '*' and '?' or '.' tokens.",
            "signals": [
              "Regex support",
              "Variable length matching"
            ],
            "invariant": "Recursive choices for '*' (match zero or match one)."
          }
        ]
      },
      {
        "id": "trie",
        "title": "Trie",
        "family": "Advanced Patterns",
        "difficulty": "Expert",
        "description": "Prefix tree for string reTRIEval.",
        "definition": "A tree-like data structure used to store a dynamic set or associative array where the keys are usually strings, allowing for efficient prefix searches.",
        "mentalModel": {
          "analogy": "The Autocomplete Dictionary",
          "analogyImage": "trie_analogy",
          "realWorldExample": "A dictionary where you look up 'APP', then 'APPLE', then 'APPLY'; they all share the same prefix 'APP'.",
          "coreInsight": "Each node represents a character. Shared prefixes share nodes, saving space and making prefix lookup O(L) where L is word length."
        },
        "visualizerType": "trie",
        "subPatterns": [
          {
            "id": "prefix_search",
            "title": "Prefix / Word Search",
            "description": "Check if any word starts with a given prefix.",
            "signals": [
              "Dictionary lookup",
              "Autocomplete"
            ],
            "invariant": "Each node has a child mapping (Map or Array[26]) and an isEndOfWord boolean."
          }
        ]
      },
      {
        "id": "segment_tree",
        "title": "Segment Tree",
        "family": "Advanced Patterns",
        "difficulty": "Expert",
        "description": "Tree for range queries.",
        "definition": "A tree data structure for storing intervals or segments, allowing for efficient range queries (sum, min, max) and point updates in O(log N).",
        "mentalModel": {
          "analogy": "The Tournament Bracket",
          "analogyImage": "segment_tree_analogy",
          "realWorldExample": "Tracking the high score in a leaderboard for specific regions of the list.",
          "coreInsight": "Divide the range into halves. Each node stores the pre-calculated answer for its range. To query, combine answers from relevant sub-ranges."
        },
        "visualizerType": "segment_tree",
        "subPatterns": [
          {
            "id": "range_sum",
            "title": "Range Sum Query",
            "description": "Calculate sum in range [L, R] with updates.",
            "signals": [
              "Frequent updates",
              "Range queries"
            ],
            "invariant": "Node value = leftChild.value + rightChild.value"
          }
        ]
      },
      {
        "id": "graph_advanced",
        "title": "Shortest Path & MST",
        "family": "Advanced Patterns",
        "difficulty": "Expert",
        "description": "Dijkstra, Prim, Kruskal.",
        "definition": "Advanced graph algorithms for finding the shortest path between nodes or the minimum spanning tree of a weighted graph.",
        "mentalModel": {
          "analogy": "The Postal Route Optimizer",
          "analogyImage": "graph_advanced_analogy",
          "realWorldExample": "Google Maps finding the fastest way home; National Grid connecting cities with minimum cable length.",
          "coreInsight": "Use Priority Queues to always pick the 'cheapest' next step (Greedy + BFS logic)."
        },
        "visualizerType": "graph_advanced",
        "subPatterns": [
          {
            "id": "dijkstra",
            "title": "Dijkstra's (Shortest Path)",
            "description": "Find shortest path in graphs with non-negative weights.",
            "signals": [
              "Weighted graph",
              "Single source shortest path"
            ],
            "invariant": "Once a node is popped from the Priority Queue, its shortest path from the source is finalized."
          },
          {
            "id": "kruskals",
            "title": "Kruskal's (Min Spanning Tree)",
            "description": "Find minimum cost to connect all nodes using Union-Find.",
            "signals": [
              "Connect all nodes",
              "Minimum cost",
              "Edges weights"
            ],
            "invariant": "Sort edges by weight and add if they don't form a cycle (using DSU)."
          }
        ]
      },
      {
        "id": "string_matching",
        "title": "String Matching",
        "family": "Advanced Patterns",
        "difficulty": "Expert",
        "description": "KMP, Rabin-Karp.",
        "definition": "Algorithms used to find one or more occurrences of a pattern string within a larger text string efficiently.",
        "mentalModel": {
          "analogy": "The Search Engine Finder",
          "analogyImage": "string_matching_analogy",
          "realWorldExample": "Control+F search in a document; DNA sequence mapping.",
          "coreInsight": "KMP: Use information from previous matches to avoid re-checking characters. Rabin-Karp: Use hashing to quickly compare substrings."
        },
        "visualizerType": "string_matching",
        "subPatterns": [
          {
            "id": "kmp",
            "title": "KMP (Knuth-Morris-Pratt)",
            "description": "Pattern matching in O(N+M) using LPS array.",
            "signals": [
              "Sub-pattern search",
              "Linear time requirement"
            ],
            "invariant": "LPS[i] = length of the longest proper prefix of pattern[0..i] that is also a suffix of pattern[0..i]."
          }
        ]
      }
    ]
  }
]